<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HTML基础知识</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/22/myworkspaces/readnotes/html/html/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/22/myworkspaces/readnotes/html/html/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML基础知识"><a href="#HTML基础知识" class="headerlink" title="HTML基础知识"></a>HTML基础知识</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>HTML是超文本标记语言。</li><li>HTML使用标记标签描述网页。</li></ul><hr><h2 id="常见标签"><a href="#常见标签" class="headerlink" title="常见标签"></a>常见标签</h2><p>html：通过<code>&lt;html&gt;</code>标记整个HTML文档。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    Here is the whole html document<br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>主体：通过<code>&lt;body&gt;</code>标记HTML文档主体。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    Here is html body<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>标题：通过<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>标签进行标记的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>H1 title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>H2 title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure><p>段落：通过<code>&lt;p&gt;</code>进行标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>paragraph 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>链接：通过<code>&lt;a&gt;</code>标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://cn.bing.com&quot;</span>&gt;</span>Bing!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>图像：通过<code>&lt;img&gt;</code>标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;wallpapers.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;1024&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;1024&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>其中参见：<a href="https://www.w3school.com.cn/tags/index.asp">HTML 标签参考手册</a></p><hr><h2 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h2><ul><li>HTML元素指的是开始标签和结束标签之间的内容。</li><li>某些HTML元素具有空内容，空内容在开始标签结束。</li></ul><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here is html element<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span> <span class="hljs-comment">&lt;!--here is no html element--&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h2><ul><li>属性给HTML元素提供附加信息。</li><li>属性总是在HTML元素开始标签中规定的。</li><li>属性以键值对形式出现：<code>key=&quot;value&quot;</code>。</li><li>属性中的值是包含在“双引号”中的，若其中存在双引号，则可以使用单引号。</li></ul><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>h1 title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><ul><li>使用<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>用来标记标题。其中<code>&lt;h1&gt;</code>最大，<code>&lt;h6&gt;</code>最小。</li><li>浏览器会自动在标题前后添加空行。</li></ul><p>空行：通过<code>&lt;hr/&gt;</code>在页面中创建水平线。用来分割内容。</p><p>注释：通过<code>&lt;!----&gt;</code>表示注释，会被浏览器忽略不被展示在页面中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--here is a comment--&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><ul><li>使用<code>&lt;p&gt;</code>进行标记一个新的段落。</li><li>浏览器会自动在段落前后添加空行。</li><li>不要用<code>&lt;p&gt;</code>生成空行，而使用专门的<code>&lt;br/&gt;</code>标签。</li></ul><hr><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>style属性用于改变HTML元素的样式。</p><p>可以在独立的样式表(CSS)中进行定义。</p><p>一些标签和属性是废弃的，推荐使用样式进行配置。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 背景颜色 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:red&quot;</span>&gt;</span>This is h1 title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 字体、大小 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-family:arial;font-size:20px&quot;</span>&gt;</span>this is h1 title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 对齐方式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align:center&quot;</span>&gt;</span>this is h1 title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="文本格式化"><a href="#文本格式化" class="headerlink" title="文本格式化"></a>文本格式化</h2><p>使用不同的标签对文本进行格式化：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>This text is bold<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>This text is strong<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">big</span>&gt;</span>This text is big<span class="hljs-tag">&lt;/<span class="hljs-name">big</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>This text is emphasized<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>This text is italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>This text is small<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br>This text contains<br><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>subscript<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br>This text contains<br><span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>superscript<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="预格式文本"><a href="#预格式文本" class="headerlink" title="预格式文本"></a>预格式文本</h3><p>使用<code>&lt;pre&gt;</code>格式进行对空格和换行控制。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><br>    new line is     maintain.<br>    this is a new line.<br><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br><br>this is a line.<br>without new line.<br></code></pre></td></tr></table></figure><h3 id="计算机输出标签"><a href="#计算机输出标签" class="headerlink" title="计算机输出标签"></a>计算机输出标签</h3><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>Computer code<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">kbd</span>&gt;</span>Keyboard input<span class="hljs-tag">&lt;/<span class="hljs-name">kbd</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tt</span>&gt;</span>Teletype text<span class="hljs-tag">&lt;/<span class="hljs-name">tt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">samp</span>&gt;</span>Sample text<span class="hljs-tag">&lt;/<span class="hljs-name">samp</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">var</span>&gt;</span>Computer variable<span class="hljs-tag">&lt;/<span class="hljs-name">var</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>展示地址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:example@mail.com&quot;</span>&gt;</span>contract me<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="缩写和首字母缩写"><a href="#缩写和首字母缩写" class="headerlink" title="缩写和首字母缩写"></a>缩写和首字母缩写</h3><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">abbr</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;etcetera&quot;</span>&gt;</span>etc.<span class="hljs-tag">&lt;/<span class="hljs-name">abbr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">acronym</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;World Wide Web&quot;</span>&gt;</span>WWW<span class="hljs-tag">&lt;/<span class="hljs-name">acronym</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- dfn用于定义项目或缩写的定义 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dfn</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;world wide web&quot;</span>&gt;</span>www<span class="hljs-tag">&lt;/<span class="hljs-name">dfn</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="文字方向"><a href="#文字方向" class="headerlink" title="文字方向"></a>文字方向</h3><p>通过<code>&lt;bdo&gt;</code>控制文字的方向：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 从右向左输出 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bdo</span> <span class="hljs-attr">dir</span>=<span class="hljs-string">&quot;rtl&quot;</span>&gt;</span><br>Here is some Hebrew text<br><span class="hljs-tag">&lt;/<span class="hljs-name">bdo</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h3><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span><br>    This is block quote.<br><span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">q</span>&gt;</span><br>    This is short quote.<br><span class="hljs-tag">&lt;/<span class="hljs-name">q</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="插入-删除特效"><a href="#插入-删除特效" class="headerlink" title="插入/删除特效"></a>插入/删除特效</h3><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 删除 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>delete me<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 插入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ins</span>&gt;</span>insert me<span class="hljs-tag">&lt;/<span class="hljs-name">ins</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">cite</span>&gt;</span>here is a cite message<span class="hljs-tag">&lt;/<span class="hljs-name">cit</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.w3school.com.cn/index.html">W3school</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux的Namespace介绍</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/mydocker/linux_namespace/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/mydocker/linux_namespace/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux的Namespace介绍"><a href="#Linux的Namespace介绍" class="headerlink" title="Linux的Namespace介绍"></a>Linux的Namespace介绍</h1><p>Linux的Namespace是Linux内核提供的功能，用于<strong>隔离系统资源</strong>：如PID，UID，Network等。</p><p>按照UID进行隔离，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>折腾ArchLinux触控板小记</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/linux/touchpadsettings/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/linux/touchpadsettings/</url>
    
    <content type="html"><![CDATA[<h1 id="折腾ArchLinux触控板小记"><a href="#折腾ArchLinux触控板小记" class="headerlink" title="折腾ArchLinux触控板小记"></a>折腾ArchLinux触控板小记</h1><blockquote><p>环境：<br>Description:    Manjaro Linux<br>Release:    21.0.7<br>Codename:    Ornara</p></blockquote><ol><li>将用户加入到input群组：<code>sudo gpasswd -a $USER input</code>。</li><li>添加依赖：<code>sudo pacman -S wmctrl xdotool</code>。</li><li>安装libinput-gestures：<code>sudo pacman -s libinput-gestures</code>。</li><li>配置文件：默认的配置文件位于<code>/etc/libinput-gestures.conf</code>，添加如下配置：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">gesture swipe left 4 xdotool key super+Left # 4指左划: 切换到左侧工作区<br>gesture swipe right 4 xdotool key super+Right # 4指右划: 切换到右侧工作区<br><br>gesture swipe left 3 xdotool key alt+Left # 3指左划: 浏览器后退<br>gesture swipe right 3 xdotool key alt+Right # 3指右划: 浏览器前进<br>gesture swipe up 3 xdotool key F5 # 3指上划: 刷新当前页面<br>gesture swipe down 3 xdotool key ctrl+w # 3指下划: 关闭当前页面<br><br>gesture pinch in 2 xdotool key ctrl+minus # 2指捏: 缩小<br>gesture pinch out 2 xdotool key ctrl+plus # 2指张: 放大<br></code></pre></td></tr></table></figure></li><li>启动应用：<code>libinput-gestures-setup service</code>，作为系统服务。</li><li>设置开启启动，并立即启动：<code>libinput-gestures-setup autostart start</code>。</li><li>若配置不生效，则重启：<code>libinput-gestures-setup restart</code>。</li></ol><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://wiki.archlinux.org/title/Libinput">libinput ArchLinux</a></li><li><a href="https://github.com/bulletmark/libinput-gestures/blob/master/README.md">LIBINPUT-GESTURES</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>问题集</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/questions/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/questions/</url>
    
    <content type="html"><![CDATA[<h1 id="问题集"><a href="#问题集" class="headerlink" title="问题集"></a>问题集</h1><hr><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><ul><li>为什么要编译程序，编译前后程序之间的关系？</li><li>编程语言如何通过变量名找到变量在内存的地址？<ul><li><a href="https://www.zhihu.com/question/20086414">程序如何根据变量名在内存中找到存放这个变量的地址？</a></li></ul></li><li>Android如何实现在子线程中异步执行耗时任务，并且每个任务可以设置超时时间。任务任务完成</li><li>并发问题：<ul><li>如何并发访问资源</li><li>如何实现线程之间的协作</li><li>如何判断共享资源是否已被占用（已被加锁）</li><li>如何设置超时协程（通过channel和select语句)</li></ul></li></ul><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>学习资源总结</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/study_resources/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/study_resources/</url>
    
    <content type="html"><![CDATA[<h1 id="学习资源总结"><a href="#学习资源总结" class="headerlink" title="学习资源总结"></a>学习资源总结</h1><p>[toc]</p><hr><h2 id="公开课"><a href="#公开课" class="headerlink" title="公开课"></a>公开课</h2><ul><li><a href="http://dsg.csail.mit.edu/6.830/">MIT6.830/6.814</a></li><li><a href="">MIT6.046J</a></li><li><a href="">MIT6.852J</a></li></ul><hr><h2 id="在线资源"><a href="#在线资源" class="headerlink" title="在线资源"></a>在线资源</h2><ul><li><a href="http://ddia.vonng.com/#/">设计数据密集型应用 - 中文翻译</a></li><li><a href="https://leeshengis.com/">JUST DO IT</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>确定有限状态自动机</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/algorithm/deterministic_finite_automaton/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/algorithm/deterministic_finite_automaton/</url>
    
    <content type="html"><![CDATA[<h1 id="确定有限状态自动机"><a href="#确定有限状态自动机" class="headerlink" title="确定有限状态自动机"></a>确定有限状态自动机</h1><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A simple deterministic finite automation implementation</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DFA</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransitionFunction</span> </span>&#123;<br>        Map&lt;Integer, Map&lt;Character, Integer&gt;&gt; tf = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <br>        TransitionFunction(<span class="hljs-keyword">int</span>[][] states, <span class="hljs-keyword">char</span>[] alphabet) &#123;<br>            <span class="hljs-keyword">if</span> (states.length != alphabet.length) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">int</span> len = states.length;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>                <span class="hljs-keyword">int</span> startState = states[i][<span class="hljs-number">0</span>], endState = states[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">char</span> input = alphabet[i];<br>                <span class="hljs-keyword">if</span> (!tf.containsKey(startState)) &#123;<br>                    Map&lt;Character, Integer&gt; aRule = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>                    aRule.put(input, endState);<br>                    tf.put(startState, aRule);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tf.get(startState).containsKey(input)) &#123;<br>                    tf.get(startState).put(input, endState);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getNextState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> currentState, <span class="hljs-keyword">char</span> input)</span> </span>&#123;<br>            Integer res = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> (tf.containsKey(currentState) &amp;&amp; tf.get(currentState).containsKey(input)) &#123;<br>                res = tf.get(currentState).get(input);<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Set&lt;Integer&gt; states = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Set&lt;Integer&gt; acceptStates = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Set&lt;Character&gt; alphabet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">private</span> TransitionFunction tf;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentState;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DFA</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] transitionFunction, <span class="hljs-keyword">char</span>[] input, <span class="hljs-keyword">int</span>[] accpetStates, <span class="hljs-keyword">int</span> startState)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] t : transitionFunction) &#123;<br>            states.add(t[<span class="hljs-number">0</span>]);<br>            states.add(t[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : input) &#123;<br>            alphabet.add(c);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : accpetStates) &#123;<br>            <span class="hljs-keyword">this</span>.acceptStates.add(i);<br>        &#125;<br>        tf = <span class="hljs-keyword">new</span> TransitionFunction(transitionFunction, input);<br>        currentState = startState;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inputCharacter</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>        currentState = tf.getNextState(currentState, c) != <span class="hljs-keyword">null</span> ? tf.getNextState(currentState, c) : currentState;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inputString</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) inputCharacter(c);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccept</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> acceptStates.contains(currentState);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.nosuchfield.com/2017/01/05/Finite-automaton/">计算机的计算（一） - 有限自动机</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hash函数</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/algorithm/hash_function/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/algorithm/hash_function/</url>
    
    <content type="html"><![CDATA[<h1 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h1><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hash函数：将任意长度的数据映射成固定长度的值。</p><p>Hash函数需要满足两个特性：</p><ol><li>计算快速，在常数时间内完成计算。</li><li>尽可能降低不同输入产生重复值的概率。（使用输入的每一位，对聚集的key进行分离）</li></ol><hr><h2 id="常见的Hash函数实现"><a href="#常见的Hash函数实现" class="headerlink" title="常见的Hash函数实现"></a>常见的Hash函数实现</h2><p><em>m</em>假定为哈希表的长度。</p><ul><li>Division Hashing: <em>h(x) = x mod m</em>。</li><li>Multiplicative Hashing: <em>h(x) = (a x) mod m</em>，或者<em>h(x) = ((ax) mod p) mod m</em>。其中<em>a</em>和<em>p</em>为大素数。</li><li>Linear Hashing: <em>h(x) = ax + b mod m</em>或<em>h(x) = ((ax+b) mod p) mod m</em>，其中<em>a</em>,<em>b</em>和<em>p</em>是大素数。</li></ul><p>注意：</p><ul><li><em>m</em>常为2的幂次，若只对<em>m</em>取余则只有低位才能对最终结果产生影响，所以采用两次取余。</li><li>采用大素数<em>p</em>：<em>p</em>较小则导致取余的结果落在一个小的取值范围内，导致发生碰撞的概率增大。取素数是为了尽可能使得输出的结果分布均匀。</li></ul><p><img src="../../../imgs/modnumber.png"></p><ul><li>Polynomial Hashing: 当输入为一个数值序列时，计算其多项式比较方便：<em>x=(c0,c1,c2,…)<em>，</em>p</em>为合适的素数，则<em>h(x)=(c0 + c1p + c2p^2 + …) mod m</em>。</li></ul><p><strong>Hornel’s rule</strong>常用于多项式的计算：<em>h(x) = c0 + c1x + c2x^2 + …cnx^n</em> –&gt; <em>h(x) = c0 + x(c1 + x(c2 + x( … + x(c{n-1} + cnx)…)<em>。<br>使用<strong>Hornel’s rule</strong>可以减少乘法的次数，对于一个</em>n</em>次的多项式<em>h(x) = c0 + c1x + c2x^2 + … cnx^n</em>，需要<em>2n - 1</em>次乘法，而使用<strong>Hornel’s rule</strong>仅需要<em>n</em>次乘法。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hornelRule</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] params, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> prev = <span class="hljs-number">0</span>, n = params.length;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>    <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) prev = x * (prev + params[i]);<br>    <span class="hljs-keyword">else</span> prev += params[i];<br>&#125;<br><span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="随机化"><a href="#随机化" class="headerlink" title="随机化"></a>随机化</h2><p>一般情况下，输入的统计分布情况未知，所以没有一个完美的Hash函数。出现哈希碰撞在所难免。通过随机化可以降低哈希碰撞的概率。</p><ul><li>事先设置一系列备选的Hash函数。</li><li>对于每个输入，通过一个随机数确定选择对应Hash函数。</li><li>每个Hash函数被选中的概率相当。</li></ul><p><strong>Carter&amp;Wegman哈希函数</strong>：</p><ul><li>选择一个大素数<em>p</em>。</li><li>选择一个随机数<em>a</em>,取值范围在*{1,2, …, p - 1}*。</li><li>选择一个随机数<em>b</em>,取值范围在*{0,1,2,…,p - 1}*。</li><li>Hash函数为<em>h(x) = ((ax + b) mod p) mod m</em>。</li></ul><hr><h2 id="解决哈希冲突问题"><a href="#解决哈希冲突问题" class="headerlink" title="解决哈希冲突问题"></a>解决哈希冲突问题</h2><h3 id="分离链接法-separate-chaining"><a href="#分离链接法-separate-chaining" class="headerlink" title="分离链接法(separate chaining)"></a>分离链接法(separate chaining)</h3><ul><li>哈希表是一个长度为<em>m</em>的数组。</li><li>相同的哈希值的元素保存在数组相同位置，使用一个链表将同一位置的元素链接起来。</li></ul><p>图示：<br><img src="../../../imgs/separatechaining.png"></p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://en.wikipedia.org/wiki/Hash_function">Hash function</a></li><li><a href="https://www.cs.umd.edu/class/fall2019/cmsc420-0201/index.html">CMSC 420 - 0201 Data Structures Fall 2019 Dave Mount</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>预编译语句(prepared statement)</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/database/prepared_statement/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/database/prepared_statement/</url>
    
    <content type="html"><![CDATA[<h1 id="预编译语句-prepared-statement"><a href="#预编译语句-prepared-statement" class="headerlink" title="预编译语句(prepared statement)"></a>预编译语句(prepared statement)</h1><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>预编译语句：用于预编译成SQL代码。通过使用一个<strong>预先编译的模板</strong>和每次执行时传入的数据将组合成目标SQL语句。</p><p>优势：</p><ol><li>效率：无需编译重复执行。</li><li>安全：减少SQL注入问题。</li></ol><hr><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>生成一个预编译语句的基本流程如下：</p><ol><li><strong>准备</strong>：应用创建一个语句模板并发送给数据库，其中某些特定值没有指定，而是使用占位符(placeholder)进行表示（<em>MySQL中使用问号?表示一个参数</em>，示例：<code>INSERT INTO user (name, age) VALUES (?, ?);</code>）</li><li><strong>编译</strong>：数据库对于语句模板进行编译（<em>分割、优化、转换等</em>），存储编译后的结果但不执行。</li><li><strong>执行</strong>：应用向数据库针对特定语句模板提供数据，数据库执行SQL语句并返回结果。应用可能对同一个语句模板执行多个请求。</li></ol><hr><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li>预编译语句的两点优势：效率和减少SQL注入的原理是怎样的？</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://en.wikipedia.org/wiki/Prepared_statement">Prepared statement</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git基础</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/git/git_basics/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/git/git_basics/</url>
    
    <content type="html"><![CDATA[<h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><p>[toc]</p><hr><h2 id="以图形化的方式显示分支"><a href="#以图形化的方式显示分支" class="headerlink" title="以图形化的方式显示分支"></a>以图形化的方式显示分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --graph --oneline --abbrev-commit --all<br></code></pre></td></tr></table></figure><hr><h2 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h2><p>可以通过两种方式撤销更改：</p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a><code>git revert</code></h3><blockquote><p>虽然可以通过<code>git reset</code>或<code>git rebase -i</code>从历史记录中撤销之前的提交，但是可能导致其他参与者的本地仓库与远程仓库之间不同步。</p></blockquote><p>通过<code>git revert</code>可以对已经提交的更改进行撤销。</p><p>代码示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git revert &lt;指定的commit-id&gt; # 若没有冲突，则填写commit message进行提交<br></code></pre></td></tr></table></figure><p>若发生冲突，则需要解决冲突：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git status # 查看冲突情况<br><span class="hljs-meta">#</span><span class="bash"> 修改对应的文件，解决冲突</span><br>git add &lt;冲突文件&gt; # 或 git rm &lt;冲突文件&gt; 移除冲突文件<br>git revert --continue # 继续完成revert<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>git revert</code>是对特定的commit进行撤销，相当于对于该commit的更改进行撤销并<strong>生成一个commit成为历史记录中最新的commit</strong>。可以撤销特定commit的同时并保留其后的更改。</li></ul><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a><code>git reset</code></h3><p><code>git reset</code>：将当前的HEAD指针重置到特定的状态。</p><p>三种模式：</p><ul><li><code>--soft</code>：将HEAD指针移动到指定的位置，不会更改工作区和暂存区中的内容。移动HEAD指针导致的更改放置在暂存区作为未提交的修改。</li><li><code>--hard</code>：将HEAD指针移动到指定的位置，使得工作区和暂存区完全为指定位置的状态。（若工作区有为添加的更改，暂存区有未提交的修改都会丢失）</li><li><code>--mixed</code>(默认)：将HEAD指针移动到指定的位置，暂存区的内容会被移除，<strong>工作区未添加的更改，暂存区未提交的修改，由移动HEAD指针导致的无效的更改都会被放在工作区</strong>。</li></ul><hr><h2 id="与远程仓库同步"><a href="#与远程仓库同步" class="headerlink" title="与远程仓库同步"></a>与远程仓库同步</h2><p>通过远程仓库可以使得不同的开发者协作开发。</p><p>常用的同步操作：</p><ul><li><code>git push</code>: 将本地的提交同步到远程仓库中。<ul><li><code>git push origin *:*</code>：将本地的分支推送到远程的同名分支上。</li></ul></li><li><code>git pull</code>: 拉取远程仓库的commit到本地仓库中。<ul><li><code>git pull origin master1:master2</code>：将远程仓库的<code>master1</code>分支拉取下来与本地的<code>master2</code>分支合并。</li></ul></li><li><code>git merge</code>: 在拉取远程仓库到本地时，若本地仓库</li></ul><hr><h2 id="git-pull发生冲突"><a href="#git-pull发生冲突" class="headerlink" title="git pull发生冲突"></a><code>git pull</code>发生冲突</h2><p>当使用<code>git push</code>时无法提交，通过<code>git pull</code>拉取最新提交时提示冲突：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">CONFLICT (content): Merge conflict in XXX<br>error: Failed to merge in the changes.<br></code></pre></td></tr></table></figure><p>此时通过<code>git branch -av</code>检查当前所处的分支：<code>(no branch, rebasing master)</code>。git会自动切换到匿名分支。</p><p>解决冲突流程：</p><ol><li>检查发生冲突的文件：<code>git status</code>。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Unmerged paths:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br>  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)<br><br>both modified:   file1<br></code></pre></td></tr></table></figure></li><li>解决冲突。编辑冲突文件，删除git在文件中生成的标识符。（将&lt;&lt;&lt;、===和&gt;&gt;&gt;删除）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>本地更改内容<br>=======<br>远程仓库拉取内容<br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;&gt;&gt;&gt;&gt; from remote</span><br></code></pre></td></tr></table></figure></li><li>添加修改：<code>git add &lt;修改的文件&gt;</code>。</li><li>合并修改：<code>git rebase --continue</code>。</li><li>向远程仓库提交修改：<code>git push origin master</code></li></ol><hr><h2 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h2><p>某些情况下，需要对已经提交的commit进行修改。可能需要更改特定提交，改变提交的顺序甚至到将不同的提交合并到一起。</p><h3 id="git-commit-amend"><a href="#git-commit-amend" class="headerlink" title="git commit --amend"></a><code>git commit --amend</code></h3><p>通过<code>git commit --amend</code>命令可以对当前分支的最新commit进行修改。</p><blockquote><p>若已经<code>git push</code>提交到远程仓库的commit，在<code>git commit --amend</code>后进行提交会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hint: Updates were rejected because the tip of your current branch is behind its remote counterpart. Integrate the remote changes<br></code></pre></td></tr></table></figure><p>可以通过<code>git push -f</code>强制推送更改。注意：<strong>这可能导致远程仓库中的commit历史记录丢失</strong>。</p><blockquote><p><code>git push -f</code>基本原理：<br><code>git push</code>将本地commit提交到远程仓库时，会检查远程仓库的ref是否是本地仓库的祖先。若是则正常推送，否则拒绝推送。而<code>-f</code>选项将该检查关闭，强制推送至远程仓库。</p></blockquote></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.jianshu.com/p/c2ec5f06cf1a">Git Reset 三种模式</a></li><li><a href="https://backlog.com/git-tutorial/undoing-changes/">Undoing changes</a></li><li><a href="https://morningspace.github.io/tech/git-merge-stories-1/">Git合并那些事——认识几种Merge方法</a></li><li><a href="https://backlog.com/git-tutorial/what-is-git/">What is git?</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分支</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/git/git_branch/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/git/git_branch/</url>
    
    <content type="html"><![CDATA[<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>[toc]</p><hr><h2 id="将分支移动特定提交"><a href="#将分支移动特定提交" class="headerlink" title="将分支移动特定提交"></a>将分支移动特定提交</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -f &lt;分支名&gt; &lt;commit-id&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="将HEAD设置到指定的提交"><a href="#将HEAD设置到指定的提交" class="headerlink" title="将HEAD设置到指定的提交"></a>将HEAD设置到指定的提交</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard &lt;commit-id&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="HEAD游离-HEAD-detached-from-XXX"><a href="#HEAD游离-HEAD-detached-from-XXX" class="headerlink" title="HEAD游离(HEAD detached from XXX)"></a>HEAD游离(HEAD detached from XXX)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout &lt;分支名&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git rebase小结</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/git/git_rebase/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/git/git_rebase/</url>
    
    <content type="html"><![CDATA[<h1 id="git-rebase小结"><a href="#git-rebase小结" class="headerlink" title="git rebase小结"></a><code>git rebase</code>小结</h1><p>[toc]</p><hr><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>git rebase</code>主要用来<strong>将一个分支合并到另一个分支</strong>。<br>核心思想：<code>git rebase</code>是在被合并的分支上以创建新提交的方式使得当前分支上不同的修改得以应用。</p><blockquote><p>使用<code>git rebase</code>命令的场景：<br>在合并两个分支时需要保证合并后分支具有<strong>完整的历史记录</strong>。在发生问题时，可以通过提交历史快速定位到提交记录。</p></blockquote><h2 id="git-rebase可以做什么？"><a href="#git-rebase可以做什么？" class="headerlink" title="git rebase可以做什么？"></a><code>git rebase</code>可以做什么？</h2><ul><li>重写历史记录中特定的commit</li><li>将一系列commit整合成一个commit</li><li>以及几乎一切编辑提交历史记录的操作</li></ul><hr><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="1-将一个分支的提交应用到另一个分支上"><a href="#1-将一个分支的提交应用到另一个分支上" class="headerlink" title="1. 将一个分支的提交应用到另一个分支上"></a>1. 将一个分支的提交应用到另一个分支上</h3><p>假设当前的分支状态如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">* c4        (master)<br><span class="hljs-string">|    * c3   (HEAD -&gt; branch1)</span><br><span class="hljs-string">|   /</span><br>* c2<br><span class="hljs-string">|</span><br><span class="hljs-string">|</span><br>* c1<br></code></pre></td></tr></table></figure><p>假设当前所处的分支为<code>branch1</code>，则执行<code>git rebase master</code>，则将<code>master</code>分支的提交应用到<code>branch1</code>分支上。即将提交c4应用到分支<code>branch1</code>上，结果为：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-symbol">*</span> c3&#x27;   (HEAD -&gt; branch1)<br>|<span class="hljs-string"></span><br><span class="hljs-string"></span>|<br><span class="hljs-symbol">*</span> c4    (master)<br>|<span class="hljs-string"></span><br><span class="hljs-string"></span>|<br><span class="hljs-symbol">*</span> c2<br>|<span class="hljs-string"></span><br><span class="hljs-string"></span>|<br><span class="hljs-symbol">*</span> c1<br></code></pre></td></tr></table></figure><h3 id="2-git-rebase合并时发生冲突的处理"><a href="#2-git-rebase合并时发生冲突的处理" class="headerlink" title="2. git rebase合并时发生冲突的处理"></a>2. <code>git rebase</code>合并时发生冲突的处理</h3><ol><li><code>git rebase master</code>：将<code>master</code>分支合并到当前分支。显示发生冲突：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">CONFLICT (content): Merge conflict in XXX<br>error: Failed to merge in the changes.<br></code></pre></td></tr></table></figure></li><li>查看发生冲突的文件：<code>git status</code>：(两个分支都对同一个文件进行修改)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Unmerged paths:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br>  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)<br><br>both modified:   file8<br></code></pre></td></tr></table></figure></li><li>解决冲突：对冲突文件修改，删除git自动生成的冲突标识符。</li><li><code>git add &lt;修改的文件&gt;</code>：添加修改。</li><li><code>git rebase --continue</code>：继续完成<code>rebase</code>操作。</li></ol><hr><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="移动指定区间的提交记录"><a href="#移动指定区间的提交记录" class="headerlink" title="移动指定区间的提交记录"></a>移动指定区间的提交记录</h3><ol><li>删除部分区间的提交记录<br>假设当前的提交历史记录如下，需要删除c2、c3：<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"> * -- * -- * -- * <br><span class="hljs-keyword">c</span><span class="hljs-number">1</span>   <span class="hljs-keyword">c</span><span class="hljs-number">2</span>   <span class="hljs-keyword">c</span><span class="hljs-number">3</span>   <span class="hljs-keyword">c</span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 确定目标位置，需要移动的起点、终点</span><br><span class="hljs-meta">#</span><span class="bash"> 目标位置为c1，起始点为c3，终点为c4(默认不包含起始点)</span><br><span class="hljs-meta">#</span><span class="bash"> 格式：git rebase --onto 目标位置 起始点 终点</span><br>git rebase --onto c1 c3 c4<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 此时当前分支处于游离状态，将其指向HEAD</span><br><span class="hljs-meta">#</span><span class="bash"> 格式：git branch -f &lt;之前所处的分支&gt; &lt;目标位置&gt;</span><br>git branch -f master HEAD<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 切换到目标分支</span><br>git checkout master<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">* -- *<br><span class="hljs-keyword">c</span><span class="hljs-number">1</span>  <span class="hljs-keyword">c</span><span class="hljs-number">4</span>&#x27;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>虽然是将指定的一段提交记录移动到指定位置，实际上是在指定位置上<strong>生成新的相同内容的提交记录</strong>。（通过commit id可以看出新的提交与之前的提交并不同）</li><li>当起始点和终点相同时，则只会将HEAD移动到目标位置。</li></ul><hr><h2 id="交互式rebase"><a href="#交互式rebase" class="headerlink" title="交互式rebase"></a>交互式<code>rebase</code></h2><p><code>rebase</code>中的选项<code>-i</code>提供交互式的修改提交历史的能力。</p><h3 id="删除特定提交"><a href="#删除特定提交" class="headerlink" title="删除特定提交"></a>删除特定提交</h3><p>在交互式的<code>rebase</code>中，可以在编辑器中编辑指定范围内的提交历史记录。可以删除特定的提交记录，但可能需要解决冲突问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase -i HEAD~5  # 展示最近的5条提交记录<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 在编辑器中，可以在要删除的记录将其`pick`改为`drop`，保存后退出即可自动完成rebase</span><br></code></pre></td></tr></table></figure><h3 id="将多个提交合并为一个提交"><a href="#将多个提交合并为一个提交" class="headerlink" title="将多个提交合并为一个提交"></a>将多个提交合并为一个提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase -i HEAD~3<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 在编辑器中修改需要更改的提交记录：</span><br><span class="hljs-meta">#</span><span class="bash"> 例如，修改之前为：</span><br>pick 0638ae8 hello, file9<br>pick 31ccb80 hello, file10<br>pick 258a3d2 hello, file11<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 需要将这三个提交合并为一个提交，则改为：</span><br>pick 0638ae8 hello, file9<br>squash 31ccb80 hello, file10<br>squash 258a3d2 hello, file11<br><span class="hljs-meta">#</span><span class="bash"> 保存退出，然后在随后弹出的编辑器中编写commit message</span><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase">git rebase</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/array_slices/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/array_slices/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>[toc]</p><hr><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><code>[n]T</code>为一个数组，数据类型为<code>T</code>，数组长度为<code>n</code>。</p><blockquote><ul><li>数组长度一旦确定下来就不可改动。</li><li><strong>数组的长度是其类型的一部分，<code>[2]int</code>和<code>[3]int</code>是不同的类型</strong>。</li><li>在内存中，<code>[n]int</code>使用连续的<code>n</code>个整数int进行表示。</li><li>若没有对数组初始化，则其会被赋予零值。</li><li>可以不指定数组的长度，由编译器根据初始化数据进行判断</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := [<span class="hljs-number">2</span>]<span class="hljs-keyword">string</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;zhangsan&quot;</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;lisi&quot;</span><br><br>iarr = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br>arr1 := [...]<span class="hljs-keyword">string</span> &#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>&#125; <span class="hljs-comment">// arr1的类型：[3]string</span><br></code></pre></td></tr></table></figure><hr><h2 id="切片-slices"><a href="#切片-slices" class="headerlink" title="切片(slices)"></a>切片(slices)</h2><ul><li>切片是一种以动态的视角看待数组的方式。</li><li>通过对数组截取部分来获得切片。</li><li><code>[]T</code>表示类型为<code>T</code>的切片。</li><li>切片通过指定一个数组的上下标来确定，包含左边界但不包含右边界。</li><li>切片不存储任何数据，只是用来描述数组的指定一段数据。对于数组的修改会反映到对应的切片中，通过切片修改数据也会影响数组。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义</span><br><span class="hljs-keyword">var</span> arr1 []<span class="hljs-keyword">int</span> = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>s1 := arr1[<span class="hljs-number">2</span>: <span class="hljs-number">4</span>] <span class="hljs-comment">// &#123;3, 4&#125;</span><br>s2 := arr1[<span class="hljs-number">0</span>: <span class="hljs-number">1</span>] <span class="hljs-comment">// &#123;1&#125;</span><br><br>arr2 := [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>s3 := arr2[<span class="hljs-number">0</span>: <span class="hljs-number">2</span>] <span class="hljs-comment">// &#123;0, 1&#125;</span><br>s4 := arr2[<span class="hljs-number">1</span>:<span class="hljs-number">1</span>] <span class="hljs-comment">// &#123;&#125; 空切片</span><br></code></pre></td></tr></table></figure><h3 id="切片常量"><a href="#切片常量" class="headerlink" title="切片常量"></a>切片常量</h3><p>如同结构体，切片也可以定义常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">b1 := []<span class="hljs-keyword">bool</span>&#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>&#125;<br><br><span class="hljs-comment">// 定义一个结构体切片</span><br>s1 := []<span class="hljs-keyword">struct</span> &#123;<br>    i   <span class="hljs-keyword">int</span><br>    b   <span class="hljs-keyword">bool</span><br>&#125; &#123;<br>    &#123;<span class="hljs-number">2</span>, <span class="hljs-literal">false</span>&#125;,<br>    &#123;<span class="hljs-number">3</span>, <span class="hljs-literal">true</span>&#125;,<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>&#125;,<br>    &#123;<span class="hljs-number">4</span>, <span class="hljs-literal">false</span>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切片边界默认值"><a href="#切片边界默认值" class="headerlink" title="切片边界默认值"></a>切片边界默认值</h3><p>在创建切片时，可以忽略范围边界的下界和上界，会使用对应的默认值。上界的默认值为数组长度，下界的默认值为0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br>arr1 := arr[:] <span class="hljs-comment">// &#123;1, 2, 3&#125;</span><br>arr2 := arr[:<span class="hljs-number">1</span>] <span class="hljs-comment">// &#123;1&#125;</span><br>arr3 := arr[<span class="hljs-number">1</span>:] <span class="hljs-comment">// &#123;2, 3&#125;</span><br></code></pre></td></tr></table></figure><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><ul><li>每个切片都有其长度和容量。<ul><li>长度表示该切片的所包含的元素个数。</li><li>容量表示切片对应的底层数组的元素个数，从切片的第一个元素开始计算。</li><li>通过<code>len(s)</code>和<code>cap(s)</code>函数可以获得切片<code>s</code>的长度和容量。</li></ul></li><li>可以通过重新切片来调整切片的长度。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">s := []<span class="hljs-keyword">int</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br><br>s1 := s[:<span class="hljs-number">0</span>] <span class="hljs-comment">// &#123;&#125;</span><br><br>s2 := s[<span class="hljs-number">2</span>:] <span class="hljs-comment">// &#123;3, 4, 5, 6, 7&#125;</span><br>s2 = s2[:<span class="hljs-number">2</span>] <span class="hljs-comment">// &#123;3, 4&#125;</span><br>s2 = s2[:<span class="hljs-number">3</span>] <span class="hljs-comment">// &#123;3, 4, 5&#125;</span><br>s2 = s2[:]  <span class="hljs-comment">// &#123;3, 4, 5&#125;</span><br>s2 = s2[:<span class="hljs-number">6</span>] <span class="hljs-comment">// 错误， &#123;3, 4, 5, 6, 7&#125;总共5个元素</span><br></code></pre></td></tr></table></figure><h3 id="切片的默认值"><a href="#切片的默认值" class="headerlink" title="切片的默认值"></a>切片的默认值</h3><p>切片变量的默认值为<code>nil</code>。对应的长度和容量均为0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr <span class="hljs-keyword">int</span>[] <span class="hljs-comment">// nil</span><br><br><span class="hljs-built_in">len</span>(arr) <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">cap</span>(arr) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><h3 id="通过make函数创建切片"><a href="#通过make函数创建切片" class="headerlink" title="通过make函数创建切片"></a>通过<code>make</code>函数创建切片</h3><p>切片可以通过<code>make</code>函数创建，基本形式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// arr := make([]T, len, cap)</span><br><br>arr1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 创建一个长度为5,容量为10的int切片</span><br><br>arr2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 创建一个长度为5,容量为5的int切片</span><br></code></pre></td></tr></table></figure><h3 id="切片的切片"><a href="#切片的切片" class="headerlink" title="切片的切片"></a>切片的切片</h3><p>切片可以包含任何数据类型，包括切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := [][]<span class="hljs-keyword">string</span> &#123;<br>    []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>    []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>&#125;,<br>    []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a>向切片追加元素</h3><p>可以通过<code>append()</code>函数向一个切片中追加元素。基本使用方法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">append</span>(s []T, vs ...T) T[] <span class="hljs-comment">// s为T类型的切片，vs为追加到切片的元素</span><br><br><span class="hljs-keyword">var</span> s <span class="hljs-keyword">int</span>[]         <span class="hljs-comment">// s = [], len = 0, cap = 0</span><br><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)    <span class="hljs-comment">// s = [1], len = 1, cap = 1</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">2</span>)    <span class="hljs-comment">// s = [1, 2], len = 2, cap = 2</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// s = [1, 2, 3, 4, 5], len = 5, cap = 6???</span><br></code></pre></td></tr></table></figure><h3 id="迭代器range"><a href="#迭代器range" class="headerlink" title="迭代器range"></a>迭代器<code>range</code></h3><p>在一个<code>for</code>循环中，通过<code>range</code>函数获得对应切片或map的迭代器。对于切片，<code>range</code>会返回两个值：第一个值为下标index，第二个值为该下标对应的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := [...]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>&#125;<br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr &#123;<br>    fmt.Println(i, j)<br>&#125;<br><span class="hljs-comment">// 结果为：</span><br><span class="hljs-comment">// 0 zero</span><br><span class="hljs-comment">// 1 one</span><br><span class="hljs-comment">// 2 two</span><br></code></pre></td></tr></table></figure><h3 id="忽略range中的部分值"><a href="#忽略range中的部分值" class="headerlink" title="忽略range中的部分值"></a>忽略<code>range</code>中的部分值</h3><p>可以忽略<code>range</code>函数返回的两个值中的任何一个，使用”_”表示要忽略的值。或者只接收下标。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := []<span class="hljs-keyword">int</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-comment">// 只需要值</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 只需要下标</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> arr &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建二维切片"><a href="#创建二维切片" class="headerlink" title="创建二维切片"></a>创建二维切片</h3><p>创建一个<code>dx * dy</code>的二维int切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, dx)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> arr &#123;<br>    arr[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, dy)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li>slice上的<code>append</code>的扩容机制。</li><li>如何创建二维切片<code>[dx][dy]int</code>？</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://go.dev/blog/slices-intro">Go Slices: usage and internals</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/database/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/database/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>[toc]</p><hr><h2 id="连接数据库的基本流程-忽略异常情况"><a href="#连接数据库的基本流程-忽略异常情况" class="headerlink" title="连接数据库的基本流程(忽略异常情况)"></a>连接数据库的基本流程(<em>忽略异常情况</em>)</h2><ol><li>驱动初始化：自定义的数据库驱动通过<code>init()</code>方法进行注册。<ol><li>通过调用<code>sql.Register()</code>方法进行注册。<code>sql.Register()</code>方法在<code>drivers</code>上添加驱动名和驱动实例的键值对。<code>drivers</code>为一个<code>map</code>，key是驱动名(string)，value是驱动实例<code>driver.Driver</code>。（特定数据库的驱动需要实现<code>driver.Driver</code>方法。</li></ol></li><li>获得<code>sql.DB</code>实例：通过<code>sql.Open()</code>方法获得一个<code>sql.DB</code>实例，用于表示一个数据库。<ol><li>首先从<code>drivers</code>中根据驱动名获得对应的驱动实例。</li><li>然后通过驱动实例获得<code>DriverContext</code>（驱动上下文）。</li><li>通过调用<code>DriverContext.OpenConnector()</code>方法获得一个<code>driver.Connector</code>实例。</li><li>调用<code>OpenDB()</code>方法使用<code>driver.Connector</code>获得一个<code>sql.DB</code>实例。（*不会创建真实的数据库连接，返回的<code>sql.DB</code>对象可以在多个协程中并发使用，所以<code>Open()</code>方法只需要调用一次获得全局变量<code>sql.DB</code>*）</li></ol></li><li>查询数据库：通过<code>db.Query()</code>获取数据库中的结果。<ol><li>调用<code>db.QueryContext()</code>方法。其会在当前的数据库连接上重复调用<code>query()</code>方法直到没有返回“bad connection”错误。</li><li><code>query()</code>方法会先通过<code>conn()</code>方法获得一个数据库连接<code>driverConn</code>。(新创建的或缓存的)，然后调用<code>queryDC()</code>方法在给定的连接上执行查询操作。</li></ol></li></ol><hr><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>一般情况下，应用是通过<strong>TCP</strong>连接到数据库服务器并执行请求。<br>通过使用一个连接池将与数据库已建立的连接保存下来，在下次发送请求时就不需要再次建立连接，直接使用连接池中空闲的连接即可完成访问请求。<br>可以通过以下几个参数配置连接池：</p><ul><li>最大打开连接(maximum open connections):任何时刻存在的最多连接数量。</li><li>最大空闲连接(maximum idle connections):任何时刻空闲连接的最大数量。（<em>空闲连接：没有执行请求的连接</em>）</li><li>空闲连接超时(idle connection timeout):连接空闲的最大时间。</li><li>连接生命周期(connection lifetime):一个连接存活的最大时间。</li></ul><p><img src="../../imgs/db_connection_pool.jpg"></p><p>配置方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">db, _ := sql.Open(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;XXXX&quot;</span>)<br><br>db.SetMaxIdleConns(<span class="hljs-number">5</span>)<br>db.SetMaxOpenConns(<span class="hljs-number">10</span>)<br>db.SetConnMaxIdleTime(<span class="hljs-number">1</span> * time.Second)<br>db.SetConnMaxLifetime(<span class="hljs-number">30</span> * time.Second)<br></code></pre></td></tr></table></figure><h3 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h3><p>对于某些长时间执行的查询，可以通过<code>context</code>取消查询操作。</p><p>实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx := context.Background()<br><br>ctx, _ = context.WithTimeout(ctx, <span class="hljs-number">300</span> * time.Millisecond)<br>_, err = db.QueryContext(ctx, <span class="hljs-string">&quot;SELECT * FROM user&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatalf(<span class="hljs-string">&quot;could finish execute&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.sohamkamani.com/golang/sql-database/#connection-pooling---timeouts-and--maxidle-connections">Using an SQL Database in Go (With Production Readiness)</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据类型</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/datatypes/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/datatypes/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>[toc]</p><hr><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><table><thead><tr><th>数据类型</th><th>解释</th></tr></thead><tbody><tr><td><code>bool</code></td><td>布尔值</td></tr><tr><td><code>string</code></td><td>字符串</td></tr><tr><td><code>int</code></td><td>整数</td></tr><tr><td><code>int8</code></td><td>8位整数</td></tr><tr><td><code>int16</code></td><td>16位整数</td></tr><tr><td><code>int32</code></td><td>32位整数</td></tr><tr><td><code>int64</code></td><td>64为整数</td></tr><tr><td><code>uint</code></td><td>无符号整数</td></tr><tr><td><code>uint8</code></td><td>8位无符号整数</td></tr><tr><td><code>uint16</code></td><td>16位无符号整数</td></tr><tr><td><code>uint32</code></td><td>32位无符号整数</td></tr><tr><td><code>uint64</code></td><td>64位无符号整数</td></tr><tr><td><code>uintptr</code></td><td></td></tr><tr><td><code>byte</code></td><td>等价于<code>uint8</code></td></tr><tr><td><code>rune</code></td><td>等价于<code>int32</code></td></tr><tr><td><code>float32</code>,<code>float64</code></td><td>32、64位浮点数</td></tr><tr><td><code>complex32</code>，<code>complex64</code></td><td>32、64位复数</td></tr></tbody></table><p>注意：<code>int</code>，<code>uint</code>和<code>uintptr</code>是根据平台决定采用的长度，32位操作系统为32位比特，64位操作系统为64比特。</p><hr><h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>当一个变量定义时没有赋值，则会被分配“零值”。</p><ul><li>数值类型为0</li><li>字符串为””</li><li>布尔类型为false</li></ul><hr><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在go中，类型转换必须显式指定。通过<code>T(v)</code>可以将变量<code>v</code>转换为<code>T</code>类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a, b <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><br><span class="hljs-comment">// 通过显式T(v)进行类型转换</span><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">float32</span> = <span class="hljs-keyword">float32</span>(a)<br><span class="hljs-comment">// 可以使用`:=`简化变量声明</span><br>d := <span class="hljs-keyword">float64</span>(b)<br><br><span class="hljs-keyword">var</span> e <span class="hljs-keyword">float32</span> = a <span class="hljs-comment">// 错误，必须显式的进行类型转换</span><br></code></pre></td></tr></table></figure><h2 id="的"><a href="#的" class="headerlink" title="的"></a>的</h2><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>在定义变量时，若没有指定变量类型（通过<code>:=</code>或<code>var a = </code>)时，则变量的类型是由右值推导出来的。</p><ol><li>当右值指定数据类型，则该变量的数据类型与右值保持一致。</li><li>若右值为非类型的数值常量，则根据常量的精度可能为<code>int</code>,<code>float64</code>或<code>complex128</code>。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">var</span> b = a <span class="hljs-comment">// b为int类型</span><br><br>c := <span class="hljs-number">3.13</span> <span class="hljs-comment">// c为float64类型</span><br></code></pre></td></tr></table></figure><hr><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量的声明类似于变量，使用关键字<code>const</code>。<br>常量可以为<strong>字符</strong>，<strong>字符串</strong>，<strong>布尔</strong>或<strong>数值</strong>。<br>**常量的声明不能使用<code>:=</code>**。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> i1 <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">const</span> i2 = <span class="hljs-number">2</span> <span class="hljs-comment">// 可以忽略声明数据类型</span><br><span class="hljs-keyword">const</span> i3 := <span class="hljs-number">3</span> <span class="hljs-comment">// 错误，不能使用`:=`</span><br><br><span class="hljs-comment">// 可以在const块中定义所有常量</span><br><span class="hljs-keyword">const</span> (<br>    i4 = <span class="hljs-number">4</span><br>    b1 = <span class="hljs-literal">false</span><br>    s1 = <span class="hljs-string">&quot;s1&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> b1 = <span class="hljs-literal">false</span> <span class="hljs-comment">// 可以在函数内声明</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h2><p>一个没有指定类型的数值常量可以根据上下文决定对应的数据类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">100</span><br>    b = <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">99</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob1</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob2</span><span class="hljs-params">(x <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span> &#123;<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">0.1</span><br>&#125;<br><br>myJob1(a) <span class="hljs-comment">// 抛出异常，int最多为64位数值，a*10超过int表示范围</span><br>myJob1(b) <span class="hljs-comment">// = 20</span><br>myJob2(a)<br>myJob2(b)<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>错误</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/errors/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/errors/</url>
    
    <content type="html"><![CDATA[<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在go中，使用<code>error</code>值表示一个错误状态。<code>error</code>为一个接口，定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> error <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>函数常常在返回错误类型用来表示函数是否正常执行，可以通过判断返回的<code>error</code>对象是否为<code>nil</code>来确定函数是否正常执行。</p></blockquote><p>自定义错误类型如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>    message     <span class="hljs-keyword">string</span><br>    currenttime time.Time<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(err MyError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;error occurs at %v, error message is %v&quot;</span>, err.currenttime, err.message)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMyError</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>    <span class="hljs-keyword">return</span> MyError &#123;<span class="hljs-string">&quot;test my error type&quot;</span>, time.Now()&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    err := getMyError()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>流程控制(flow control)</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/flowcontrol/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/flowcontrol/</url>
    
    <content type="html"><![CDATA[<h1 id="流程控制-flow-control"><a href="#流程控制-flow-control" class="headerlink" title="流程控制(flow control)"></a>流程控制(flow control)</h1><p>[toc]</p><hr><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul><li>go语言中循环语句只有<code>for</code>。</li><li>for语句中控制条件没有<code>()</code>，并且循环体必须使用<code>&#123;&#125;</code>括起来。</li><li>for语句的三个部分都可选的。</li></ul><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 注意：递增i只能使用i++，不能使用++i</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">var</span> j <span class="hljs-keyword">int</span><br><span class="hljs-comment">// 忽略三个部分</span><br><span class="hljs-keyword">for</span> ;; &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 类似于其他语言的`while`关键字</span><br><span class="hljs-keyword">for</span> j &lt; <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 无限循环</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><ul><li><code>if</code>语句用于对条件进行判断，判断条件不用<code>()</code>包括，执行块使用<code>&#123;&#125;</code>括起来。</li><li><code>if</code>语句的判断体可以添加一条短语句，后面接判断条件。</li><li>在<code>if</code>中短语句定义的变量同样在<code>else</code>语句块中有效。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">if</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">if</span> k := <span class="hljs-number">1</span>; k &gt; <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> k == <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    k++<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><code>switch</code>语句</h2><p><code>switch</code>语句可以用来替换<code>if-else</code>语句。<strong>当第一个条件成立时停止匹配</strong>。</p><ul><li>go语言中每个<code>case</code>最后不需要显式添加<code>break</code>，go语言会自动添加。</li><li>匹配条件不需要为常量，可以匹配量可以不是常数。</li><li><code>switch</code>可以不添加条件，则根据<code>case</code>是否成立进行判断。</li></ul><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 1. 每个case最后不需要添加break</span><br><span class="hljs-comment">* 2. 从上至下匹配，当第一个匹配成功即结束匹配</span><br><span class="hljs-comment">* 3. </span><br><span class="hljs-comment">*/</span><br>swith i := <span class="hljs-string">&quot;one&quot;</span>; i &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">case</span> f(): <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">default</span>: <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// 成为case的函数返回值与其他case的数据类型保持一致</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// func f() int&#123;&#125; // 错误，返回值必须为string</span><br><br><span class="hljs-comment">// 无条件的switch</span><br><br>i := <span class="hljs-number">1</span><br><span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> i == <span class="hljs-number">0</span>: <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> i == <span class="hljs-number">1</span>: <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">default</span>: <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a><code>defer</code>语句</h2><ul><li><code>defer</code>语句<strong>只能执行函数调用</strong>，不能执行赋值、运算等操作。</li><li><code>defer</code>语句推迟语句的执行知道函数返回。</li><li><code>defer</code>语句中的参数会按照在函数中的顺序进行判断并确定下来。</li><li>函数中最先出现的<code>defer</code>语句最后执行，最后出现的<code>defer</code>语句最先执行（函数返回之前）</li><li><code>defer</code>语句的函数调用是保存到栈中，所以调用顺序满足“先进后出”的顺序。</li></ul><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">0</span><br><span class="hljs-keyword">defer</span> fmt.Println(i) <span class="hljs-comment">// 此时i为0</span><br><br>i++<br><span class="hljs-keyword">defer</span> fmt.Println(i) <span class="hljs-comment">// 此时i为1</span><br><br>i++<br><span class="hljs-keyword">defer</span> fmt.Println(i) <span class="hljs-comment">// 此时i为2</span><br><br><span class="hljs-comment">// 输出结果为：</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>函数(function)</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/function/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/function/</url>
    
    <content type="html"><![CDATA[<h1 id="函数-function"><a href="#函数-function" class="headerlink" title="函数(function)"></a>函数(function)</h1><p>[toc]</p><hr><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 基本语法：func 函数名(参数列表) 返回值类型 &#123;&#125;</span><br><br><span class="hljs-comment">// 输入为int,输出为int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob1</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">// 无输入，输出为int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob2</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 输入为int,无输出</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob3</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;myJob3&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h2><p>当参数列表中的连续多个参数的数据类型相同，则可以只在最后一个相同类型参数后表示数据类型。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// x, y, z都是int类型参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob</span><span class="hljs-params">(x, y, z <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p>一个函数可以同时定义多个返回值。</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回两个值，数据类型分别为int和string</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-string">&quot;myJob&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 同时接收两个返回值</span><br>a, b := myJob(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// 可以只接收其中一个返回值，使用_表示不使用的值</span><br>_, b := myJob(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// 接收的参数数量与返回值的数量需要保持一致</span><br><span class="hljs-comment">// a := myJob(1, 2) // 错误</span><br></code></pre></td></tr></table></figure><hr><h2 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h2><p>可以对返回值进行命名，可以将其视作在函数开始声明的变量。<br>命名返回值后，返回<code>return</code>关键字后面可以不指定。此时默认返回命名的返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 注意：</span><br><span class="hljs-comment">* 1. 参数名和返回值名不能重复。</span><br><span class="hljs-comment">* 2. 命名的返回值具有默认值，不对其修改会返回默认值。int ==&gt; 0, string ==&gt; &quot;&quot;</span><br><span class="hljs-comment">* 3. 返回关键字`return`后可以不添加返回值，返回按照命名返回值返回结果</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob</span><span class="hljs-params">(x, y, z <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">// 返回a=0, b=&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h2><p>函数也是值，可以像其他类型变量一样在不同的函数间进行传递。可以作为另一个函数的参数进行传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 将函数作为值保存到变量中</span><br>f1 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 无返回值函数</span><br>f2 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 函数使用另一个函数作为参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mf1</span><span class="hljs-params">(ff <span class="hljs-keyword">func</span>(s <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span>, <span class="hljs-title">s1</span> <span class="hljs-title">string</span>, <span class="hljs-title">i1</span> <span class="hljs-title">int</span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    ff(s1, i1)<br>&#125;<br><br><span class="hljs-comment">// 返回值为函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mf2</span><span class="hljs-params">(ff <span class="hljs-keyword">func</span>(i <span class="hljs-keyword">int</span>)</span>, <span class="hljs-title">i1</span> <span class="hljs-title">int</span>) <span class="hljs-title">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    ff(i1)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h2><blockquote><p><strong>闭包</strong>：是一个引用其外部环境的变量的函数值。这个函数可以访问并操作其引用的外部变量。每个闭包都对应<strong>独立、隔离</strong>的引用变量。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通过调用outerfunction函数返回闭包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">outerfunction</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 闭包</span><br>        i++<br>        fmt.Println(<span class="hljs-string">&quot;i : &quot;</span>, i)<br>    &#125;<br>&#125;<br><br>c1 := outerfunction(<span class="hljs-number">0</span>)<br>c1() <span class="hljs-comment">// i : 1</span><br>c1() <span class="hljs-comment">// i : 2</span><br><br>c2 := outerfunction(<span class="hljs-number">0</span>)<br>c2() <span class="hljs-comment">// i : 1</span><br>c2() <span class="hljs-comment">// i : 2</span><br></code></pre></td></tr></table></figure><p>示例（使用闭包实现生成斐波那契数列）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    i1, i2 := <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">switch</span> &#123;<br>        <span class="hljs-keyword">case</span> i1 == <span class="hljs-number">-1</span>:<br>            i1 = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">return</span> i1<br>        <span class="hljs-keyword">case</span> i2 == <span class="hljs-number">-1</span>:<br>            i2 = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> i2<br>        <span class="hljs-keyword">default</span>:<br>            tmp := i1 + i2<br>            i1 = i2<br>            i2 = tmp<br>            <span class="hljs-keyword">return</span> i2<br>    &#125;<br>&#125;<br><br>fs = fibonacci()<br>fs() <span class="hljs-comment">// 0</span><br>fs() <span class="hljs-comment">// 1</span><br>fs() <span class="hljs-comment">// 1</span><br>fs() <span class="hljs-comment">// 2</span><br>fs() <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>协程(goroutine)</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/goroutines/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/goroutines/</url>
    
    <content type="html"><![CDATA[<h1 id="协程-goroutine"><a href="#协程-goroutine" class="headerlink" title="协程(goroutine)"></a>协程(goroutine)</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>协程</strong>：是由go管理的轻量级线程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> f(x, y, z)   <span class="hljs-comment">// 开始一个新的协程运行f(x,y,z)</span><br></code></pre></td></tr></table></figure><ul><li>协程之间运行在相同的地址空间，所以访问相同的共享内存需要同步。</li><li><code>sync</code>包提供协程之间的协作的工具。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> f1() <span class="hljs-comment">// 新起一个协程执行</span><br>    f1()    <span class="hljs-comment">// 当前协程执行</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="管道-channel"><a href="#管道-channel" class="headerlink" title="管道(channel)"></a>管道(channel)</h2><ul><li>管道是具有特定类型的通道，你可以通过符号<code>&lt;-</code>向管道发送数据或提取数据。</li><li>管道需要显式创建：<code>ch := make(chan int)</code>。</li><li>默认情况下，发送端和接收端只有当对方准备好才能进行数据的传输。所以不需要额外的同步或阻塞。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        ch &lt;- i<br>    &#125;<br>    ch &lt;- <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">go</span> myJob()<br><br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> ans != <span class="hljs-number">-1</span> &#123;<br>        fmt.Println(ans)<br>        ans = &lt;- ch<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缓存通道"><a href="#缓存通道" class="headerlink" title="缓存通道"></a>缓存通道</h3><p>通道可以有缓存，在创建通道时可以指定第二个参数为通道的缓存大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)    <span class="hljs-comment">// 缓存为10的int型通道</span><br></code></pre></td></tr></table></figure><ul><li>向有缓存的通道发送数据时，只有当缓存已满时才阻塞该协程。从通道取出数据时，当缓存为空时会阻塞该协程。</li></ul><h3 id="管道的状态"><a href="#管道的状态" class="headerlink" title="管道的状态"></a>管道的状态</h3><ul><li>接收者可以检测管道的状态：管道是否被关闭。通过在接收表达式中分配第二个参数表示管道的状态。</li><li>只有发送者可以关闭管道，接收者关闭管道导致<code>panic</code>。</li><li>可以对管道进行<code>for</code>循环遍历。该<code>for</code>循环会持续到管道被关闭为止。</li><li>管道不像文件一样完成数据传输之后需要关闭，只有在发送方需要向接收方表示没有数据时才可能通过关闭管道通知对方。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        ch &lt;- i<br>    &#125;<br>    <span class="hljs-built_in">close</span>(ch)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">receiveMessage</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 方式1：v为数据，ok为管道是否关闭（true为正常，false为关闭）</span><br>    v, ok := &lt;- ch<br>    <span class="hljs-keyword">if</span> ok &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-comment">// 方式2：for循环持续直到管道被关闭</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ch &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a><code>select</code>语句</h2><p><code>select</code>语句表示使得一个协程在多个管道通信操作上等待。只要其中一个<code>case</code>由阻塞状态变为非阻塞状态，则执行该<code>case</code>。若多个<code>case</code>都可以执行，则从准备好的一个中随机选择一个执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通过两个管道实现不同协程的协同</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br><span class="hljs-keyword">go</span> myJob(c1, c2)<br><span class="hljs-keyword">for</span> &#123;<br>i := &lt;- c1<br>fmt.Println(i)<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">10</span> &#123;<br><span class="hljs-built_in">close</span>(c2)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob</span><span class="hljs-params">(c1 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, c2 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> c1 &lt;- i:<br>i++<br><span class="hljs-keyword">case</span> &lt;- c2:<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="带有默认选项的select语句"><a href="#带有默认选项的select语句" class="headerlink" title="带有默认选项的select语句"></a>带有默认选项的<code>select</code>语句</h3><p><code>select</code>语句中的条件中可以设置默认选项。当其他条件都没有准备好时（阻塞状态）则执行默认状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> i := &lt;- ch:<br>            fmt.Println(i)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">default</span>:<br>            ch &lt;- <span class="hljs-string">&quot;one&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>若需要互斥的访问某个资源，可以使用互斥量(mutual exclusion)实现。<br>go中<code>sync.Mutex</code>提供用于互斥访问的互斥量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>    mu  sync.Mutex<br>    v   <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span> <span class="hljs-title">Modify</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>, value <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    c.mu.Lock()<br>    c.v[key] = value<br>    c.mu.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span></span> &#123;<br>    c.mu.Lock()<br>    <span class="hljs-keyword">defer</span> c.mu.Unlock()<br><br>    <span class="hljs-keyword">return</span> c.v[key]<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li>为什么下面代码无法正常跳出循环：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> i := &lt;- ch:<br>            fmt.Println(i)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">default</span>:<br>            ch &lt;- <span class="hljs-string">&quot;one&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP请求</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/http_request/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/http_request/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTTP消息分为两种：</p><ul><li>HTTP请求(HTTP Request)</li><li>HTTP响应(HTTP Response)</li></ul><p>消息格式：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">请求<span class="hljs-comment">(响应)</span>行<br><span class="hljs-number">0</span>个或多个Header<br><span class="hljs-comment">(空行)</span><br>消息体Body<span class="hljs-comment">(可选)</span><br></code></pre></td></tr></table></figure><hr><h2 id="http-Request请求"><a href="#http-Request请求" class="headerlink" title="http.Request请求"></a><code>http.Request</code>请求</h2><ul><li>go语言中使用<code>http.Request</code>表示客户端发送的HTTP请求消息。</li><li>其中重要的字段有：<ul><li>URL</li><li>Header</li><li>Body</li><li>Form, PostForm, MultipastForm</li></ul></li><li><code>Request</code>提供方法用来访问请求中的：Cookie, URL, User Agent。</li></ul><h3 id="http-Request中的URL字段"><a href="#http-Request中的URL字段" class="headerlink" title="http.Request中的URL字段"></a><code>http.Request</code>中的<code>URL</code>字段</h3><p><code>http.Request</code>中包含字段<code>URL</code>，用来表示请求对应的URL字段。该字段为<code>url.URL</code>的指针。</p><p><code>url.URL</code>为一个结构体，其中的字段表示一个完整的URL的不同部分。</p><p>URL的通用格式为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">scheme:<span class="hljs-regexp">//</span>[userinfo@]host/path[?query][<span class="hljs-comment">#fragment]</span><br></code></pre></td></tr></table></figure><ul><li><code>scheme</code>为对应的协议：http,https,ssh</li><li><code>[userinfo@]</code>：用户消息（可选）</li><li><code>host</code>：主机地址</li><li><code>path</code>：目标文件路径</li><li><code>query</code>：查询字符串（可选，以?开头）</li><li><code>fragment</code>：以#开头，默认被浏览器忽略</li></ul><h3 id="http-Requst中的Header字段"><a href="#http-Requst中的Header字段" class="headerlink" title="http.Requst中的Header字段"></a><code>http.Requst</code>中的<code>Header</code>字段</h3><p><code>http.Request</code>中的<code>Header</code>字段是一个<code>Header</code>结构体，该结构体的类型为<code>map[string][]string</code>。用来表示HTTP Header中的键值对。</p><p>获取<code>Header</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h myHander)</span> <span class="hljs-title">serveHTTP</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 获取Header</span><br>    header := r.Header<br>    <span class="hljs-comment">// 获取特定key</span><br>    encoding := header[<span class="hljs-string">&quot;Accept-Encoding&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="http-Request中的Body字段"><a href="#http-Request中的Body字段" class="headerlink" title="http.Request中的Body字段"></a><code>http.Request</code>中的<code>Body</code>字段</h3><ul><li>请求和响应的中的Body使用<code>io.ReadCloser</code>接口表示，而该接口是由两个接口<code>Reader</code>和<code>Closer</code>组成。</li><li>其中<code>Reader</code>接口中定义了<code>Read(p []byte) (n int, err error)</code>方法，返回值分别表示Body的长度和出错信息。</li><li><code>Closer</code>接口定义了<code>Close() error</code>方法，用于关闭HTTP连接。</li></ul><p>获取Body的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBody</span><span class="hljs-params">(w http.ResponseWriter, r *http.Rquest)</span></span> &#123;<br>    length := r.ContentLength<br>    body := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, lenght)<br>    r.Body.Read(body)   <span class="hljs-comment">// 将Body读取到body变量中</span><br>    s := <span class="hljs-keyword">string</span>(body)   <span class="hljs-comment">// 转换为字符串形式</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="URL-Query查询"><a href="#URL-Query查询" class="headerlink" title="URL Query查询"></a>URL Query查询</h3><p>类似于：<code>https://www.example.com/post?id=123&amp;name=lisi</code>的URL中，查询字段为”?”后的部分：<code>id=123&amp;name=lisi</code>。</p><ul><li><code>r.URL.RawQuery</code>：原始的字符串形式。</li><li><code>r.URL.Query()</code>：将查询字段转换为对应键值对形式(<code>map[string][]string</code>)。</li><li><code>query[&quot;id&quot;]</code>：获取特定key对应的值的map。</li><li><code>query.Get(&quot;id&quot;)</code>：获取特定key对应的第一个值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> r http.Request<br><br>url := r.URL    <span class="hljs-comment">// URL=http://www.example.com/post1?id=1&amp;name=aa&amp;id=2&amp;name=bb</span><br>raw_query := url.RawQuery   <span class="hljs-comment">// id=1&amp;name=aa&amp;id=2&amp;name=bb</span><br><br>query := url.Query()    <span class="hljs-comment">// map[id: [1 2], name:[aa bb]]</span><br><br>all_ids := query[<span class="hljs-string">&quot;id&quot;</span>]   <span class="hljs-comment">// [1, 2]</span><br>name1 := query.Get(<span class="hljs-string">&quot;name&quot;</span>)  <span class="hljs-comment">// aa</span><br></code></pre></td></tr></table></figure><h3 id="Form表单"><a href="#Form表单" class="headerlink" title="Form表单"></a><code>Form</code>表单</h3><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>页面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://localhost:8080/uploadfile&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;upload&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>方式一：<br>处理逻辑：</p></blockquote><ol><li>调用<code>ParseMultipartForm()</code>方法</li><li>从<code>File</code>字段获得<code>FileHeader</code>，调用<code>Open()</code>方法获得文件</li><li>使用<code>ioutil.ReadAll()</code>方法将文件内容读取到<code>byte</code>切片中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">http.HandleFunc(<span class="hljs-string">&quot;/uploadfile&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    r.ParseMultipartForm(<span class="hljs-number">1024</span>)<br><br>    fileHeader := r.MultipartForm.File[<span class="hljs-string">&quot;upload&quot;</span>][<span class="hljs-number">0</span>]<br>    file, err := fileHeader.Open()<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        data, err := ioutil.ReadAll(file)<br>        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>            s := <span class="hljs-keyword">string</span>(data)<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>方式二：<br>处理逻辑：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    file, _, err := r.FromFile(<span class="hljs-string">&quot;upload&quot;</span>)<br>    file, err := fileHeader.Open()<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        data, err := ioutil.ReadAll(file)<br>        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>            s := <span class="hljs-keyword">string</span>(data)<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>使用<code>FromFile()</code>无需调用<code>ParseMultipartForm()</code>方法。</li><li><code>FromFile()</code>方法会返回指定key对应的第一个value。</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP响应</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/http_response/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/http_response/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h1><p>[toc]</p><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>在<code>serveHTTP(w http.ResponseWriter, r *http.Request)</code>方法中,<code>ResponseWriter</code>表示一个HTTP响应对象。</li><li><code>ResponseWriter</code>是一个接口，<code>Handler</code>通过调用<code>serveHTTP()</code>方法使用<code>ResponseWriter</code>返回响应。</li><li><code>ResponseWriter</code>的实现为结构体<code>response</code>。</li><li><code>serveHTTP()</code>方法中只有<code>*http.Request</code>为指针，对该引用进行修改时会影响指向的对象。而<code>http.ResponseWriter</code>非指针，对其修改没有影响？<ul><li><code>ResponseWriter</code>为接口，<code>*response</code>指针实现了该接口，所以<code>ResponseWriter</code>表示指向<code>response</code>的指针。</li></ul></li></ul><hr><h2 id="将数据写入到响应中"><a href="#将数据写入到响应中" class="headerlink" title="将数据写入到响应中"></a>将数据写入到响应中</h2><ul><li>通过<code>ResponseWrite</code>的<code>Write()</code>方法将数据添加到响应中。数据被写入到HTTP响应的Body中。</li><li>若<code>Write()</code>方法调用前没有设置<code>Content-Type</code>，则Body中前512字节用于判断<code>Content-Type</code>。</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeExample</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>str := <span class="hljs-string">`&lt;html&gt;</span><br><span class="hljs-string">&lt;head&gt;&lt;title&gt;Golang&lt;/title&gt;&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;&lt;h1&gt;hello golang&lt;/h1&gt;&lt;/body&gt;</span><br><span class="hljs-string">&lt;/html&gt;`</span><br>w.Write([]<span class="hljs-keyword">byte</span>(str))<br>&#125;<br><br><span class="hljs-comment">// 返回的结果为：Content-Type: text/html; charset=utf-8</span><br></code></pre></td></tr></table></figure><hr><h2 id="操作响应的Header部分"><a href="#操作响应的Header部分" class="headerlink" title="操作响应的Header部分"></a>操作响应的Header部分</h2><ul><li>通过<code>WriteHeader</code>方法可以设置响应的状态码。</li><li>若没有显式调用<code>WriteHeader</code>方法，则在第一次调用<code>Write()</code>方法时隐式的调用<code>WriteHeader(http.StatusOK)</code>。</li><li>在调用<code>WriteHeader</code>后，仍然可以写入数据到<code>ResponseWriter</code>中，但无法再修改Header部分。</li><li>通过<code>ResponseWrite.Header()</code>获得HTTP响应对象，可以通过其中的<code>Add()</code>添加header，通过<code>Set()</code>方法修改header。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 先向Header中添加name:zhangsan</span><br><span class="hljs-comment">// 然后调用WriteHeader()方法</span><br><span class="hljs-comment">// 然后写入数据</span><br><span class="hljs-comment">// 最后再向Header中添加age:23</span><br><br><span class="hljs-comment">// 结果：（只有在WriteHeader方法前添加到Header的key-value生效，其后的key-value不生效）</span><br><span class="hljs-comment">//HTTP/1.1 501 Not Implemented</span><br><span class="hljs-comment">//Name: zhangsan</span><br><span class="hljs-comment">//Date: Sun, 24 Oct 2021 12:13:01 GMT</span><br><span class="hljs-comment">//Content-Length: 32</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeHeader</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Header().Add(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>)<br>w.WriteHeader(<span class="hljs-number">501</span>)<br>fmt.Fprint(w, <span class="hljs-string">&quot;no such service, try again later&quot;</span>)<br>w.Header().Add(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>设置重定向：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">w.Header().Set(<span class="hljs-string">&quot;Location&quot;</span>, <span class="hljs-string">&quot;http://cn.bing.com&quot;</span>)<br>w.WriteHeader(<span class="hljs-number">302</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="返回JSON数据"><a href="#返回JSON数据" class="headerlink" title="返回JSON数据"></a>返回JSON数据</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 自定义结构体</span><br><span class="hljs-keyword">type</span> Post <span class="hljs-keyword">struct</span> &#123;<br>User<span class="hljs-keyword">string</span><br>Threads[]<span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeJSON</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 确定content-type为applicaiton/json</span><br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>post := &amp;Post&#123;<br>User:<span class="hljs-string">&quot;zhang san&quot;</span>,<br>Threads:[]<span class="hljs-keyword">string</span> &#123;<span class="hljs-string">&quot;first&quot;</span>, <span class="hljs-string">&quot;second&quot;</span>, <span class="hljs-string">&quot;third&quot;</span>&#125;,<br>&#125;<br>    <span class="hljs-comment">// 将结构体转换为json编码</span><br>json, _ := json.Marshal(post)<br>    <span class="hljs-comment">// 将数据写入到reponse中</span><br>w.Write(json)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP服务端</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/http_server/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/http_server/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP服务端"><a href="#HTTP服务端" class="headerlink" title="HTTP服务端"></a>HTTP服务端</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>接口</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/interfaces/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/interfaces/</url>
    
    <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>接口是一系列方法签名的集合。</li><li>接口类型的变量可以持有任何实现该接口的值。</li><li>实现接口中的方法时，其接收者不能为指针类型，只能为值类型。否则无法编译。</li></ul><p>简单示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">interface</span> &#123;<br>    f1(s <span class="hljs-keyword">string</span>) <span class="hljs-keyword">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;<br>    a   <span class="hljs-keyword">string</span><br>    b   <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> &#123;<br>    c   <span class="hljs-keyword">string</span><br>    d   <span class="hljs-keyword">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a A)</span> <span class="hljs-title">f1</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    a.a = s<br>    <span class="hljs-keyword">return</span> a.b &gt; <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *B)</span> <span class="hljs-title">f1</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    b.c = s<br>    <span class="hljs-keyword">return</span> b.d<br>&#125;<br><br><span class="hljs-keyword">var</span> p1, p2 Person<br>p1 = A &#123;b: <span class="hljs-number">1</span>&#125;<br>p2 = B &#123;&#125;   <span class="hljs-comment">// 编译错误，结构体B只有在指针类型上实现了接口Person</span><br>p2 = &amp;B &#123;&#125;  <span class="hljs-comment">// OK</span><br><br></code></pre></td></tr></table></figure><hr><h2 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h2><ul><li>在Go中，接口是通过实现其中定义的方法来隐式实现的。即没有关键字<code>implements</code>表示接口和实现类之间的关系。</li><li>接口的隐式实现使得接口的定义和实现进行解耦</li></ul><hr><h2 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h2><p>接口值可以被看做一个二元组，由值和实际类型(concrete type)组成：(value, type)。</p><p>在接口值上调用方法会在其实际类型上执行同名方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">interface</span> &#123;<br>    f1()<br>&#125;<br><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 方法1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b B)</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">var</span> a A <span class="hljs-comment">// value = nil, type = nil</span><br>a = &amp;B &#123;&#125;<br>a.f1()  <span class="hljs-comment">// 调用方法1 </span><br></code></pre></td></tr></table></figure><hr><h2 id="空的接口值"><a href="#空的接口值" class="headerlink" title="空的接口值"></a>空的接口值</h2><p>如果实际的类型为空<code>nil</code>，则方法会在一个空的接收者(<code>nil receiver</code>)上调用。<br>一个空的接口值既不保存值也不保存实际类型。在空的接口值上调用其中的方法会抛出运行时错误，因为没有对应的实际类型用来表示最终被调用的方法。</p><blockquote><p>注意：一个持有空实际类型值的接口值本身是非空的(<code>non-nil</code>)</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">interface</span> &#123;<br>    f1()<br>&#125;<br><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b B)</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">var</span> a A     <span class="hljs-comment">// value: nil, type: nil，空接口值</span><br><span class="hljs-keyword">var</span> b *B    <span class="hljs-comment">// value: nil, type: *B</span><br>a = b       <span class="hljs-comment">// value: nil, type: *B</span><br>b = &amp;B&#123;&#125;    <span class="hljs-comment">// value: &amp;B&#123;&#125;, type: *B</span><br>a = b       <span class="hljs-comment">// value: &amp;B&#123;&#125;, type: *B</span><br></code></pre></td></tr></table></figure><hr><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p><strong>空接口</strong>：没有方法的接口类型被称为空接口，表示为<code>interface&#123;&#125;</code>。</p><ul><li>空接口可以持有任何类型的值，每种类型至少实现了零个方法。</li><li>空接口类型常用于处理未知类型的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;%v, %T&quot;</span>, i, i)  <span class="hljs-comment">// nil, nil</span><br><br>i = <span class="hljs-number">10</span><br>fmt.Printf(<span class="hljs-string">&quot;%v, %T&quot;</span>, i, i)  <span class="hljs-comment">// 10, int</span><br><br>i = <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%v, %T&quot;</span>, i, i)  <span class="hljs-comment">// hello, string</span><br><br><span class="hljs-comment">// 自定义的空接口</span><br><span class="hljs-keyword">type</span> MyInterface <span class="hljs-keyword">interface</span> &#123;&#125;<br><br><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-keyword">var</span> mi MyInterface  <span class="hljs-comment">// value: nil, type: nil</span><br>mi = A&#123;&#125;            <span class="hljs-comment">// value: &#123;&#125;, type: A</span><br></code></pre></td></tr></table></figure><hr><h2 id="类型断言-type-assertions"><a href="#类型断言-type-assertions" class="headerlink" title="类型断言(type assertions)"></a>类型断言(type assertions)</h2><p>类型断言可以用来判断一个接口值的实际类型，主要通过两种方式：</p><ol><li>假设接口值持有的实际类型为<code>T</code>。若是，则<code>t</code>保存着其值；否则抛出异常。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">t := i.(T)<br></code></pre></td></tr></table></figure></li><li>使用两个参数接收断言，第一参数为值，第二个参数表示断言是否正确。若类型正确，则<code>ok=true</code>；否则<code>ok=false</code>，<code>t</code>保存<code>T</code>类型的零值。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">t, ok := i.(T)<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;hello&quot;</span><br><br>s1 := i.(<span class="hljs-keyword">string</span>)    <span class="hljs-comment">// s1=&quot;hello&quot;</span><br><br>s2 := i.(<span class="hljs-keyword">int</span>)       <span class="hljs-comment">// 抛出异常</span><br>s3, ok1 := i.(<span class="hljs-keyword">string</span>)<span class="hljs-comment">// s3=&quot;hello&quot;, ok1=true</span><br>s4, ok2 := i.(<span class="hljs-keyword">int</span>)  <span class="hljs-comment">// s4=0, ok2=false</span><br><br></code></pre></td></tr></table></figure><hr><h2 id="类型的switch语句"><a href="#类型的switch语句" class="headerlink" title="类型的switch语句"></a>类型的switch语句</h2><p>类型的switch语句是通过switch语句实现一系列类型判断。其形式与一般的switch语句相似，只是case语句为特定类型，并对接口值的实际类型进行判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">1</span><br><span class="hljs-comment">// i := 1 // 会报错， cannot type switch on non-interface value i (type int)</span><br><br><span class="hljs-comment">// 通过`i.(type)`获取接口值的类型</span><br><span class="hljs-keyword">switch</span> v := i.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:<br>        fmt.Println(<span class="hljs-string">&quot;value: %v, type: int&quot;</span>, v)<br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:<br>        fmt.Println(<span class="hljs-string">&quot;value: %v, type: string&quot;</span>, v)<br>    <span class="hljs-keyword">default</span>:<br>        fmt.Println(<span class="hljs-string">&quot;value: %v, type: %T\n&quot;</span>, v, i)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Stringers"><a href="#Stringers" class="headerlink" title="Stringers"></a><code>Stringers</code></h2><p>一个非常常用的接口是<code>Stringer</code>，定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过对自定义类型实现该方法，可以在调用<code>fmt</code>包中的方法时返回指定的字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    name    <span class="hljs-keyword">string</span><br>    age     <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Person: name: %v, age: %v&quot;</span>, p.name, p.age)<br>&#125;<br><br>p := Person &#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">23</span>&#125;<br><br>fmt.Println(p)  <span class="hljs-comment">// Person: name: zhangsan, age: 23</span><br></code></pre></td></tr></table></figure><hr><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li>函数中的参数为接口类型，可以使用其实现类：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">interface</span> &#123;<br>    f1()<br>&#125;<br><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b B)</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(a A)</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>f2(&amp;B&#123;&#125;) <span class="hljs-comment">// 函数的参数为值，为什么可以传入指针</span><br>f2(B&#123;&#125;)<br><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang中的map</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/maps/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/maps/</url>
    
    <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h1><p>[toc]</p><hr><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>一个map用来保存键(key)-值(value)之间的映射关系。</li><li><code>map</code>的零值为<code>nil</code>，表示没有键或值可以添加到这个map中。</li><li>可以通过<code>make</code>函数创建并初始化给定类型的<code>map</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>)    <span class="hljs-comment">// key为int型，value为string</span><br><br><span class="hljs-keyword">var</span> map2 <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span><br>map2[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-literal">false</span> <span class="hljs-comment">// 错误，为nil的map无法添加元素</span><br>map2 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)<br>map2[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-literal">true</span>  <span class="hljs-comment">// &quot;one&quot; --&gt; true</span><br></code></pre></td></tr></table></figure><hr><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p>当<code>map</code>中key或value为结构体，则可以忽略对应的类型声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    name    <span class="hljs-keyword">string</span><br>    age     <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> map1 = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]Person &#123;<br>    <span class="hljs-number">1</span>: Person&#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-number">11</span>&#125;,<br>    <span class="hljs-number">2</span>: Person&#123;<span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-number">22</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 或者省略类型说明</span><br><span class="hljs-keyword">var</span> map2 = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]Person &#123;<br>    <span class="hljs-number">1</span>: &#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-number">11</span>&#125;,<br>    <span class="hljs-number">2</span>: &#123;<span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-number">22</span>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对map的修改"><a href="#对map的修改" class="headerlink" title="对map的修改"></a>对<code>map</code>的修改</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span><br><br><span class="hljs-comment">// 插入/更新操作</span><br>m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;zero&quot;</span><br>m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;one&quot;</span><br><br><span class="hljs-comment">// 提取对应的值</span><br>k := m[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment">// 删除操作</span><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-number">1</span>)    <span class="hljs-comment">// delete(map, key)</span><br><br><span class="hljs-comment">// 检测key是否存在</span><br><span class="hljs-comment">// v为1对应的值(不存在则为对应的零值)，ok为对应的key是否存在(存在为true，否则为false)</span><br>v, ok := m[<span class="hljs-number">1</span>]   <span class="hljs-comment">// v = 0, ok = false</span><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>方法</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/methods/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/methods/</url>
    
    <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>go中没有类，但可以在类型(type)中定义方法(method)。</li><li>一个方法是<strong>具有特定接收者的函数</strong>。</li><li>接收者在关键字<code>func</code>和函数名之间进行指定。</li></ul><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    name    <span class="hljs-keyword">string</span><br>    age     <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// 方法格式:</span><br><span class="hljs-comment">// func (接收者) 方法名(参数列表) 返回值类型 &#123;&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span> <span class="hljs-title">add</span><span class="hljs-params">(p1 Person)</span> <span class="hljs-title">Person</span></span> &#123;<br>    <span class="hljs-keyword">return</span> Person &#123;p.name + p1.name, p.age + p1.age&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接收者限制"><a href="#接收者限制" class="headerlink" title="接收者限制"></a>接收者限制</h3><p>方法的接收者并不限定必须是结构体，可以是同一包内定义的任意类型。但是<strong>不能是其他包中定义的类型</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mi1 myInt)</span> <span class="hljs-title">add</span><span class="hljs-params">(mi2 myInt)</span> <span class="hljs-title">myInt</span></span>&#123;<br>    <span class="hljs-keyword">return</span> mi1 + mi2<br>&#125;<br><br><span class="hljs-keyword">var</span> mi1 myInt = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> mi2 myInt = <span class="hljs-number">2</span><br>mi3 := mi1.add(mi2) <span class="hljs-comment">// mi3 = 3</span><br></code></pre></td></tr></table></figure><hr><h3 id="接收者为指针"><a href="#接收者为指针" class="headerlink" title="接收者为指针"></a>接收者为指针</h3><ul><li>方法的接收者可以设置为指针。</li><li>形式为<code>func (t *T) myJob()</code>，接收者的类型为指向<code>T</code>类型的指针。注意<code>T</code>类型本身不能为指针。</li><li>方法的接收者是指针时，在方法内可以改变指针所指向的变量；而当接收者是值时，则方法操作的是原始值的副本，不会对原始值产生影响。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    name    <span class="hljs-keyword">string</span><br>    age     <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<br>    p.name = <span class="hljs-string">&quot;name1&quot;</span><br>    p.age = <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> &#123;<br>    p.name = <span class="hljs-string">&quot;name2&quot;</span><br>    p.age = <span class="hljs-number">30</span><br>&#125;<br><br>p := Person &#123;<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-number">1</span>&#125;<br><br>p.f1() <span class="hljs-comment">// name = &quot;name&quot;, age = 1，p没有改变</span><br>p.f2() <span class="hljs-comment">// name = &quot;name2&quot;, age = 30，p被改变了</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>对于一个函数，若参数为指针，则必须传入指针参数，传入值参数无法编译。</li><li>对于一个指针接收者方法，可以对该类型的指针或值调用该方法。当对值调用指针方法时，编译器会自动添加取地址符”&amp;”，将其转换为指针调用。</li><li>类似的，若一个函数的参数为值，则传入指针则无法编译。对于一个值方法而言，可以对值或指针调用该方法。当对指针调用该方法时，会自动添加取值符”*”。</li></ul><p>方法示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">(p Person)</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>p1 := Person&#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">20</span>&#125;<br>p2 := &amp;p1<br><br>f1(p1)  <span class="hljs-comment">// OK</span><br>f2(p1)  <span class="hljs-comment">// 编译错误</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(p *Person)</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>f2(p1)  <span class="hljs-comment">// 编译错误</span><br>f2(p2)  <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>函数示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>p := Person &#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">20</span>&#125;<br>p1 := &amp;p<br><br>p.f1()  <span class="hljs-comment">// 等效于 (&amp;p).f1()</span><br>p1.f1() <span class="hljs-comment">// 指针方法调用</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>p.f2()  <span class="hljs-comment">// 值方法调用</span><br>p1.f2() <span class="hljs-comment">// 等效于(*p1).f2()</span><br></code></pre></td></tr></table></figure><h4 id="使用指针作为方法接收者的两个优势"><a href="#使用指针作为方法接收者的两个优势" class="headerlink" title="使用指针作为方法接收者的两个优势"></a>使用指针作为方法接收者的两个优势</h4><ul><li>在方法中可以对接收者进行修改。</li><li>避免每次调用方法时都对接收者进行拷贝副本，对于接收者为大结构体进行处理更高效。</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>包(package)</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/packages/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/packages/</url>
    
    <content type="html"><![CDATA[<h1 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Go中组织结构：不同的go程序属于不同的包(package)，多个包组成一个模块(module)。</p><p>在程序的第一行表明当前go程序所在的包:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br></code></pre></td></tr></table></figure><hr><h2 id="导入-import"><a href="#导入-import" class="headerlink" title="导入(import)"></a>导入(import)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 语法</span><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;module1&quot;</span><br>    <span class="hljs-string">&quot;module2&quot;</span><br>    ...<br>)<br></code></pre></td></tr></table></figure><hr><h2 id="暴露命名-exported-names"><a href="#暴露命名-exported-names" class="headerlink" title="暴露命名(exported names)"></a>暴露命名(exported names)</h2><p>在go语言中，只有以<strong>大写字母</strong>开头的命名才能从包以外进行引用。</p><p>当导入一个包时，只能引用该包中大写开头的暴露命名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 不能由外部引用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doIt</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 可以由外部引用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoIt</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>指针(pointer)</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/pointer/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/pointer/</url>
    
    <content type="html"><![CDATA[<h1 id="指针-pointer"><a href="#指针-pointer" class="headerlink" title="指针(pointer)"></a>指针(pointer)</h1><p>[toc]</p><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>go语言中有指针，用来<strong>保存一个值的内存地址</strong>。</p><ul><li><code>*T</code>表示指向<code>T</code>类型值的指针，默认值为<code>nil</code>。</li><li>操作符<code>&amp;</code>表示对于给定值生成一个指向其的指针。</li><li>操作符<code>*</code>表示指针所指向的值。</li></ul><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">i1 := <span class="hljs-number">1</span><br><br>p := &amp;i1 <span class="hljs-comment">// 生成一个指向i1的指针</span><br><br>v := *p <span class="hljs-comment">// 获取指针p指向的值</span><br><br>p1 := &amp;p <span class="hljs-comment">// 指向指针p的指针p1</span><br><br>v1 := *&amp;i1 <span class="hljs-comment">// 首先生成指向p的指针，然后取出指针指向的值为1</span><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在Golang中使用Protocol Buffers</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/protocolbuffers/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/protocolbuffers/</url>
    
    <content type="html"><![CDATA[<h1 id="在Golang中使用Protocol-Buffers"><a href="#在Golang中使用Protocol-Buffers" class="headerlink" title="在Golang中使用Protocol Buffers"></a>在Golang中使用Protocol Buffers</h1><p>[toc]</p><hr><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>安装编译器<a href="https://github.com/protocolbuffers/protobuf/releases"><code>protoc</code></a>和Go代码生成器<a href="https://github.com/protocolbuffers/protobuf-go/releases"><code>protoc-gen-go</code></a>，解压后在PATH中添加路径：<code>PATH=/path/to/protoc/bin:/path/to/protoc-gen-go</code>。</li><li>编写<code>.proto</code>文件：<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">package</span> pbpackage;  <span class="hljs-comment">// it defines proto file package</span><br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;github.com/mypbdemo&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-built_in">string</span> name = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int32</span> age = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Sex</span> </span>&#123;<br>        MALE = <span class="hljs-number">0</span>;<br>        FEMALE = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    Sex sex = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">repeated</span> <span class="hljs-built_in">string</span> habits = <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>编译<code>.proto</code>文件：通过<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">protoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/your.proto<br></code></pre></td></tr></table></figure>其中<code>$SRC_DIR</code>为<code>.proto</code>文件的路径，<code>DST_DIR</code>为生成代码的路径。</li><li>使用：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">p := &amp;mypbdemo.Person&#123;<br>    Name: <span class="hljs-string">&quot;your_name&quot;</span>,<br>    Age: <span class="hljs-number">20</span>,<br>    Sex: mypbdemo.Person.MALE,<br>    Email: <span class="hljs-string">&quot;your@mail.com&quot;</span>,<br>    Habits: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;habit1&quot;</span>, <span class="hljs-string">&quot;habit2&quot;</span>&#125;,<br>&#125;<br><br>out, err := proto.Marshal(p) <span class="hljs-comment">// encode instance to []byte</span><br><br><span class="hljs-keyword">var</span> p1 mypbdemo.Person<br>proto.Unmarshal(out, &amp;p1) <span class="hljs-comment">// decode from []byte to instance</span><br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developers.google.com/protocol-buffers/docs/gotutorial#compiling-your-protocol-buffers">Protocol Buffers Go tutorial</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>并发读取文件</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/read_file/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/read_file/</url>
    
    <content type="html"><![CDATA[<h1 id="并发读取文件"><a href="#并发读取文件" class="headerlink" title="并发读取文件"></a>并发读取文件</h1><p>[toc]</p><hr><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> chunk <span class="hljs-keyword">type</span>&#123;<br>    BufSize     <span class="hljs-keyword">int</span><br>    Offset      <span class="hljs-keyword">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFileConcurrency</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>, n <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    file, err := os.Open(path)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalln(<span class="hljs-string">&quot;open file failed:\n&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()<br>    fileInfo, err := file.Stat()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalln(<span class="hljs-string">&quot;file stat failed:\n&quot;</span>, err)<br>    &#125;<br>    fileSize := <span class="hljs-keyword">int</span>(fileInfo.Size())<br>    bufferSize := fileSize / n<br>    chunkSizes := <span class="hljs-built_in">make</span>([]chunk, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        chunkSizes[i].BufSize = bufferSize<br>        chunkSizes[i].Offset = <span class="hljs-keyword">int64</span>(bufferSize * i)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> rem := fileSize % n; rem != <span class="hljs-number">0</span> &#123;<br>        c := chunk&#123;rem, <span class="hljs-keyword">int64</span>(n * bufferSize)&#125;<br>        n++<br>        chunkSizes = <span class="hljs-built_in">append</span>(chunkSizes, c)<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(n)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(chunkSizes []chunk, i <span class="hljs-keyword">int</span>)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br><br>            chunk := chunkSizes[i]<br>            buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, chunk.BufSize)<br>            <span class="hljs-built_in">len</span>, err := file.ReadAt(buffer, chunk.Offset)<br><br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                log.Fatalln(<span class="hljs-string">&quot;read file to buffer failed:\n&quot;</span>, err)<br>            &#125;<br>            <span class="hljs-comment">// do something with buffer</span><br>        &#125;(chunkSizes, i)<br>    &#125;<br><br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://github.com/kgrz/reading-files-in-go/blob/master/reading-chunkwise-multiple.go">reading-chunkwise-multiple.go</a></li><li><a href="http://kgrz.io/reading-files-in-go-an-overview.html">reading files in go-an overview</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>结构体(`struct`)</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/structs/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/structs/</url>
    
    <content type="html"><![CDATA[<h1 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体(struct)"></a>结构体(<code>struct</code>)</h1><p>[toc]</p><hr><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>结构体相当于域的集合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    name    <span class="hljs-keyword">string</span><br>    age     <span class="hljs-keyword">int</span><br>    sex     <span class="hljs-keyword">bool</span><br>    salary  <span class="hljs-keyword">float32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结构体中的值可以通过点”.”的方式调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Person&#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2000.0</span>&#125;<br>name := p.name<br></code></pre></td></tr></table></figure><hr><h2 id="指向结构体的指针"><a href="#指向结构体的指针" class="headerlink" title="指向结构体的指针"></a>指向结构体的指针</h2><p>可以使用指针指向结构体，这样可以直接使用”.”引用结构体中的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">p := &amp;Person&#123;<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">3000.1</span>&#125;<br>p.age++<br>p.salary += <span class="hljs-number">100.2</span><br></code></pre></td></tr></table></figure><hr><h2 id="结构体常量-struct-literals"><a href="#结构体常量-struct-literals" class="headerlink" title="结构体常量(struct literals)"></a>结构体常量(struct literals)</h2><p>结构体常量指的是创建新的结构体时给结构体中每个域分配的值。</p><ul><li>可以只对结构体中部分域进行赋值，使用”:”对特定域进行赋值。</li><li>没有显式赋值的域被分配零值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">p1 := Person&#123;&#125; <span class="hljs-comment">// name=&quot;&quot;,age=0,sex=false,salary=0</span><br>p2 := Person&#123;age: <span class="hljs-number">20</span>, salary: <span class="hljs-number">10000.0</span>&#125; <span class="hljs-comment">// 指定的域为特定值，其他为零值</span><br>p3 := &amp;Person&#123;&#125; <span class="hljs-comment">// 指向域均为零值的结构体的指针</span><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>变量(variables)</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/variables/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/variables/</url>
    
    <content type="html"><![CDATA[<h1 id="变量-variables"><a href="#变量-variables" class="headerlink" title="变量(variables)"></a>变量(variables)</h1><p>[toc]</p><hr><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>变量的定义：</p><ul><li>可以同时定义多个相同类型的变量，数据类型放在最后</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s1, s2 <span class="hljs-keyword">string</span><br><span class="hljs-comment">// 同时定义两个bool类型变量，默认值为false</span><br><span class="hljs-keyword">var</span> b1, b2 <span class="hljs-keyword">bool</span><br></code></pre></td></tr></table></figure><p>定义位置：</p><ul><li>包的根位置</li><li>函数内</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">// 包根位置</span><br><span class="hljs-keyword">var</span> s1 <span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 函数内</span><br>    <span class="hljs-keyword">var</span> i1 <span class="hljs-keyword">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>变量的定义时可以进行初始化:</p><ul><li>多个变量声明时初始化必须都进行初始化。</li><li>变量声明时初始化可以忽略对应的数据类型。</li><li>变量声明时初始化可以为不同的数据类型。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明时初始化</span><br><span class="hljs-keyword">var</span> i1, i2, i3 <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br><span class="hljs-comment">// 声明时初始化可以忽略数据类型，并且多个不同类型的变量可以一起初始化</span><br><span class="hljs-keyword">var</span> i4, s1, b1 = <span class="hljs-number">4</span>, <span class="hljs-string">&quot;s1&quot;</span>, <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><hr><h2 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h2><p>在函数内，变量的声明并初始化可以通过<code>:=</code>进行替换。</p><blockquote><p>注意：函数外无法使用<code>:=</code>。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myJob</span><span class="hljs-params">()</span></span> &#123;<br>    i := <span class="hljs-number">1</span> <span class="hljs-comment">// 等价于 ==&gt; var i: int = 1</span><br>    b := <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>first_post</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/kotlin/classes/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/kotlin/classes/</url>
    
    <content type="html"><![CDATA[<h1 id="Kotlin中的类"><a href="#Kotlin中的类" class="headerlink" title="Kotlin中的类"></a>Kotlin中的类</h1><p>[toc]</p><hr><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li>默认的类构造与Java类似，主要由三个部分组成：类名(class name)，类头(class header)和类体(class body)。其中类头和类体可选。</li><li>若没有类体，类的定义类似于<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ul><li>一个类中有一个主构造器(primary constructor)和多个次构造器(secondary constructor)。</li><li>主构造器作为类头的一部分，由参数名+参数类型组成<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>(a1 <span class="hljs-built_in">Int</span>, a2: String)<br></code></pre></td></tr></table></figure></li><li>初始化代码放置在<code>init</code>代码块中，其中初始化的顺序是按照语句的顺序。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 初始化顺序：v1 --&gt; v2 --&gt; v3 --&gt; v4 --&gt; init(v3 --&gt; v4)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>(a1 <span class="hljs-built_in">Int</span>, a2: String) &#123;<br><span class="hljs-keyword">var</span> v1 = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> v2 = <span class="hljs-string">&quot;v2&quot;</span><br><span class="hljs-keyword">var</span> v3: <span class="hljs-built_in">Int</span><br><span class="hljs-keyword">var</span> v4: String<br><br><span class="hljs-keyword">init</span> &#123;<br>v3 = <span class="hljs-number">3</span><br>v4 = <span class="hljs-string">&quot;v4&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>若主构造器前有修饰符或注释，则需要显式添加关键词<code>constructor</code>:<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span></span>(a1: <span class="hljs-built_in">Int</span>, a2: String)<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="次构造器"><a href="#次构造器" class="headerlink" title="次构造器"></a>次构造器</h2><ul><li>一个类中可以有多个次构造器，使用关键词<code>constructor</code>表示。</li><li>次构造器通过显式或隐式方式调用主构造器。</li><li>主构造器和次构造器的参数列表不能相同。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 显式调用主构造器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass1</span></span>(a1: String) &#123;<br><span class="hljs-keyword">constructor</span>(a2: String, a2: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">this</span>(a2) &#123;<br><span class="hljs-comment">// do construct</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 隐式调用主构造器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass2</span> </span>&#123;<br><span class="hljs-keyword">constructor</span>(a1: <span class="hljs-built_in">Int</span>, a2: String) &#123;<br><span class="hljs-comment">// do construct</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>若主构造器的所有参数都有默认值，则会自动生成一个无参构造器：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>(a1: <span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span>, a2: String = <span class="hljs-string">&quot;&quot;</span>) &#123;<br><span class="hljs-keyword">var</span> v1 = a1<br><span class="hljs-keyword">var</span> v2 = a2<br>&#125;<br><br><span class="hljs-comment">// 直接调用无参构造器</span><br><span class="hljs-keyword">var</span> mc = MyClass()<br></code></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li>类定义<code>class MyClass</code>和<code>class MyClass()</code>不同，调用后者的构造器为<code>this()</code>，而前者为<code>this</code>。</li><li>即使没有主构造器，也会隐式调用主构造器。由此初始化块<code>init</code>在次构造器之前执行。</li><li>若不想暴露构造器，可以将其设置为<code>private</code>。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>() &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2><p>一个类中可以包含以下成员</p><ul><li>构造器和初始化块</li><li>函数</li><li>类的属性</li><li>内部类</li><li>对象声明</li></ul><hr><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>一个类可以通过关键字<code>abstract</code>声明为抽象类，其中的方法可以声明为<code>abstract</code>，不能有方法体。</p><ul><li>一个抽象类的子类必须实现父类的方法，否则也必须声明为抽象类。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass1</span> </span>&#123;<br><span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass2</span> : <span class="hljs-type">MyClass1</span></span>() &#123;<br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// do something</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>对于一个非抽象的<code>open</code>成员可以重载为抽象成员。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass1</span> </span>&#123;<br><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// do something</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass2</span> : <span class="hljs-type">MyClass1</span></span>() &#123;<br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="伴生对象-companion-objects"><a href="#伴生对象-companion-objects" class="headerlink" title="伴生对象(companion objects)"></a>伴生对象(companion objects)</h2><p>若想要访问一个类的内部类但不需要类示例，可以通过在类中声明一个伴生对象。可以通过类名作为限定词访问该对象。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://kotlinlang.org/docs/classes.html">Kotlin-Classes</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>first_post</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/kotlin/coroutine/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/kotlin/coroutine/</url>
    
    <content type="html"><![CDATA[<h1 id="Kotlin中的协程"><a href="#Kotlin中的协程" class="headerlink" title="Kotlin中的协程"></a>Kotlin中的协程</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>协程是一个<strong>可暂停</strong>执行的实例。</li><li>协程是一些可以与其他代码一同执行的代码块。</li><li>协程可以在一个线程被暂停，在另一个线程恢复执行。</li></ul><p>一个简单的示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    launch &#123;<br>        delay(<span class="hljs-number">1000L</span>)<br>        println(<span class="hljs-string">&quot;Kotlin!&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;Hello&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>runBlocking</code>为一个<strong>CoroutineScope</strong>，表示调用该协程会阻塞线程，直到协程执行完毕。</li><li><code>launch</code>：协程构造器，只有在特定的<strong>CoroutineScope</strong>内调用。其构造的协程与剩下的代码并行执行。</li><li><code>delay()</code>：特殊的暂停函数，会暂停当前协程特定的时间。不会阻塞当前的线程，其他协程可以继续在该线程上执行。</li></ul><blockquote><p>结构化并发<br>在结构化并发内，只有当<strong>CoroutineScopre</strong>内的协程都执行完毕后，该<strong>CoroutineScope</strong>才会退出。</p></blockquote><h2 id="将代码从launch块中提取出来"><a href="#将代码从launch块中提取出来" class="headerlink" title="将代码从launch块中提取出来"></a>将代码从<code>launch</code>块中提取出来</h2><p>协程代码在<code>launch</code>块中表示，可以将这些代码提取出来，以一个单独的函数进行表示，需要使用<code>suspend</code>修饰符。<br><code>suspend</code>函数表示该函数可以用于协程中，并且可以使用其他的<code>suspend</code>函数。</p><h3 id="构建协程范围"><a href="#构建协程范围" class="headerlink" title="构建协程范围"></a>构建协程范围</h3><p>可以自定义协程范围，该协程会当其中所有的协程完成后才完成。</p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>协程将代码分发到不同的线程执行。传统的线程模型是特定代码在特定线程执行，而协程可以非常简单的在不同的线程之间切换代码执行。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://kotlinlang.org/docs/coroutines-overview.html">Kotlin-docs:Coroutines</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>first_post</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/kotlin/inheritance/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/kotlin/inheritance/</url>
    
    <content type="html"><![CDATA[<h1 id="Kotlin中的继承"><a href="#Kotlin中的继承" class="headerlink" title="Kotlin中的继承"></a>Kotlin中的继承</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><code>Any</code>是所有类的父类，其中包含三个方法<code>hashCode()</code>，<code>equals()</code>和<code>toString()</code>。</li><li>一个类默认情况下是无法继承的，需要通过关键字<code>open</code>设置该类可以被继承。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 无法被继承</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass1</span></span><br><br><span class="hljs-comment">// 可以被继承</span><br><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass2</span></span><br><br><span class="hljs-comment">// 子类继承</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass3</span> : <span class="hljs-type">MyClass2</span></span>()<br></code></pre></td></tr></table></figure></li><li>若子类有主构造器，则其父类必须在主构造器中进行初始化。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> </span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://kotlinlang.org/docs/inheritance.html">Kotlin-Inheritance</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SELinux小结</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/linux/SELinux/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/linux/SELinux/</url>
    
    <content type="html"><![CDATA[<h1 id="SELinux小结"><a href="#SELinux小结" class="headerlink" title="SELinux小结"></a>SELinux小结</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>当应用或进程发出访问对象（文件）的请求时，SELinux会检查访问向量缓存(AVC, 包含主体和对象的访问权限)。</p><p>若被拒绝，在<code>/var/log.messages</code>中会显示消息**”avc: denied”**。</p><h3 id="配置SELinux"><a href="#配置SELinux" class="headerlink" title="配置SELinux"></a>配置SELinux</h3><p>常见的有<em>目标策略</em>和<em>多级安全防护</em>(MLS)，主要使用的是目标策略。</p><p>可以通过<code>/etc/sysconfig/selinux</code>文件判断系统采用的配置方式。</p><h3 id="标签和类型强制访问控制"><a href="#标签和类型强制访问控制" class="headerlink" title="标签和类型强制访问控制"></a>标签和类型强制访问控制</h3><p>系统中的所有文件、进程和端口都有对应的SELinux标签。</p><p>标签的格式为<em>user:role:type:level</em>，其中<em>type</em>对于目标策略最为重要。</p><p>类型强制访问控制定义特定类型的进程能否访问标记为特定类型的文件。</p><h3 id="启用SELinux"><a href="#启用SELinux" class="headerlink" title="启用SELinux"></a>启用SELinux</h3><p>通过编辑<code>/etc/selinux/config</code>并设置<code>SELINUX=permissive</code>来启用SELinux。</p><hr><h2 id="自主访问控制-DAC-和强制访问控制-MAC"><a href="#自主访问控制-DAC-和强制访问控制-MAC" class="headerlink" title="自主访问控制(DAC)和强制访问控制(MAC)"></a>自主访问控制(DAC)和强制访问控制(MAC)</h2><p>DAC: 文件和进程都有对应的所有者，用户、群组和其他人可以拥有某个文件，用户可以更改自己文件的权限。root用户具有完全访问控制权，可以访问所有用户的文件。<br>MAC: 由操作系统内核检查主体对对象的任何操作是否符合授权规则，从而决定操作是否允许。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.redhat.com/zh/topics/linux/what-is-selinux">SELinux是什么？</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git内部原理</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/linux/git_internals/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/linux/git_internals/</url>
    
    <content type="html"><![CDATA[<h1 id="Git内部原理"><a href="#Git内部原理" class="headerlink" title="Git内部原理"></a>Git内部原理</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Git是一个<strong>内容寻址</strong>（content-addressable）的文件系统，并在其上提供版本控制的用户界面。</li><li>Git的本质是一个键值对数据库。向Git中插入任何数据，返回一个唯一的键。通过这个键可以取出对应的数据。</li></ul><p><code>git init</code>会在当前目录下生成一个**.git**目录，用于保存所有与Git相关的文件，其中包含：</p><table><thead><tr><th>文件</th><th>解释</th></tr></thead><tbody><tr><td>description</td><td>供GitWeb使用</td></tr><tr><td>config</td><td>项目特有的配置项</td></tr><tr><td>info</td><td>包含一个全局排除文件，存放不希望放在**.gitignore**文件中的忽略模式</td></tr><tr><td>hooks</td><td>服务端或客户端的钩子文本</td></tr><tr><td>HEAD</td><td>目前被检出的分支</td></tr><tr><td>index</td><td>保存暂存区信息</td></tr><tr><td>refs</td><td>存储指向（分支、远程仓库和标签）的提交对象的指针</td></tr><tr><td>objects</td><td>存储所有数据的内容</td></tr></tbody></table><hr><h2 id="Git对象"><a href="#Git对象" class="headerlink" title="Git对象"></a>Git对象</h2><p>Git中的有三种重要的对象，为Git中的重要数据结构，分别为：</p><ul><li>数据对象(blob object)</li><li>树对象(tree object)</li><li>提交对象(commit object)</li></ul><h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p><em>Git可以被认为是一个键值对数据库</em>，可以向其添加一个数据作为值(value)，Git返回对应的键(key)。</p><p>输入一个字符串作为数据添加到Git的数据库中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;test content&#x27; | git hash-object -w --stdin<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><code>git hash-object</code>返回输入的数据对应的唯一值。</li><li>选项<code>-w</code>表示将数据插入到Git的数据库中。</li><li><code>--stdin</code>表示数据来自标准输入。若为文件可以不写该选项而在末尾添加文件名：<code>git hash-object -w test.txt</code>。</li><li>该命令返回值为40个字符的SHA1哈希值。该哈希值是由“头部信息 + 数据内容”一起做SHA1校验运算获得的校验和。</li></ul><p>上面的命令导致在<code>.git/objects/</code>目录下生成一个对应的文件，文件的命名规则是：</p><ul><li>取SHA1哈希值的前两个字符作为子目录。</li><li>后面的38个字符为该子目录中的文件名。</li></ul><p>可以通过以下命令查看所有的数据内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find .git/objects -type f<br></code></pre></td></tr></table></figure><p>通过指定特定的SHA1哈希值获得对应的数据内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git cat-file -p &lt;SHA1_value&gt;<br><br>// 例如<br>git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4<br></code></pre></td></tr></table></figure><p>也可以用于还原数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4 &gt; test.txt<br></code></pre></td></tr></table></figure><p>若查看内部存储的对象类型，可以用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git cat-file -t d670460b4b4aece5915caf5c68d12f560a9fe3e4<br></code></pre></td></tr></table></figure><p>返回结果：<br>|结果|类型|<br>|—|—|<br>|blob|数据对象|<br>|tree|树对象|</p><h3 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h3><p>数据对象只能保存数据，无法保存文件名。而树对象可以解决这一问题，并且可以存储一系列文件。</p><p>一个树对象：</p><ul><li>由若干个数据对象和树对象组成。</li><li>是由暂存区中的状态创建并生成对应的树对象。</li></ul><p>通过下面命令检查master分支的树对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git cat-file -p master^&#123;tree&#125;<br></code></pre></td></tr></table></figure><p>为特定文件生成一个暂存区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git update-index --add --cacheinfo 10064 &lt;file_sha1_value&gt; &lt;file_name&gt;<br><br>// 例如：<br>git update-index --add --cacheinfo 10064 d670460b4b4aece5915caf5c68d12f560a9fe3e4 test.txt<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><code>--add</code>：将文件加入到暂存区中。</li><li><code>--cacheinfo</code>:将文件添加到Git的数据库中，而非当前目录。</li><li>10064:表示当前为一个普通文件；100755：可执行文件；120000：符号链接。</li></ul><p>将暂存区的内容写到一个树对象中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git write-tree<br></code></pre></td></tr></table></figure><p>子树对象是同将已有的树对象读到暂存区并创建新的树对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 将已有树对象读入咱存取<br>git read-tree --prefix=&lt;path_name&gt; &lt;sub-tree SHA1 value&gt;<br>// 例如<br>git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579<br><br><br>git write-tree<br></code></pre></td></tr></table></figure><h3 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h3><p>提交对象(commit object)：用于保存这些快照的信息：所有者、时间、提交信息等。</p><p>为一个树对象创建一个提交对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &lt;commit message&gt; | git commit-tree &lt;tree object SHA1 value&gt;<br>// 例如<br>echo &quot;first commit&quot; | git commit-tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579<br></code></pre></td></tr></table></figure><p>提交对象的数据结构：</p><ul><li>一个顶层树对象，表示当前的快照。</li><li>父提交对象（若存在）</li><li>作者/提交者信息。</li><li>提交注释。</li></ul><p>可以检查特定提交对象保存的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --stat fdf4fc3344e67ab068f836878b6c4951e3b15f3d<br></code></pre></td></tr></table></figure><p>会显示：</p><ul><li>每个提交的SHA1哈希值。</li><li>作者/邮箱信息。</li><li>提交日期、时间。</li><li>提交注解。</li><li>简略的改动信息。</li></ul><blockquote><p>在我们使用<code>git add</code>和<code>git commit</code>时，Git所要做的实质工作是将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明顶层树对象和父提交的提交对象。这些对象均保存在<code>.git/objects</code>目录下。</p></blockquote><blockquote><p>一个数据对象如何床创建的？</p><ol><li>Git会以识别出的对象类型作为开头构造一个<strong>头部信息</strong>，一个数据对象的头部信息格式如下：<br><code>&quot;blob &lt;character length&gt;\0000&lt;message&gt;&quot;</code>，如要保存信息”test”，则对应的头部信息为<code>&quot;blob 4\0000test&quot;</code>。</li><li>使用SHA1将头部信息压缩成长度为40个字节的16进制字符串。</li><li>在<code>.git/objects</code>目录下创建一个以SHA1哈希值前两个字符作为子目录，后面38个字符作为文件名创建对应的文件。</li><li>文件的内容是将<strong>头部信息</strong>使用zlib进行压缩的结果。<br>其他的对象（树对象、提交对象）有各自的头部信息数据格式，但创建流程基本相同。</li></ol></blockquote><hr><h2 id="Git引用"><a href="#Git引用" class="headerlink" title="Git引用"></a>Git引用</h2><blockquote><p>Git中的引用本质上是<strong>对提交对象的SHA1哈希值创造一个别名</strong>，为了简化引用特定的提交对象。<br>Git的分支的本质是<strong>一个指向某个提交的指针或引用</strong>。</p></blockquote><p>Git引用保存在<code>.git/refs</code>目录下，其中</p><ul><li>heads为本地引用目录。</li><li>tags为标签目录。</li></ul><p>创建Git引用的方式：</p><ol><li>直接将指定的提交对象的SHA1哈希值写入到<code>.git/refs/heads/&lt;refs name&gt;</code>文件。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo fdf4fc3344e67ab068f836878b6c4951e3b15f3d &gt; .git/refs/heads/master<br></code></pre></td></tr></table></figure></li><li>使用Git提供的命令。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">// master引用指向最新提交<br>git update-ref refs/heads/master<br><br>// 指定特定引用指向特定的提交对象<br>git update-ref refs/heads/test fdf4fc3344e67ab068f836878b6c4951e3b15f3d<br></code></pre></td></tr></table></figure></li></ol><p>注意：</p><ul><li>可以通过以下命令检查特定引用的提交记录：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --pretty=oneline master // 检查master分支的提交记录<br></code></pre></td></tr></table></figure></li><li><code>git branch &lt;branch&gt;</code>实质上就是使用<code>git update-ref</code>命令更新当前引用所指向的提交，可可以用于创建一个新的分支。</li></ul><h3 id="HEAD引用"><a href="#HEAD引用" class="headerlink" title="HEAD引用"></a>HEAD引用</h3><blockquote><p>HEAD文件在<code>.git</code>目录下，是一个符号引用(symbolic referencec，指向其他引用的指针)，指向目前所在的分支。<br>Git通过HEAD引用获取当前的最新提交的SHA1哈希值。</p></blockquote><p>正常情况下，HEAD文件的内容类似于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ref: refs/heads/master<br></code></pre></td></tr></table></figure><p>表示目前的最新的引用指向master引用，所有随着master引用的更新而HEAD引用也随之更新。</p><p>可以使用如下命令将HEAD引用指向不同的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout test<br><br>// HEAD文件内容更新为 ref: refs/heads/test<br></code></pre></td></tr></table></figure><p>在使用<code>git commit</code>命令时，会创建一个提交对象，并用HEAD文件所指向的SHA1哈希值作为父提交字段。</p><p>推荐使用以下命令对应用进行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 查看HEAD引用的指向<br>git symbolic-ref HEAD<br><br>// 将HEAD指向特定的引用<br>git symbolic-ref HEAD refs/heads/test<br></code></pre></td></tr></table></figure><h3 id="标签引用"><a href="#标签引用" class="headerlink" title="标签引用"></a>标签引用</h3><p>标签对象(tag object)：包含标签创建者信息、日期、注释信息以及一个指针。通常指向一个提交对象，像一个不会移动的分支引用。</p><p>创建标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 创建一个轻量标签<br>git update-ref refs/tags/&lt;tag_name&gt; &lt;SHA1 value&gt;<br><br>// 创建一个附注标签<br>git tag -a &lt;tag_name&gt; &lt;SHA1 value&gt; -m &lt;&quot;tag info&quot;&gt;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>标签文件中保存着标签对象的SHA1哈希值。</li><li>检查对应SHA1哈希值文件可以了解标签对象的数据格式。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 获得标签对应的SHA1哈希值<br>cat .git/refs/tags/v1.1<br><br>// 获得对应的标签信息<br>git cat-file -p &lt;SHA1 value&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h3><p>远程引用(remote reference)：用于记录远程仓库对应的引用。</p><p>保存在<code>.git/refs/remotes/&lt;remote repo&gt;/&lt;remote refs&gt;</code>，如对于远程仓库<strong>origin</strong>的<strong>master</strong>分支，远程引用保存在<code>.git/refs/remotes/origin/master</code>。其中保存着本地的<strong>master</strong>分支所对应的SHA1哈希值。</p><p>远程引用与本地分支的区别：<strong>远程引用是只读的</strong>。远程分支被作为记录远程服务器上各分支最后已知位置状态的书签使用。</p><hr><h2 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h2><p>默认情况下，Git是对完整的原文件生成对应的快照。所以对于大文件的改动进行多次提交会生成多个类似的快照。</p><p>这种松散的数据保存格式可能导致占用额外的存储空间，可以通过保存一个原始文件再加上与之前版本的差异部分来减少新旧版本的重复部分。</p><p>Git通过<strong>包文件</strong>(packfile)的二进制文件将多个对象打包成一个文件，节省空间和提高效率。</p><p>可以通过以下命令手动创建包文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git gc<br></code></pre></td></tr></table></figure><p>结果是<code>objects</code>目录下出现一对新文件：索引文件<code>*.idx</code>和包文件<code>*.pack</code>。<br>包文件：包含了被移除的所有对象的内容。<br>索引文件：包含了包文件的偏移信息。可以由此快速定位任意一个指定对象。</p><blockquote><p><strong>实现原理</strong>：查找命名及大小相近的文件，只保存文件不同版本之间的差异内容。<br>通过以下命令查看打包的内容：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git verify-pack -v .git/objects/pack/pack-XXXX.idx<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>一般是保存最新版的完整信息，而之前的版本是通过差异内容保存。因为大部分情况下需要快速访问文件的最新版本。</li></ul><hr><h2 id="引用规范"><a href="#引用规范" class="headerlink" title="引用规范"></a>引用规范</h2><p>在<code>.git/config</code>文件中保存着<code>fetch</code>和<code>push</code>操作的**引用规范(refspec)**：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[remote &quot;origin&quot;]<br>        url = git@github.com:XXXX/XXXX.git<br>        fetch = +refs/heads/*:refs/remotes/origin/*<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>fetch</code>后的格式为”+ <src>:<dst>“，+表示在不能快进的情况下也要强制更新引用。<code>&lt;src&gt;</code>为远程仓库的引用，<code>&lt;dst&gt;</code>为本地仓库的远程引用的位置。</li><li>可以同时拉取多个分支：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 将远程仓库origin的master分支拉到本地分支master，topic分支拉到本地的topic分支<br>git fetch origin master:refs/remotes/origin/master topic:refs/remotes/origin/topic<br></code></pre></td></tr></table></figure></li></ul><p>可以通过命名空间实现在一个项目中将不同团队隔离开来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[remote &quot;origin&quot;]<br>url=git@github.com:XXXX/XXXX.git<br>fetch= +refs/heads/master:refs/remotes/origin/master<br>fetch= +refs/heads/qa/*:refs/remotes/origin/qa/*<br>push= refs/heads/qa/master:refs/heads/qa/master<br></code></pre></td></tr></table></figure><p>若要删除一个远程引用，可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin :topic<br><br>// 或者<br>git push origin --delete topic<br></code></pre></td></tr></table></figure><hr><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><hr><h2 id="维护与数据恢复"><a href="#维护与数据恢复" class="headerlink" title="维护与数据恢复"></a>维护与数据恢复</h2><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>当存在太多的松散对象或包文件时，Git会通过<code>git gc</code>命令进行垃圾回收。其主要的动作是：收集所有松散对象并将其放置在包文件中，将多个包文件合并为一个大的包文件，移除与任何提交都无关的陈旧对象。</p><p>手动执行自动垃圾回收：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git gc --auto<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>只有当约7000个松散对象或50个包文件时才能触发真正的gc命令。</li><li><code>git gc</code>命令会导致<code>refs</code>目录下的引用文件被移除，保存在<code>packed-refs</code>目录下。</li></ul><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>若丢失一次提交，如何恢复丢失的提交呢？<br>可以通过以下命令查看引用日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reflog<br></code></pre></td></tr></table></figure><p>每次更改HEAD时，引用日志会记录每次提交或更改分支。</p><p>通过以下命令以标准日志格式输出引用日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log -g<br></code></pre></td></tr></table></figure><p>找到丢失的提交，可以通过创建一个新的分支指向该提交来恢复：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch &lt;new_branch&gt; &lt;SHA1_value&gt;<br></code></pre></td></tr></table></figure><p>若引用日志丢失，可以使用<code>git fsck</code>工具检查数据库的完整性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git fsck --full<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>dangling commit</code>为丢失的提交。</li></ul><h3 id="移除对象"><a href="#移除对象" class="headerlink" title="移除对象"></a>移除对象</h3><p>若将大文件提交到Git中，即使该文件从项目中移除，也会导致每次克隆时都强制下载该大文件。</p><p>解决方案：从大文件引用最早的树对象开始重写每一次提交。</p><p>注意：</p><ul><li>通过<code>git rm &lt;file_name&gt;</code>只会移除文件，无法删除历史记录。</li></ul><p>基本流程：</p><ul><li>找到可能的大文件。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git gc<br><br>// 按照大小排序查找最大的三个对象<br>git verify-pack -v .git/objects/pack/pack-XXXX.XXXX.git | sort -k 3 -n | tail -3<br><br>// 由对应的SHA1哈希值找到对应的对象<br>git rev-list --objects --all | grep &lt;SHA1_value&gt;<br></code></pre></td></tr></table></figure></li><li>查找所有与该文件改动有关的提交。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log --oneline --branches -- &lt;file_name&gt;<br></code></pre></td></tr></table></figure></li><li>重写指定提交后的所有提交<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git filter-branch --index-filter &#x27;git rm --ignore-unmatch --cached &lt;file_name&gt;&#x27; -- &lt;SHA1_value^&gt;<br></code></pre></td></tr></table></figure></li><li>此时历史中不存在对大文件的引用，但引用日志可能存在该文件的引用，可以重新打包数据库：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -Rf .gitl/refs/original<br>rm -Rf .git/logs/<br>git gc<br></code></pre></td></tr></table></figure></li><li>若要删除松散对象中的大文件，可以：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git prune --expire now<br></code></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li><code>--index-filter</code>：只修改在暂存区或索引中的文件。</li><li><code>git rm --cached</code>：在索引中移除文件。</li><li><code>--ignore-unmatch</code>：若删除的模式不存在，不提示错误。</li><li><code>filter-branch</code>：重写指定提交以来的历史。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://git-scm.com/book/zh/v2">Pro Git</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ranger常用命令手册</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/linux/rangerdocs/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/linux/rangerdocs/</url>
    
    <content type="html"><![CDATA[<h1 id="Ranger常用命令手册"><a href="#Ranger常用命令手册" class="headerlink" title="Ranger常用命令手册"></a>Ranger常用命令手册</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>最上面是当前所在的路径。</li><li>最下面是当前选中文件或文件夹的相关信息。</li><li><code>:</code>用来打开命令行，可以手动运行命令。</li></ul><hr><h2 id="基本导航功能"><a href="#基本导航功能" class="headerlink" title="基本导航功能"></a>基本导航功能</h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>i</td><td>向下移动</td></tr><tr><td>k</td><td>向上移动</td></tr><tr><td>h</td><td>返回父目录</td></tr><tr><td>l</td><td>进入选中目录</td></tr><tr><td>i</td><td>查看指定文件或退出查看</td></tr><tr><td>q</td><td>退出ranger</td></tr></tbody></table><hr><h2 id="按键绑定"><a href="#按键绑定" class="headerlink" title="按键绑定"></a>按键绑定</h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>y</td><td>复制</td></tr><tr><td>d</td><td>剪切/删除</td></tr><tr><td>p</td><td>粘贴</td></tr><tr><td>o</td><td>排序</td></tr><tr><td>z</td><td>设置</td></tr><tr><td>u</td><td>撤销操作</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vim常用操作</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/linux/vimdocs/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/linux/vimdocs/</url>
    
    <content type="html"><![CDATA[<h1 id="Vim常用操作"><a href="#Vim常用操作" class="headerlink" title="Vim常用操作"></a>Vim常用操作</h1><p>[toc]</p><hr><h2 id="Vim中常用的命令"><a href="#Vim中常用的命令" class="headerlink" title="Vim中常用的命令"></a>Vim中常用的命令</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><table><thead><tr><th>移动方向</th><th>快捷键</th></tr></thead><tbody><tr><td>j</td><td>向下移动一行</td></tr><tr><td>k</td><td>向上移动一行</td></tr><tr><td>h</td><td>向左移动一行</td></tr><tr><td>l</td><td>向右移动一行</td></tr><tr><td>0</td><td>移动到当前行首</td></tr><tr><td>$</td><td>移动到当前行尾</td></tr><tr><td>]]</td><td>段首</td></tr><tr><td>[[</td><td>段尾</td></tr><tr><td>G</td><td>最后一行</td></tr><tr><td>gg</td><td>第一行</td></tr><tr><td>nG</td><td>跳转到特定行</td></tr></tbody></table><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><table><thead><tr><th>搜索方式</th><th>快捷键</th></tr></thead><tbody><tr><td>/word</td><td>光标后搜索包含word的位置</td></tr><tr><td>?word</td><td>光标前搜索包含word的位置</td></tr><tr><td>n</td><td>搜索下一个结果</td></tr><tr><td>N</td><td>搜索前一个结果</td></tr></tbody></table><h3 id="复制、粘贴、删除"><a href="#复制、粘贴、删除" class="headerlink" title="复制、粘贴、删除"></a>复制、粘贴、删除</h3><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>x,X</td><td>向后、向前删除一个字符</td></tr><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>ndd</td><td>从光标处向下删除n行</td></tr><tr><td>d$</td><td>删除光标到所在行行尾</td></tr><tr><td>d0</td><td>删除光标到所在行行首</td></tr><tr><td>yy</td><td>复制所在行</td></tr><tr><td>nyy</td><td>向下复制n行</td></tr><tr><td>p,P</td><td>向后、向前粘贴</td></tr><tr><td>J</td><td>将所在行与下一行合并为一行</td></tr><tr><td>u</td><td>撤销前一个动作</td></tr><tr><td>ctrl + r</td><td>反撤销</td></tr><tr><td>.</td><td>重复上一个动作</td></tr></tbody></table><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>wq!</td><td>强制保存后退出</td></tr><tr><td>q!</td><td>强制退出不保存</td></tr></tbody></table><h3 id="可视化界面"><a href="#可视化界面" class="headerlink" title="可视化界面"></a>可视化界面</h3><p><strong>多行缩进</strong></p><ul><li>按键<code>v</code>进入可视化界面。</li><li>通过j向下移动光标选中多行。</li><li>按键<code>&lt;</code>向前缩进，按键<code>&gt;</code>向后缩进。</li></ul><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><ol><li><code>Ctrl + q</code>进入<strong>viusal block</strong>模式。</li><li>通过<code>j</code>或<code>k</code>选中多行。</li><li>通过<code>Ctrl + i</code>进入<strong>insert</strong>模式。</li><li>输入输入的内容，通过Esc键退出编辑模式即可。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回调函数（Callback）</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/programmingbasics/Callback/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/programmingbasics/Callback/</url>
    
    <content type="html"><![CDATA[<h1 id="回调函数（Callback）"><a href="#回调函数（Callback）" class="headerlink" title="回调函数（Callback）"></a>回调函数（Callback）</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>回调函数涉及三者：<ul><li>起始函数</li><li>中间函数</li><li>回调函数</li></ul></li><li>起始函数：向中间函数发起调用操作，向中间函数中传入特定的回调函数。</li><li>中间函数：接收起始函数的调用，并在特定的时间调用传来的回调函数。</li><li>回调函数：由中间函数调用，完成整个调用链。</li></ul><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>快递公司提供包裹投递功能。你（起始函数）将包裹给快递公司（中间函数），快递公司通过运输将包裹送到指定的收件人手中（回调函数）。</p><p><img src="../../imgs/callback.png"></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 起始函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sender</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>        Receiver r = <span class="hljs-keyword">new</span> Zhangsan();<br>        Express.transport(r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中间函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Express</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">transport</span><span class="hljs-params">(Receiver r)</span> </span>&#123;<br>        r.receive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回调函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// receive a package</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zhangsan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Receiver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// It&#x27;s zhangsan.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.zhihu.com/question/19801131/answer/27459821">回调函数（callback）是什么？</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">回调函数（wikipedia）</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python相关问题总结</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/python/python_questions/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/python/python_questions/</url>
    
    <content type="html"><![CDATA[<h1 id="Python相关问题总结"><a href="#Python相关问题总结" class="headerlink" title="Python相关问题总结"></a>Python相关问题总结</h1><blockquote><p>这里保存着学习、使用Python以及相关软件时遇到的问题以及对应的解决方案。</p></blockquote><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><table><thead><tr><th>问题描述</th><th>原因</th><th>解决方案</th><th>参考文献</th><th>备注</th></tr></thead><tbody><tr><td>安装Anaconda后Terminal中提示行开始出现(base)</td><td></td><td>修改<code>~/.condarc</code>文件，添加<code>changeps1: False</code></td><td><a href="https://www.jianshu.com/p/6cdc9713c4ed">安装conda后终端出现的(base)字样去除方法</a> <a href="https://conda.io/projects/conda/en/latest/user-guide/configuration/use-condarc.html#change-command-prompt-changeps1">Change command prompt (changeps1)</a></td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TiKV源码解析（一）</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/tikv/tikv1/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/tikv/tikv1/</url>
    
    <content type="html"><![CDATA[<h1 id="TiKV源码解析（一）"><a href="#TiKV源码解析（一）" class="headerlink" title="TiKV源码解析（一）"></a>TiKV源码解析（一）</h1><p>[toc]</p><hr><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>TiKV使用RocksDB作为底层数据存储方案。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>TiKV使用<strong>Raft</strong>作为一致性协议。</p><h3 id="通讯框架"><a href="#通讯框架" class="headerlink" title="通讯框架"></a>通讯框架</h3><p>TiKV使用<strong>gRPC</strong>作为通讯框架。</p><h3 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h3><p>TiKV使用<strong>Prometheus</strong>作为监控系统。</p><h3 id="错误注入"><a href="#错误注入" class="headerlink" title="错误注入"></a>错误注入</h3><p>TiKV使用<strong>Fail</strong>作为错误注入工具测试系统稳定性。</p><hr><h2 id="项目组成"><a href="#项目组成" class="headerlink" title="项目组成"></a>项目组成</h2><ul><li>Raftstore：TiKV如何使用Raft</li><li>Storage：MVCC，数据在engine里的存储方式，engine相关API。</li><li>Server：TiKV的gRPC API</li><li>Corprocessor：TiKV处理TiDB的下退请求</li><li>PD：TiKV与PD交互</li><li>Import：TiKV处理大量数据导入</li><li>Util：TiKV基本功能库</li></ul><p>注：PD负责整个TiKV的调度。PD使用etcd进行元数据的存取和高可用支持。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://pingcap.com/zh/blog/tikv-source-code-reading-1">TiKV 源码解析系列文章（一）序</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TiKV源码解析（二）：raft-rs proposal示例场景分析</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/tikv/tikv2/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/tikv/tikv2/</url>
    
    <content type="html"><![CDATA[<h1 id="TiKV源码解析（二）：raft-rs-proposal示例场景分析"><a href="#TiKV源码解析（二）：raft-rs-proposal示例场景分析" class="headerlink" title="TiKV源码解析（二）：raft-rs proposal示例场景分析"></a>TiKV源码解析（二）：raft-rs proposal示例场景分析</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>发起一次请求称为一次proposal。</li><li>一个raft实例使用一个RawNode进行表示。</li><li>每个RawNode实例运行时主要逻辑是如下的循环：<ul><li>使用<code>Step()</code>方法处理所有接收到的消息Message。</li><li>每隔一段时间，通过调用<code>tick()</code>方法使Raft的逻辑时钟前进一次。</li><li>调用<code>ready</code>接口从Raft中获取最新的日志(<code>entries</code>)，已提交的日志(<code>committed_entries</code>)和待发送给其他节点的消息。</li><li>对最新的日志进行持久化操作。</li><li>将待发送的消息发送给对应的节点。</li><li>处理已提交的日志。</li><li>确保一个<code>ready</code>接口中的所有进度被处理完毕后，调用<code>advance</code>接口。</li></ul></li></ul><p>伪代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-built_in">sleep</span>()<br>    <span class="hljs-keyword">for</span> msg := <span class="hljs-built_in">receive_msg</span>() &#123;<br>        node.<span class="hljs-built_in">step</span>(msg) <span class="hljs-comment">// 处理消息</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> last_time - current_time &gt;= timeout &#123;<br>        <span class="hljs-built_in">tick</span>() <span class="hljs-comment">// 定期驱动逻辑时钟前进，分别触发不同角色发生不同的操作</span><br>    &#125;<br>    ready := node.<span class="hljs-built_in">ready</span>() <span class="hljs-comment">// 获取待处理的信息</span><br>    <span class="hljs-built_in">persist</span>(ready.<span class="hljs-built_in">entries</span>()) <span class="hljs-comment">// 将最新的日志持久化</span><br>    <span class="hljs-built_in">send_all</span>(ready.messages) <span class="hljs-comment">// 将收到的消息发送给对应节点</span><br>    <span class="hljs-built_in">handle_committed_entries</span>(ready.committed_entries) <span class="hljs-comment">// 处理已提交的日志</span><br>    node.<span class="hljs-built_in">advance</span>(ready) <span class="hljs-comment">// 更新内部信息</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><p>Raft算法中的日志复制部分 ==&gt; 不断追加写入新日志的持久化数组。<br>其中包含如下信息：<br>|方法|描述|<br>|—|—|<br>|initial_state|Raft节点初始化信息|<br>|entries|用于获取给定范围内的Raft Log|<br>|term|特定日志的term|<br>|first_index|未被清理的最早日志|<br>|last_index|最后一个日志|<br>|snapshot|用于发送给落后很多的follower|</p><hr><h2 id="ready-方法"><a href="#ready-方法" class="headerlink" title="ready()方法"></a><code>ready()</code>方法</h2><p>返回一个<code>Ready</code>结构体，主要有：<br>|方法/字段|作用|<br>|—|—|<br>|entries()|获取发送到Raft中但未持久化的Raft Log|<br>|committed_entries|取出持久化并提交的Raft Log|<br>|messages|需要发送给对应节点的消息|</p><p>当一个客户端在<code>propose</code>一个消息之后，应该调用<code>RawNode.ready()</code>方法并在返回的<code>Ready</code>结构体上继续处理：</p><ul><li>持久化Raft Log</li><li>将Raft消息发送到网络上</li></ul><p>对于一个leader而言：在收到足够的对特定Raft Log的回复后，则认为这个Raft Log已被确认。调用<code>maybe_commit()</code>方法后在下一次该Raft节点调用<code>ready()</code>方法并可以取出已被确认的消息并应用到状态机中。</p><p>在一个<code>Ready</code>结构体中的内容被处理完成后，可以调用<code>advance()</code>方法更新Raft中的进度，包括<code>last_index</code>、<code>commit_index</code>和<code>apply_index</code>等。</p><hr><h2 id="step接口"><a href="#step接口" class="headerlink" title="step接口"></a><code>step</code>接口</h2><p>目的：<strong>用于处理从其他节点收到的消息</strong>。</p><ul><li>follower收到leader发送的日志，需要将日志存储并回复ACK。</li><li>节点收到更大term的选举消息时，进入选举状态并回复投票信息。</li></ul><p>举例（提交写入过程）：</p><ul><li>客户端调用<code>RawNode.propose()</code>方法请求写入。</li><li><code>RawNode.propose()</code>方法调用<code>RawNode.step()</code>方法，参数为<code>MsgPropose</code>类型的消息，客户端写入的数据包装在消息中。</li><li><code>RawNode.step()</code>方法根据消息的类型调用<code>Raft.step_leader()</code>函数，将消息作为一个Raft Log赞存起来，并广播到follower中。（此时<code>propose()</code>方法可以返回，但Raft Log没有持久化并且广播给follower的MsgAppend消息没有发送）</li><li>此时程序挂起，等待Raft获取这个写入操作已经被集群中的过半的节点确认之后，向写入的发起者返回写入成功的响应。</li></ul><hr><h2 id="tick接口"><a href="#tick接口" class="headerlink" title="tick接口"></a><code>tick</code>接口</h2><p>目的：<strong>驱动Raft内部的逻辑时钟前进，对超时进行处理</strong>。</p><ul><li>对follower：<ul><li>在tick时发现leader失联很久，则发起一次选举。</li></ul></li><li>对leader：<ul><li>避免被替代，在更短的超时向follower发送心跳。</li></ul></li></ul><p>注意：<code>tick</code>会产生Raft消息，为了及时发送出去，在每次轮寻先处理<code>tick</code>，再处理<code>Ready</code>。</p><hr><h2 id="整体流程图示"><a href="#整体流程图示" class="headerlink" title="整体流程图示"></a>整体流程图示</h2><p><img src="https://img1.www.pingcap.com/prod/1_cd54338342.png" alt="一次propose的整体流程"></p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://pingcap.com/zh/blog/tikv-source-code-reading-2">TiKV 源码解析系列文章（二）raft-rs proposal 示例情景分析</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TiKV源码解析（六）：raft-rs日志复制过程分析</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/tikv/tikv6/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/tikv/tikv6/</url>
    
    <content type="html"><![CDATA[<h1 id="TiKV源码解析（六）：raft-rs日志复制过程分析"><a href="#TiKV源码解析（六）：raft-rs日志复制过程分析" class="headerlink" title="TiKV源码解析（六）：raft-rs日志复制过程分析"></a>TiKV源码解析（六）：raft-rs日志复制过程分析</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在raft-rs中，与应用程序交互的主要API有：</p><ul><li><code>RawNode.propose</code>发起一次新的提交，尝试在Raft日志中追加一个新项</li><li><code>RawNode.ready_since</code>从Raft节点中获取最近的更新（新近追加的日志、新近确认的日志、需要发送给其他节点的消息）</li><li><code>RawNode.advance</code>在一个Ready中所有的更新处理完毕后，将这个Raft节点中的这个<code>Ready</code>标记为已完成状态。</li></ul><hr><h2 id="一般的MsgAppend和MsgAppendResponse的处理"><a href="#一般的MsgAppend和MsgAppendResponse的处理" class="headerlink" title="一般的MsgAppend和MsgAppendResponse的处理"></a>一般的<code>MsgAppend</code>和<code>MsgAppendResponse</code>的处理</h2><ol><li>对于leader而言，程序的一次propose操作发起的写入请求被处理成一条<code>MsgAppend</code>类型的消息。</li><li>然后调用<code>Raft.append_entry</code>将消息中的数据追加到Raft日志中并通过<code>Raft.bcast_append</code>广播到其他节点。</li></ol><p>流程伪代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func step<span class="hljs-constructor">_leader(<span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> msg_type<span class="hljs-operator"> == </span>MessageType.MsgPropose &#123;<br>        append<span class="hljs-constructor">_entry(&amp;<span class="hljs-params">msg</span>.<span class="hljs-params">entries</span>()</span>)<br>        bcast<span class="hljs-constructor">_append()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>append_entry()</code>方法参数为引用，因为需要为每个Entry赋予正确的term和index。term由选举产生的leader的term，index是该Entry在Raft日志中的下标。</li><li>需要term和index的原因：一个旧的leader可能在系统位置（相同index）广播过了一条过期Entry。当其他节点收到重复的、更高的term的消息，会用该消息覆盖之前的消息，从而与最新的leader保持一致。</li><li>在将新的写入追加到自己的Raft Log中后，可以调用<code>bcast_append()</code>将这些消息广播到其他节点。</li><li>每个节点的进度可能不同，则需要<code>Progress</code>结构体对每个节点的进度进行记录。<table><thead><tr><th>Progress中的字段</th><th>解释</th></tr></thead><tbody><tr><td>matched</td><td></td></tr><tr><td>next_idx</td><td>该节点希望收到的下一个Entry的index</td></tr><tr><td>ins</td><td>未提交的消息的滑动窗口</td></tr><tr><td>state</td><td>进度状态</td></tr><tr><td>paused</td><td>是否暂停向该节点发送</td></tr></tbody></table></li></ul><blockquote><p><strong>设置next_idx的一些细节</strong><br>刚启动时所有副本的<code>next_idx</code>如何设置：当选出新的leader时，<code>reset()</code>方法中将leader中记录的所有节点的<code>next_id</code>设置为与leader相同，然后leader广播一条包含自己term的空Entry。<br>接收到leader的广播的新写入后，各节点如何向leader更新<code>next_idx</code>：在<code>handle_append_response</code>函数中，各节点在收到leader广播的最新的日志后，存在两种情况：</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func handle_append_response(msg) &#123;<br>    resp := new_message_append_response()<br>    ok := this<span class="hljs-selector-class">.logs</span><span class="hljs-selector-class">.maybe_append</span>()<br>    <span class="hljs-keyword">if</span> ok &#123;<br>        resp<span class="hljs-selector-class">.set_index</span>(last_index) <span class="hljs-comment">// 追加日志成功，将最新的last_index发送给leader</span><br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 追加日志失败，设置reject并告知自己的last index</span><br>        resp<span class="hljs-selector-class">.set_reject</span>(true)<br>        resp<span class="hljs-selector-class">.set_reject_hint</span>(this<span class="hljs-selector-class">.logs</span><span class="hljs-selector-class">.last_index</span>())<br>    &#125;<br>    send(resp)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>节点调用<code>maybe_append</code>失败的原因是其日志比leader的日志少，而新选举的leader默认将所有节点的<code>next_idx</code>设置与自己相同。这样日志就无法匹配而遭到其他节点的拒绝。leader收到拒绝响应后更新对应节点的<code>next_idx</code>。</p></blockquote><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas">func handle_append_response(msg) &#123;<br>    <span class="hljs-meta">if</span> m.get_reject() &#123; // 被节点拒绝，获取节点的last <span class="hljs-meta">index</span>作为其last_idx<br>        new_progress := get_progress(msg)<br>        maybe_decr_to(msg.get<span class="hljs-meta">_index(</span>), msg.get_reject_<span class="hljs-meta">hint(</span>))<br>    &#125; <span class="hljs-meta">else</span> &#123; // 节点接受，将next_idx更新为msg.get<span class="hljs-meta">_index(</span>) + 1<br>        maybe_u<span class="hljs-meta">pdate(</span>msg.get<span class="hljs-meta">_index(</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>// TODO</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://pingcap.com/zh/blog/tikv-source-code-reading-6">TiKV 源码解析系列文章（六）raft-rs 日志复制过程分析</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>android.os.Handler小结</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/SourceCodeReadNotes/android_os_Handler/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/SourceCodeReadNotes/android_os_Handler/</url>
    
    <content type="html"><![CDATA[<h1 id="android-os-Handler小结"><a href="#android-os-Handler小结" class="headerlink" title="android.os.Handler小结"></a>android.os.Handler小结</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>基本功能：向特定线程发送消息<code>Message</code>（或<code>Runnable</code>），处理当前线程的消息或<code>Runnable</code>。</p><p>特点：</p><ul><li>每个<code>Handler</code>绑定到一个特定的线程。</li><li>每个线程有一个对应的<code>Looper</code>，而<code>Looper</code>持有一个<code>MessageQueue</code>。当将<code>Handler</code>与特定的<code>Looper</code>绑定，则该<code>Handler</code>与将消息发送到该<code>Looper</code>的<code>MessageQueue</code>中，并处理该<code>Looper</code>传递的消息。</li></ul><p>示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>android.os.Looper小结</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/SourceCodeReadNotes/android_os_Looper/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/SourceCodeReadNotes/android_os_Looper/</url>
    
    <content type="html"><![CDATA[<h1 id="android-os-Looper小结"><a href="#android-os-Looper小结" class="headerlink" title="android.os.Looper小结"></a>android.os.Looper小结</h1><p>[toc]</p><hr><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="java">public final class Looper &#123;    static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();    // 整个应用的主Looper，位于主线程中    private static Looper sMainLooper;    final MessageQueue mQueue;    final Thread mThread;    private boolean mInLoop;    /** Initialize the current thread as a looper.      * This gives you a chance to create handlers that then reference      * this looper, before actually starting the loop. Be sure to call      * &#123;@link #loop()&#125; after calling this method, and end it by calling      * &#123;@link #quit()&#125;.      */    // 将当前线程与新的Looper实例绑定    // 使用流程是 prepare() ==&gt; loop() ==&gt; Handler ==&gt; quie()    public static void prepare() &#123;        prepare(true);    &#125;    private static void prepare(boolean quitAllowed) &#123;        if (sThreadLocal.get() != null) &#123;            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);        &#125;        sThreadLocal.set(new Looper(quitAllowed));    &#125;    // 返回整个应用的主Looper，位于主线程中    public static Looper getMainLooper() &#123;        synchronized (Looper.class) &#123;            return sMainLooper;        &#125;    &#125;    // 依次将消息队列中的所有Message分配给对应的Handler进行处理    public static void loop() &#123;        final Looper me = myLooper();        if (me == null) &#123;            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);        &#125;        if (me.mInLoop) &#123;            Slog.w(TAG, &quot;Loop again would have the queued messages be executed&quot;                    + &quot; before this one completed.&quot;);        &#125;        me.mInLoop = true;        final MessageQueue queue = me.mQueue;        // Make sure the identity of this thread is that of the local process,        // and keep track of what that identity token actually is.        Binder.clearCallingIdentity();        final long ident = Binder.clearCallingIdentity();        // Allow overriding a threshold with a system prop. e.g.        // adb shell &#39;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#39;        final int thresholdOverride =                SystemProperties.getInt(&quot;log.looper.&quot;                        + Process.myUid() + &quot;.&quot;                        + Thread.currentThread().getName()                        + &quot;.slow&quot;, 0);        boolean slowDeliveryDetected = false;        // 对于消息队列中的Message依次处理        for (;;) &#123;            Message msg = queue.next(); // might block            if (msg == null) &#123;                // No message indicates that the message queue is quitting.                return;            &#125;            // This must be in a local variable, in case a UI event sets the logger            final Printer logging = me.mLogging;            if (logging != null) &#123;                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +                        msg.callback + &quot;: &quot; + msg.what);            &#125;            // Make sure the observer won&#39;t change while processing a transaction.            final Observer observer = sObserver;            final long traceTag = me.mTraceTag;            long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;            long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;            if (thresholdOverride &gt; 0) &#123;                slowDispatchThresholdMs = thresholdOverride;                slowDeliveryThresholdMs = thresholdOverride;            &#125;            final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0);            final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0);            final boolean needStartTime = logSlowDelivery || logSlowDispatch;            final boolean needEndTime = logSlowDispatch;            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));            &#125;            final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;            final long dispatchEnd;            Object token = null;            if (observer != null) &#123;                token = observer.messageDispatchStarting();            &#125;            long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);            try &#123;                // 关键步骤：将每个Message分配给对应的Handler进行处理                msg.target.dispatchMessage(msg);                if (observer != null) &#123;                    observer.messageDispatched(token, msg);                &#125;                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;            &#125; catch (Exception exception) &#123;                if (observer != null) &#123;                    observer.dispatchingThrewException(token, msg, exception);                &#125;                throw exception;            &#125; finally &#123;                ThreadLocalWorkSource.restore(origWorkSource);                if (traceTag != 0) &#123;                    Trace.traceEnd(traceTag);                &#125;            &#125;            if (logSlowDelivery) &#123;                if (slowDeliveryDetected) &#123;                    if ((dispatchStart - msg.when) &lt;= 10) &#123;                        Slog.w(TAG, &quot;Drained&quot;);                        slowDeliveryDetected = false;                    &#125;                &#125; else &#123;                    if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;,                            msg)) &#123;                        // Once we write a slow delivery log, suppress until the queue drains.                        slowDeliveryDetected = true;                    &#125;                &#125;            &#125;            if (logSlowDispatch) &#123;                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg);            &#125;            if (logging != null) &#123;                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);            &#125;            // Make sure that during the course of dispatching the            // identity of the thread wasn&#39;t corrupted.            final long newIdent = Binder.clearCallingIdentity();            if (ident != newIdent) &#123;                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;                        + Long.toHexString(ident) + &quot; to 0x&quot;                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;                        + msg.target.getClass().getName() + &quot; &quot;                        + msg.callback + &quot; what=&quot; + msg.what);            &#125;            msg.recycleUnchecked();        &#125;    &#125;    // 当前线程绑定的Looper    public static @Nullable Looper myLooper() &#123;        return sThreadLocal.get();    &#125;    // 当前线程对应的消息队列    public static @NonNull MessageQueue myQueue() &#123;        return myLooper().mQueue;    &#125;    private Looper(boolean quitAllowed) &#123;        mQueue = new MessageQueue(quitAllowed);        mThread = Thread.currentThread();    &#125;    // 退出队列    // 导致消息队列中已有的Message不再被处理（即这些消息无法被传递到对应的Handler进行处理），试图向消息队列中添加Message失败    public void quit() &#123;        mQueue.quit(false);    &#125;    // 试图向队列中添加Message将失败    // 队列中已有的Message将会被传递给对应的Handler进行处理    // 队列中延迟的Message将无法传递给对应的Handler进行处理    public void quitSafely() &#123;        mQueue.quit(true);    &#125;&#125;---## 问题总结### `Looper`是如何与特定的线程绑定的？答：`Looper`中有一个字段`ThreadLocal&lt;Looper&gt; sThreadLocal`，当该`ThreadLocal`变量创建时，就与当前的线程绑定在一起。这样在Looper.prepare()`方法中通过`sThreadLocal.set()`方法向线程中放置一个`Looper`实例对象。</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>android.os.Message源码阅读总结</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/SourceCodeReadNotes/android_os_Message/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/SourceCodeReadNotes/android_os_Message/</url>
    
    <content type="html"><![CDATA[<h1 id="android-os-Message源码阅读总结"><a href="#android-os-Message源码阅读总结" class="headerlink" title="android.os.Message源码阅读总结"></a>android.os.Message源码阅读总结</h1><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>功能：消息进入消息队列<br>基本流程：按照<code>Message.when</code>在队列中寻找合适的位置将新的Message插入到消息队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果Message没有对应的Handler，则报错</span><br>    <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-comment">// 如果Message已经在使用了，则报错</span><br>        <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 如果消息队列MessageQueue已经退出，即对应的Thread已经终止，则报错</span><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            IllegalStateException e = <span class="hljs-keyword">new</span> IllegalStateException(<br>                    msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>            Log.w(TAG, e.getMessage(), e);<br>            msg.recycle();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 标记该Message正在使用</span><br>        msg.markInUse();<br>        <span class="hljs-comment">// 将Message的when设置为指定的when</span><br>        msg.when = when;<br>        <span class="hljs-comment">// mMessages为当前队列的头</span><br>        Message p = mMessages;<br>        <span class="hljs-keyword">boolean</span> needWake;<br>        <span class="hljs-comment">// 队列为空，设置执行时间为立即执行或者小于队列头Message的时间点，则将新的Message放置到队列首部</span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 只有当队列是阻塞状态、队列首部的Message对应的Handler为空并且新的Message是异步执行的才需要唤醒</span><br>            needWake = mBlocked &amp;&amp; p.target == <span class="hljs-keyword">null</span> &amp;&amp; msg.isAsynchronous();<br>            Message prev;<br>            <span class="hljs-comment">// 在消息队列中为新的Message寻找合适的位置（按照when排序寻找）</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when &lt; p.when) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                    needWake = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将新的Meesage插入到找到的位置上</span><br>            msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>            prev.next = msg;<br>        &#125;<br>        <span class="hljs-comment">// 必要时进行唤醒</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Activity Results API</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/ActivityResultsAPI/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/ActivityResultsAPI/</url>
    
    <content type="html"><![CDATA[<h1 id="Activity-Results-API"><a href="#Activity-Results-API" class="headerlink" title="Activity Results API"></a>Activity Results API</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>常见的启动<code>Activity</code>并获取返回数据的方式是通过<code>Intent</code>携带数据，使用<code>startActivityForResult</code>方法启动下一个<code>Activity</code>，然后重写<code>onActivityResult</code>方法处理返回的数据。</li><li>Android官方已经废弃<code>startActivityForResult</code>方法，推荐使用Activity Results API。</li></ul><p>常见的<code>startActivityForResult</code>方法流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Activity 1</span><br><br>Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, Activity2.class);<br>startActivityForResult(intent, <span class="hljs-number">1</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> resultCode, <span class="hljs-meta">@Nullable</span> Intent data)</span></span>&#123;<br><span class="hljs-comment">// do something with the result from activity 2</span><br></code></pre></td></tr></table></figure><h2 id="Activity-Results-API-1"><a href="#Activity-Results-API-1" class="headerlink" title="Activity Results API"></a>Activity Results API</h2><ul><li>Activity Results API是官方推荐的<code>Activity</code>,<code>Fragment</code>获取数据的方式。</li><li>其中有三个关键组件：<code>ActivityResultContract</code>，<code>ActivityResultCallback</code>和<code>ActivityResultLauncher</code>。<ul><li><code>ActivityResultContract</code>：定义如何传递数据以及如何处理返回的数据。</li><li><code>ActivityResultCallback</code>：当一个<code>Activity</code>获取返回结果时调用该回调函数。</li><li><code>ActivityResultLauncher</code>：用于启动一个Activity的启动器。</li></ul></li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>定义数据输入输出协议<code>ActivityResultContract&lt;I, O&gt;</code>。</li><li>定义回调函数<code>ActivityResultLauncher</code>。</li><li>注册协议，获取启动器<code>ActivityResultLauncher</code>。</li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义协议</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivityResultContract</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ActivityResultContract</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">String</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Intent <span class="hljs-title">createIntent</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, String input)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Intent(context, Activity2.class).putExtra(<span class="hljs-string">&quot;name&quot;</span>, input);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">parseResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resultCode, <span class="hljs-meta">@Nullable</span> Intent intent)</span> </span>&#123;<br>String data = intent.getStringExtra(<span class="hljs-string">&quot;result&quot;</span>);<br><span class="hljs-keyword">return</span> (resultCode == Activity.RESULT_OK &amp;&amp; data != <span class="hljs-keyword">null</span>) ? data : <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 自定义回调函数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivityResultCallback</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ActivityResultCallback</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(String result)</span> </span>&#123;<br><span class="hljs-comment">// do something with the result from activity 2</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 获取启动器</span><br>ActivityResultLauncher&lt;String&gt; launcher = registerForActivityResult(<span class="hljs-keyword">new</span> MyActvitityContract(), <span class="hljs-keyword">new</span> MyActivityResultCallback());<br>launcher.launch(<span class="hljs-string">&quot;hello, it&#x27;s activity 2&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="内置的协议"><a href="#内置的协议" class="headerlink" title="内置的协议"></a>内置的协议</h3><p>除了自定义数据处理协议，Android内置了常用的协议(具体参见<code>ActivityResultContracts</code>)：</p><ul><li><code>StartActivityForResult</code></li><li><code>RequestMultiplePermission</code></li><li><code>RequestPermission</code></li><li><code>TakePicture</code></li><li><code>TakeVideo</code></li><li><code>PickContact</code></li><li>…</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 启动新的Activity</span><br>ActivityResultLauncher&lt;Intent&gt; launcher = registerForActivityResult(<span class="hljs-keyword">new</span> ActivityResultContracts.StartActivityForResult(), <span class="hljs-keyword">new</span> ActivityResultCallback&lt;ActivityResult&gt;() &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(ActivityResult result)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (result.getResultCode() == Activity.RESULT_OK) &#123;<br><span class="hljs-comment">// do something with the result from activity 2</span><br>&#125;<br>&#125;<br>&#125;);<br><br><span class="hljs-comment">// lambda表达式</span><br>ActivityResultLauncher&lt;Intent&gt; launcher = registerForActivityResult(<span class="hljs-keyword">new</span> ActivityResultContacts.StartActivityForResult(), v -&gt; &#123;<br><span class="hljs-keyword">if</span> (v.getResultCode() == Activity.RESULT_OK) &#123;<br><span class="hljs-comment">// do something with the result from activity 2</span><br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 申请权限</span><br>ActivityResultLauncher&lt;String&gt; launcher = registerForActivityResult(<span class="hljs-keyword">new</span> ActivityResultContracts.RequestPermission(), v -&gt; &#123;<br><span class="hljs-keyword">if</span> (v) <span class="hljs-comment">// get permission</span><br><span class="hljs-keyword">else</span> <span class="hljs-comment">//fail to get permission</span><br>&#125;);<br><br>launcher.launch(Manifest.permission.READ_CONTACTS);<br></code></pre></td></tr></table></figure><p>获取图片：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ActivityResultLauncher&lt;String&gt; launcher = registerForActivityResult(<span class="hljs-keyword">new</span> ActivityResultContracts.GetContent(), v -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (v == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(v));<br>iv_show_image.setImageBitmap(bitmap);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;<br>&#125;);<br><br>launcher.launch(<span class="hljs-string">&quot;image/*&quot;</span>);<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>申请权限时需要在<code>AndroidManifest.xml</code>中声明所使用的权限，如：<code>&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;</code>。</li></ul><p>// TODO …</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000037601888">再见！onActivityResult！你好，Activity Results API！</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android中的AsyncTask被废弃，原因和对策</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/AsyncTaskDeprecated/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/AsyncTaskDeprecated/</url>
    
    <content type="html"><![CDATA[<h1 id="Android中的AsyncTask被废弃，原因和对策"><a href="#Android中的AsyncTask被废弃，原因和对策" class="headerlink" title="Android中的AsyncTask被废弃，原因和对策"></a>Android中的AsyncTask被废弃，原因和对策</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><code>AsyncTask</code>被Android官方废弃（deprecated）。</li><li>官方指出<code>AsyncTask</code>可能导致内存泄漏，回调丢失以及配置更改导致崩溃。</li></ul><hr><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li>内存泄漏与使用<code>AsyncTask</code>无直接关系，使用其他多线程框架仍然可能产生内存泄漏。</li><li><code>AsyncTask</code>使得多线程更加复杂，并没有简化多线程的使用。</li><li><code>AsyncTask</code>的文档描述不清楚。</li><li><code>AsyncTask</code>API复杂，容易误用。</li><li><code>AsyncTask</code>滥用继承，不符合推荐使用组合的原则。</li><li><code>AsyncTask</code>的可靠性存在问题，默认配置可能导致程序崩溃。</li></ul><hr><h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2><h3 id="使用Executor和Handler组合"><a href="#使用Executor和Handler组合" class="headerlink" title="使用Executor和Handler组合"></a>使用<code>Executor</code>和<code>Handler</code>组合</h3><ul><li><code>Executor</code>将在后台执行任务，<code>Handler</code>用于更新UI。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">btn_okhttp_send_request.setOnClickListener(v -&gt; &#123;<br>    ExecutorService executorService = Executors.newSingleThreadExecutor();<br>    Handler handler = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper());<br>    executorService.execute(() -&gt; &#123;<br>OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();<br>Request request = <span class="hljs-keyword">new</span> Request.Builder().<br>url(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>.build();<br><span class="hljs-keyword">try</span> &#123;<br>    Response response = client.newCall(request).execute();<br>    String responseRes = response.body() == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : response.body().string();<br>    <span class="hljs-keyword">if</span> (responseRes != <span class="hljs-keyword">null</span>) handler.post(() -&gt; &#123;tv_okhttp_show_result.setText(responseRes);&#125;);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="使用Thread类"><a href="#使用Thread类" class="headerlink" title="使用Thread类"></a>使用<code>Thread</code>类</h3><ul><li>通过创建新的线程并在线程内执行耗时操作。</li><li>无法从子线程中进行UI操作，可以通过<code>runOnUiThread</code>方法进行UI更新操作。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 后台执行网络任务</span><br>btn_okhttp_send_request.setOnClickListener(v -&gt; &#123;<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>ExecutorService executorService = Executors.newSingleThreadExecutor();<br>Handler handler = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper());<br>executorService.execute(() -&gt; &#123;<br>    OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();<br>    Request request = <span class="hljs-keyword">new</span> Request.Builder().<br>    url(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>    .build();<br>    <span class="hljs-keyword">try</span> &#123;<br>Response response = client.newCall(request).execute();<br>String responseRes = response.body() == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : response.body().string();<br><span class="hljs-keyword">if</span> (responseRes != <span class="hljs-keyword">null</span>) setText(responseRes);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>    &#125;<br>&#125;);<br>    &#125;).start();<br>&#125;);<br><br><span class="hljs-comment">// UI更新操作，必须在UI线程执行，不能在子线程进行UI操作</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setText</span><span class="hljs-params">(String s)</span> </span>&#123;<br>runOnUiThread(() -&gt; &#123;tv_okhttp_show_result.setText(s);&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/qq_32916805/article/details/103996274">震惊！AsyncTask将被弃用？</a></li><li><a href="https://www.geeksforgeeks.org/alternatives-for-the-deprecated-asynctask-in-android/">Alternatives for the Deprecated AsyncTask in Android</a></li><li><a href="https://www.androiddesignpatterns.com/2012/06/app-force-close-honeycomb-ics.html">Why Ice Cream Sandwich Crashes your App</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android中的数据绑定库(Data binding library)</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/DataBindingLibrary/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/DataBindingLibrary/</url>
    
    <content type="html"><![CDATA[<h1 id="Android中的数据绑定库-Data-binding-library"><a href="#Android中的数据绑定库-Data-binding-library" class="headerlink" title="Android中的数据绑定库(Data binding library)"></a>Android中的数据绑定库(Data binding library)</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>环境要求：</p><ul><li>Android 4.0 (API 14)及以上。</li><li>Gradle 1.5.0及以上。</li></ul><p>配置环境：<br>在应用模块的<code>builde.gradle</code>设置打开数据绑定选项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">android &#123;<br>buildFeatures &#123;<br>dataBinding true<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="简单的数据绑定示例"><a href="#简单的数据绑定示例" class="headerlink" title="简单的数据绑定示例"></a>简单的数据绑定示例</h2><p>通常情况下，为了实现组件和对应数据的绑定，需要通过方法<code>findViewById()</code>方法实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">findViewById&lt;TextView&gt;(R.id.my_text).apply &#123;<br>text = <span class="hljs-string">&quot;test message&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而通过使用数据绑定，可以直接在布局文件中为组件设置对应的数据。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;viewmodel.userName&#125;&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>通过在布局文件中绑定数据，可以使得你移除在<code>Activity</code>中存在的大量调用UI组件的代码。</p><p>注意：视图绑定(view binding)也可以提供类似的功能，若想取代<code>findViewById()</code>方法，则可以考虑优先使用视图绑定。</p><hr><h2 id="布局与绑定表达式"><a href="#布局与绑定表达式" class="headerlink" title="布局与绑定表达式"></a>布局与绑定表达式</h2><p>基本结构：数据绑定布局文件的根目录标签为<code>&lt;layout&gt;</code>，并且在其中放置<code>&lt;data&gt;</code>标签用来存放数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemes.android.com/apk/res/android&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.User&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;user.firstName&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;user.lastName&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><p>对于每个布局文件，会生成对应的绑定类。该类的类名是基于布局文件名，如布局文件为<code>activity_main.xml</code>，则生成的绑定类为<code>ActivityMainBinding</code>。这个类中保存着布局文件中的所有绑定数据。</p><p>可以通过如下方式创建绑定类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 获取绑定类对象</span><br><span class="hljs-keyword">val</span> binding: ActivityMainBinding = DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.activity_main)<br><br><span class="hljs-comment">// 设置数据绑定</span><br>binding.user = User(<span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-string">&quot;User&quot;</span>)<br></code></pre></td></tr></table></figure><p>也可以通过<code>LayoutInflater</code>获取对应的绑定类对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> binding: ActivityMainBinding = ActivityMainBinding.inflate(getLayoutInflater())<br></code></pre></td></tr></table></figure><h3 id="表达式语法"><a href="#表达式语法" class="headerlink" title="表达式语法"></a>表达式语法</h3><p>可以使用的操作符：</p><table><thead><tr><th>类型</th><th>操作符</th></tr></thead><tbody><tr><td>数学</td><td>+ - * / %</td></tr><tr><td>字符串拼接</td><td>+</td></tr><tr><td>逻辑运算符</td><td>&amp;&amp; ||</td></tr><tr><td>二值操作符</td><td>&amp; | ^</td></tr><tr><td>一元操作符</td><td>+ - ! ~</td></tr><tr><td>移位操作</td><td>&gt;&gt; &gt;&gt;&gt; &lt;&lt;</td></tr><tr><td>比较运算符</td><td>== &gt; &lt; &gt;= &lt;=</td></tr><tr><td>类型比较</td><td><code>instanceof</code></td></tr><tr><td>分组</td><td>()</td></tr><tr><td>字面值</td><td>字符，字符串，数值，null</td></tr><tr><td>类型转换</td><td></td></tr><tr><td>方法调用</td><td></td></tr><tr><td>域成员</td><td></td></tr><tr><td>数组访问</td><td>[]</td></tr><tr><td>三元操作符</td><td>?:</td></tr></tbody></table><p>注意：表达式中不支持：<code>this</code>，<code>super</code>，<code>new</code>等。</p><h4 id="null值处理"><a href="#null值处理" class="headerlink" title="null值处理"></a>null值处理</h4><p>null值处理运算符可以根据左值是否为null进行选择：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--若user.text为null，则为user.name，否则为user.text--&gt;</span><br>@&#123;user.text ?? user.name&#125;<br></code></pre></td></tr></table></figure><h4 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h4><p>数据绑定类会自动检查null值从而避免空指针异常。若为null，则根据不同的数据类型分配对应的默认值。</p><h4 id="组件引用"><a href="#组件引用" class="headerlink" title="组件引用"></a>组件引用</h4><p>在表达式中可以通过ID引用其他组件值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;TextView<br>    android:id=<span class="hljs-string">&quot;@+id/tv_user1&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:text=<span class="hljs-string">&#x27;@&#123;&quot;first name is&quot; + user.firstName&#125;&#x27;</span>/&gt;<br><br>&lt;TextView<br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:text=<span class="hljs-string">&#x27;@&#123;tvUser1.text&#125;&#x27;</span>/&gt;<br></code></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>通用的集合，如：Array, List, Map等可以通过[]进行访问：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.List&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.Map&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;List<span class="hljs-symbol">&amp;lt;</span>String&gt;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Map<span class="hljs-symbol">&amp;lt;</span>String, String&gt;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;String&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>android.text=&quot;@&#123;list[index]&#125;&quot;<br><br>android.text=&quot;@&#123;map[key]&#125;&quot;<br></code></pre></td></tr></table></figure><p>注意：在xml中无法使用”&lt;”，可以使用”&lt;”进行表示。</p><h4 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h4><p>为了在表达式中表示字符串，需要使用单引号引用表达式，在内部使用双引号引用字符串。<br>或者双引号引用表达式，引号`表示字符串：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">android.text=&#x27;@&#123;&quot;this is a test&quot;&#125;&#x27;<br><br><span class="hljs-comment">&lt;!--或者--&gt;</span><br>android.text=&quot;@&#123;`this is a test`&#125;&quot;<br></code></pre></td></tr></table></figure><h4 id="资源引用"><a href="#资源引用" class="headerlink" title="资源引用"></a>资源引用</h4><p>可以在表达式中引用资源：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引用字符串--&gt;</span><br>android:text=&quot;@&#123;@string/user1&#125;&quot;<br></code></pre></td></tr></table></figure><hr><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>数据绑定可以通过编写的表达式对于View的事件进行处理。而事件属性名是由监听器的方法名决定的。如<code>View.onClickListener</code>中有方法<code>onClick()</code>，则对应的时间属性为<code>android:onClick</code>。</p><p>除了通用的<code>android:onClick</code>外，还有一些特定的事件：<br>|类|监听器|属性|<br>|—|—|—|<br>|<code>SearchView</code>|<code>setOnSearchClickListener</code>|<code>android:onSearchLick</code>|<br>|<code>ZoomControls</code>|<code>setOnZoomInClickListener</code>|<code>android:onZoomIn</code>|<br>|<code>ZoomControls</code>|<code>setOnZoomOutClickListener</code>|<code>android:onZoomOut</code>|</p><p>提供两种方式处理一个事件：</p><ul><li>方法引用(Method references)：需要被引用的方法的参数列表与监听器方法的参数列表保持一致。数据绑定将会该方法引用包装进一个监听器并设置在对应的View上。</li><li>监听器绑定(Listener binding)：当对应事件发生时，执行对应的lambda表达式。</li></ul><blockquote><p>两个方法的主要区别是：<strong>方法引用是在数据绑定时创建对应的监听器实例，而监听器绑定是在对应的事件发生时执行对应的表达式</strong>。</p></blockquote><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用与一般的<code>onClick</code>方法的区别是表达式是在编译期被处理的，若方法不存在或参数有错则无法编译。</p><p>代码示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 自定义的处理方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandler</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onButtonClicked</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myHandler&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.MyHandler&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_user1&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:onClick</span>=<span class="hljs-string">&quot;@&#123;handler::onButtonClicked&#125;&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="监听器绑定"><a href="#监听器绑定" class="headerlink" title="监听器绑定"></a>监听器绑定</h3><p>监听器绑定当事件发生时运行对应的表达式。其类似于方法引用，但是不需要参数列表与监听器方法的参数列表保持一致，只需要返回值符合监听器对应的返回值类型即可。</p><p>代码示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 自定义处理方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Presenter</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSaveClick</span><span class="hljs-params">(task: <span class="hljs-type">Task</span>)</span></span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;task&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.Task&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;presenter&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.Presenter&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag"><span class="hljs-attr">...</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:onClick</span>=<span class="hljs-string">&quot;@&#123;() -&gt; presenter.onSaveClick(task)&#125;&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>监听器绑定对于参数列表有两种处理方式：1.声明所有的参数，2.忽略所有的参数。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// onClick方法的参数列表为: View -&gt; void，输入为View，返回值为void</span><br>android:onClick=<span class="hljs-string">&quot;@&#123;(view) -&gt; ... &#125;&quot;</span><br><br>android:onClick=<span class="hljs-string">&quot;@&#123;() -&gt; ... &#125;&quot;</span><br><br><span class="hljs-comment">// 可以不使用参数view</span><br>android:onClick=<span class="hljs-string">&quot;@&#123;(view) -&gt; ...&#125;&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="导入，变量和引入"><a href="#导入，变量和引入" class="headerlink" title="导入，变量和引入"></a>导入，变量和引入</h2><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>可以导入需要的类从而在数据绑定时使用该类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.List&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br></code></pre></td></tr></table></figure><p>类型别名：若导入多个类时出现重名，可以使用别名进行标记。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.List&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;MyList&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br></code></pre></td></tr></table></figure><p>导入的类可以用于变量或表达式中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.List&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myList&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;List<span class="hljs-symbol">&amp;lt;</span>String&gt;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：默认导入了<code>java.lang.*</code>。</p><p>可以使用导入的类作为类型转换：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:text=&quot;@&#123;((User)user).name&#125;&quot;<br></code></pre></td></tr></table></figure><p>导入的类可以调用其内的静态方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;MyUtils&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>android:text=&quot;@&#123;MyUtils.getCurrentTime()&#125;&quot;<br></code></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>通过标签<code>&lt;variable&gt;</code>可以在<code>&lt;data&gt;</code>定义一个变量，数据绑定将在生成的类中生成对应的变量以及set和get方法。这些变量根据其类型被赋以默认值。</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>一个布局文件中的变量可以传递给另一个布局文件。<br>通过<code>&lt;include&gt;</code>可以在布局文件中引入另一个布局文件，通过<code>bind</code>来将当前布局文件的变量绑定到另一个布局文件中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.User&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout_parent&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">bind:user</span>=<span class="hljs-string">&quot;@&#123;user&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：不能在一个<code>&lt;merge&gt;</code>元素的直接子标签中进行数据绑定。</p><hr><h2 id="可观察数据对象"><a href="#可观察数据对象" class="headerlink" title="可观察数据对象"></a>可观察数据对象</h2><p>在数据绑定中，被绑定的数据的更改不会导致对应UI的更新。为了使得UI能够感知数据的更改，可以使用可观察的数据对象。</p><p>常见的可观察类有三种：</p><ul><li>对象</li><li>域</li><li>集合</li></ul><h3 id="可观察的域"><a href="#可观察的域" class="headerlink" title="可观察的域"></a>可观察的域</h3><p>对于基本数据类型，已经预先定义了对应的可观察对象类型：</p><ul><li><code>ObservableBoolean</code></li><li><code>ObservableByte</code></li><li><code>ObservableChar</code></li><li><code>ObservableShort</code></li><li><code>ObservableInt</code></li><li><code>ObservableLong</code></li><li><code>ObservableFloat</code></li><li><code>ObservableDouble</code></li><li><code>ObservableParcelable</code></li></ul><p>基本使用方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 创建一个类，包含可观察域</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><span class="hljs-keyword">val</span> firstName = ObservableField&lt;String&gt;()<br><span class="hljs-keyword">val</span> age = ObservableInt()<br>&#125;<br><br><span class="hljs-comment">// 将该类与布局文件进行绑定</span><br><span class="hljs-keyword">val</span> binding = DataBindingUtil.setContentView&lt;ActivityMainBinding&gt;(<span class="hljs-keyword">this</span>, R.layout.activity_main)<br><span class="hljs-keyword">val</span> user = User()<br>binding.user = user<br><br><span class="hljs-comment">// 修改数据，自动更新UI</span><br>user.firstName = <span class="hljs-string">&quot;zhang&quot;</span><br><span class="hljs-keyword">val</span> age = user.age<br></code></pre></td></tr></table></figure><h3 id="可观察的集合"><a href="#可观察的集合" class="headerlink" title="可观察的集合"></a>可观察的集合</h3><p>可观察的集合需要动态保存数据，<code>ObservableArrayMap</code>使用key作为索引来获取数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ObservableArrayMap&lt;String, Any&gt;().apply &#123;<br>put(<span class="hljs-string">&quot;firstName&quot;</span>, <span class="hljs-string">&quot;zhang&quot;</span>)<br>put(<span class="hljs-string">&quot;lastName&quot;</span>, <span class="hljs-string">&quot;li&quot;</span>)<br>put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">20</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>获取数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;ObservableMap<span class="hljs-symbol">&amp;lt;</span>String, Object<span class="hljs-symbol">&amp;gt;</span>&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br>android:text=&quot;@&#123;user.lastName&#125;&quot;<br></code></pre></td></tr></table></figure><p><code>ObservableArrayList</code>提供可观察的List：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ObservableArrayList&lt;Any&gt;().apply &#123;<br>add(<span class="hljs-string">&quot;one&quot;</span>)<br>add(<span class="hljs-string">&quot;two&quot;</span>)<br>add(<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>获取数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;ObservableList<span class="hljs-symbol">&amp;lt;</span>Object<span class="hljs-symbol">&amp;gt;</span>&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>android:text=&quot;@&#123;user[0]&#125;&quot;<br></code></pre></td></tr></table></figure><h3 id="自定义可观察对象"><a href="#自定义可观察对象" class="headerlink" title="自定义可观察对象"></a>自定义可观察对象</h3><p>通过实现<code>Observable</code>接口，一个类可以注册监听器并在属性更改时发出通知。<code>Observable</code>提供添加和移除监听器的机制，由开发者自行决定何时发送通知。</p><p>为了简化开发，自定义的可观察对象可以继承自<code>BaseObservable</code>类，只需要自行决定在属性更改时发送通知即可。<br>一个简单的实现是对于<code>get()</code>方法设置注解<code>@Bindable</code>而在<code>set()</code>方法中调用<code>notifyPropertyChanged()</code>发送通知。</p><p>注意：</p><ul><li>数据绑定会生成一个名为<code>BR</code>的类，其中包含着数据绑定中所使用的资源ID。</li><li><code>@Bindable</code>注解会在编译期在<code>BR</code>类中为可观察对象生成一个入口，可以用来识别域值是否更改。</li></ul><p>代码示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>: <span class="hljs-type">BaseObservable</span></span>() &#123;<br><br><span class="hljs-meta">@get:Bindable</span><br><span class="hljs-keyword">var</span> firstName: String = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">set</span>(value) &#123;<br>field = value<br>notifyPropertyChanged(BR.firstName)<br>&#125;<br><br><span class="hljs-meta">@get:Bindable</span><br><span class="hljs-keyword">var</span> lastName: String= <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">set</span>(value) &#123;<br>field = value<br><span class="hljs-comment">// without notification, so modify this field will not trigger update UI</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生命周期感知对象"><a href="#生命周期感知对象" class="headerlink" title="生命周期感知对象"></a>生命周期感知对象</h3><p>使得布局更新能够感知UI的生命周期，只有在UI可见的情况下才进行更新操作。</p><p>示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> binding: UserBinding = DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.user)<br><br><span class="hljs-comment">// specify the current activity as the lifecycle owner</span><br>binding.lifecycleOwner = <span class="hljs-keyword">this</span><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.android.com/topic/libraries/data-binding">Data Binding Library</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Activity的生命周期</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/LifeCycleOfActivity/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/LifeCycleOfActivity/</url>
    
    <content type="html"><![CDATA[<h1 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Activity的生命周期主要由六个阶段组成：<br>|阶段|说明|<br>|—|—|<br>|<code>onCreate()</code>|Activity被创建，一般进行初始化操作：加载界面布局，初始化Activity所需的数据|<br>|<code>onStart()</code>|Activity正在启动，处于后台阶段，暂不可见|<br>|<code>onResume()</code>|Activity出现在前台并可见，可以进行交互|<br>|<code>onPause()</code>|Activity正在停止，可以做一些数据存储，停止动画的动作。不能执行耗时的工作|<br>|<code>onStop()</code>|Activity即将停止，可以做一些稍重量级的回收工作，但也不能太耗时|<br>|<code>onDestroy()</code>|Activity即将销毁，Activity的最后一个生命周期，可以进行回收工作和资源释放|</p><p>除此之外，还有一个生命周期用于恢复Activity：<br>|阶段|说明|<br>|—|—|<br>|<code>onRestart()</code>|当Activity的<code>onStop()</code>方法调用后处于不可见时，但没有被销毁(<code>onDestroy()</code>)。此时恢复Activity时则会调用<code>onRestart()</code>方法|</p><p>Activity生命周期图示：<br><img src="../../../imgs/activitylifecycle.png"></p><hr><h2 id="不同行为下的生命周期"><a href="#不同行为下的生命周期" class="headerlink" title="不同行为下的生命周期"></a>不同行为下的生命周期</h2><table><thead><tr><th>行为</th><th>生命周期顺序</th></tr></thead><tbody><tr><td>首次打开Actvity</td><td><code>onCreate</code> –&gt; <code>onStart</code> –&gt; <code>onResume</code></td></tr><tr><td>打开其他Activity或切回到桌面</td><td><code>onPause</code> –&gt; <code>onStop</code></td></tr><tr><td>再次回到原Activity</td><td><code>onRestart</code> –&gt; <code>onStart</code> –&gt; <code>onResume</code></td></tr><tr><td>通过back键退出</td><td><code>onPause</code> –&gt; <code>onStop</code> –&gt; <code>onDestroy</code></td></tr></tbody></table><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://book.douban.com/subject/26599538/">Android开发艺术探索</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>生命周期感知组件</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/LifecycleAwareComponents/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/LifecycleAwareComponents/</url>
    
    <content type="html"><![CDATA[<h1 id="生命周期感知组件"><a href="#生命周期感知组件" class="headerlink" title="生命周期感知组件"></a>生命周期感知组件</h1><p>[toc]</p><hr><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>通常情况下，对于生命周期有关的操作需要在对应的方法中进行实现，如<code>onCreate()</code>，<code>onStop()</code>等，这会导致这些方法代码冗长，难以维护。</p><p>通过<code>androidx.lifecycle</code>提供的类和接口，可以使用更加灵活的方式实现与组件生命周期有关的逻辑代码。</p><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a><code>Lifecycle</code></h3><p><code>Lifecycle</code>是一个类，其用来表示对应组件的生命周期状态信息。生命周期状态由两个部分组成：</p><ul><li>事件：生命周期中发生的事件。</li><li>状态：事件导致组件当前处于的状态。</li></ul><h3 id="LifecycleObserver和LifecycleOwner"><a href="#LifecycleObserver和LifecycleOwner" class="headerlink" title="LifecycleObserver和LifecycleOwner"></a><code>LifecycleObserver</code>和<code>LifecycleOwner</code></h3><p>与<code>Lifecycle</code>紧密相关的是两个类/接口：</p><ul><li><code>LifecycleOwner</code>：持有<code>Lifecycle</code>的接口，可以通过<code>getLifecycle()</code>方法获取<code>Lifecycle</code>实例。</li><li><code>LifecycleObserver</code>：对于特定组件生命周期<code>Lifecycle</code>进行监测的观察者。当生命周期发生改变时观察者可以感知到并作出相应的处理。</li></ul><p>注意：</p><ul><li>目前的<code>Fragment</code>和<code>AppCompatActivity</code>已经实现了<code>LifecycleOwner</code>接口。可以对这些类绑定监听器从而监听其生命周期。</li></ul><p>自定义生命周期监听器对特定Activity的生命周期进行监听：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 监听器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span></span>(<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> context: Context,<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycle: Lifecycle,<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> callback: () -&gt; <span class="hljs-built_in">Unit</span>) : LifecycleObserver &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> enabled = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// 当Activity触发事件onStart时该方法调用</span><br><span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// do something when the activity is on start</span><br>&#125;<br><br><span class="hljs-comment">// 当Activity触发事件onStop时该方法调用</span><br><span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// do something when the activity is on stop</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 被监测的Activity</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> myListener: MyListener<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        <span class="hljs-keyword">val</span> binding: ActivityMainBinding = DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.activity_main)<br><br>myListener = MyListener(<span class="hljs-keyword">this</span>, lifecycle) &#123;<br><span class="hljs-comment">// here is callback</span><br>&#125;<br><br><span class="hljs-comment">// 给当前的Lifecycle添加监听器</span><br>lifecycle.addObserver(myListener)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现自定义LifecycleOwner"><a href="#实现自定义LifecycleOwner" class="headerlink" title="实现自定义LifecycleOwner"></a>实现自定义<code>LifecycleOwner</code></h2><p>通过实现<code>LifecycleOwner</code>接口并且通过<code>LifecycleRegistry</code>类将事件转发到该类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span>: <span class="hljs-type">Activity</span></span>(), LifecycleOwner &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> lifecycleRegistry: LifecycleRegistry<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br><span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br><br>lifecycleRegistry = LifecycleRegistry(<span class="hljs-keyword">this</span>)<br>lifecycleRegistry.currentState = Lifecycle.State.CREATED<br>&#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">super</span>.onDestroy()<br><br>lifecycleRegistry.currentState = Lifecycle.State.DESTROYED<br>&#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLifecycle</span><span class="hljs-params">()</span></span>: Lifecycle  = lifecycleRegistry<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="生命周期感知组件的最佳实践"><a href="#生命周期感知组件的最佳实践" class="headerlink" title="生命周期感知组件的最佳实践"></a>生命周期感知组件的最佳实践</h2><ul><li>UI控制器(Activity和Fragment)代码尽可能简洁。使用<code>ViewModel</code>获取UI的数据，并通过观察<code>LiveData</code>来获取最新的数据。</li><li>UI控制器负责当数据改变时更新UI或将用户的操作反映到<code>ViewModel</code>中。</li><li><code>ViewModel</code>作为UI控制器和其他组件的连接器，数据的处理逻辑由<code>ViewModel</code>完成，而数据的获取由其他组件完成。</li><li>使用数据绑定使得View和UI控制器之间保持清晰的接口。减少在Activity和Fragment中编写UI更新的代码。</li><li><strong>避免在<code>ViewModel</code>中引用View或Activity的Context，因为<code>ViewModel</code>的生命周期比Activity更长，可能导致内存泄漏。</strong></li><li>使用kotlin的协程处理长时间任务或可以异步执行的任务。</li></ul><hr><h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a><code>LiveData</code></h2><p>Android KTX是Kotlin扩展集，用于提供对于Android Jetpack和其他Android库的支持。只要包括：</p><ul><li>扩展函数</li><li>扩展属性</li><li>lambda表达式</li><li>命名参数</li><li>参数默认值</li><li>协程</li></ul><p>添加依赖：</p><ul><li>在项目的<code>build.gradle</code>文件中添加<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">repositories &#123;<br>google()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>Android KTX被组织成若干个模块，根据需要的组件引入对应的依赖。<br>其中有一个核心模块用来提供通用的framework的API。<br>更多请参考：<a href="https://developer.android.com/kotlin/ktx">Android KTX</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">dependencies &#123;<br>// core KTX<br>implementation &quot;androidx.core:core-ktx:1.6.0&quot;<br><br>// 集合KTX<br>implementation &quot;androidx.collection:collection-ktx:&quot;<br><br>// LiveData KTX<br>implementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:2.4.0-rc01&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>LiveData</code>是一个可观察的数据类，其具有生命周期感知的能力，即只有对应的组件处于活跃状态(START或RESUME)时才更新数据。</p><h3 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h3><ol><li>在自定义的<code>ViewModel</code>类中创建<code>LiveData</code>实例持有特定的数据。</li><li>在UI控制器中(Activity或Fragment)创建<code>Observer</code>，重写<code>onChanged()</code>用以表示数据更改的响应逻辑。</li><li>调用<code>LiveData.observe()</code>方法将<code>Observer</code>与<code>LiveData</code>进行绑定。<code>observe()</code>方法接收两个参数，分别为<code>LifecycleOwner</code>和<code>Observer</code>。其中<code>LifecycleOwner</code>表示为<code>Lifecycle</code>的持有者，一般Activity和Fragment实现了该接口。</li></ol><p>一个简单的结合Databinding，<code>LiveData</code>和<code>ViewModel</code>的示例：</p><ul><li>在xml文件进行数据绑定，避免将大量UI更新操作放置在Activity中。</li><li>在<code>ViewModel</code>中的设置<code>LiveData</code>，对可观察的数据进行更新。</li></ul><ol><li>添加依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml">// build.gradle<br>android &#123;<br>    buildFeatures &#123;<br>        dataBinding true<br>    &#125;<br>&#125;<br><br>dependencies &#123;<br>    implementation &#x27;androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0-rc01&#x27;<br>    implementation &#x27;androidx.lifecycle:lifecycle-livedata-ktx:2.4.0-rc01&#x27;<br>    implementation &quot;androidx.fragment:fragment-ktx:1.3.6&quot;<br>    implementation &#x27;androidx.core:core-ktx:1.6.0&#x27;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>设置自定义的<code>ViewModel</code>，保存<code>LiveData</code><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyViewModel.kt</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyViewModel</span>: <span class="hljs-type">ViewModel</span></span>() &#123;<br><br>    <span class="hljs-keyword">val</span> nameLiveData: MutableLiveData&lt;String&gt; <span class="hljs-keyword">by</span> lazy &#123;<br>        MutableLiveData&lt;String&gt;()<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> countLiveData: MutableLiveData&lt;<span class="hljs-built_in">Int</span>&gt; <span class="hljs-keyword">by</span> lazy &#123;<br>        MutableLiveData&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onButtonClick</span><span class="hljs-params">()</span></span> &#123;<br>        nameLiveData.postValue(<span class="hljs-string">&quot;current time is <span class="hljs-subst">$&#123;SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd:hh-mm-ss&quot;</span>).format(Date())&#125;</span>&quot;</span>)<br>        countLiveData.postValue(Random().nextInt(<span class="hljs-number">100</span>))<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li>在布局文件中进行数据绑定<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--activity_4.xml--&gt;</span><br><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myviewmodel&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.xiaomi.lifecycleawarecomponenttest.viewmodels.MyViewModel&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123; (myviewmodel.countLiveData <span class="hljs-symbol">&amp;amp;</span> 1) == 0 ? myviewmodel.nameLiveData : `error`&#125;&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--数据绑定--&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;change randomly&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:onClick</span>=<span class="hljs-string">&quot;@&#123;() -&gt; myviewmodel.onButtonClick()&#125;&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--响应事件--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>在对应的Activity中进行数据绑定<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyActivity.kt</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span>: <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> myViewModel: MyViewModel <span class="hljs-keyword">by</span> viewModels()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> activity4Binding: Activity4Binding<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br><br>        activity4Binding = DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.activity_4)<br>        activity4Binding.myviewmodel = myViewModel<br><br>        activity4Binding.lifecycleOwner = <span class="hljs-keyword">this</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>注意：</p><ul><li>若<code>LiveData</code>的数据更新操作是在主线程中进行的，则必须调用<code>setValue(T)</code>更新<code>LiveData</code>。在工作线程中可以使用<code>postValue(T)</code>更新<code>LiveData</code>。</li><li><code>LiveData</code>可以用来实现不同生命周期组件之间的通信，如Activity和ViewModel。ViewModel主要用于管理UI相关的数据，<code>LiveData</code>非常适合放置在ViewModel中。</li><li>Activity和Fragment最好<strong>不要</strong>持有<code>LiveData</code>实例，因为这些UI控制器主要用于控制如何展示数据，而不是保存数据。</li><li>最好不要将<code>LiveData</code>放置在数据层，因为所有的<code>LiveData</code>对象是在主线程上进行观测的，任何耗时的操作可能阻塞主线程。可以使用Kotlin Flows并在ViewModel中使用<code>asLiveData()</code>方法将其转换为<code>LiveData</code>。</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.android.com/topic/libraries/architecture/lifecycle">Lifecycle-Aware Components</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MVVM架构在Android应用中的实现</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/MVVMinAndroid/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/MVVMinAndroid/</url>
    
    <content type="html"><![CDATA[<h1 id="MVVM架构在Android应用中的实现"><a href="#MVVM架构在Android应用中的实现" class="headerlink" title="MVVM架构在Android应用中的实现"></a>MVVM架构在Android应用中的实现</h1><p>[toc]</p><hr><h2 id="MVVM-架构简介"><a href="#MVVM-架构简介" class="headerlink" title="MVVM 架构简介"></a>MVVM 架构简介</h2><hr><h2 id="在Android应用中实现MVVM架构"><a href="#在Android应用中实现MVVM架构" class="headerlink" title="在Android应用中实现MVVM架构"></a>在Android应用中实现MVVM架构</h2><h3 id="分离关注点"><a href="#分离关注点" class="headerlink" title="分离关注点"></a>分离关注点</h3><ul><li>避免在<code>Activity</code>或<code>Fragment</code>编写所有代码。界面类应<strong>仅包含处理界面和交互的逻辑，避免与生命周期有关的问题</strong>。</li><li>Android系统可能随时销毁<code>Activity</code>和<code>Fragment</code>，减少对其依赖。</li></ul><h3 id="通过模型-model-驱动界面-view"><a href="#通过模型-model-驱动界面-view" class="headerlink" title="通过模型(model)驱动界面(view)"></a>通过模型(model)驱动界面(view)</h3><ul><li>模型负责处理应用<strong>数据</strong>的组件。</li><li>最好是通过（持久性）模型驱动界面，其独立于应用的<code>View</code>对象和组件，不受生命周期和关注点转移的影响。</li></ul><p>推荐的应用框架：<br><img src="../../../imgs/mvvm.png" alt="mvvm"></p><hr><h2 id="一步步构建简易的Android的MVVM框架应用"><a href="#一步步构建简易的Android的MVVM框架应用" class="headerlink" title="一步步构建简易的Android的MVVM框架应用"></a>一步步构建简易的Android的MVVM框架应用</h2><p>流程：</p><ol><li>构建实体层(Entity)以及对应的数据源，相当于<strong>Model</strong>。</li><li>构建<strong>ViewModel</strong>层。</li><li>构建<strong>View</strong>层。</li></ol><h3 id="构建Model层"><a href="#构建Model层" class="headerlink" title="构建Model层"></a>构建<strong>Model</strong>层</h3><ol><li><p>定义Entity为<code>User.class</code>，其中包含数据<code>id</code>，<code>age</code>和<code>name</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaomi.mvvm4android;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id, age;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>定义数据源（这里以SQLite数据库保存数据）</p></li></ol><p>首先定义抽象类，后续可能有多个实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Context context;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserRepository</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.context = context;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后定义具体的SQLite数据库实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SQLiteRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserRepository</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySQLiteHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SQLiteOpenHelper</span></span>&#123;<br>        <span class="hljs-keyword">private</span> Context context;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> version;<br>        <span class="hljs-keyword">private</span> String createDatabase = <span class="hljs-string">&quot;CREATE TABLE user (&quot;</span> +<br>                <span class="hljs-string">&quot;id integer PRIMARY KEY AUTOINCREMENT, &quot;</span> +<br>                <span class="hljs-string">&quot;age integer, &quot;</span> +<br>                <span class="hljs-string">&quot;name text)&quot;</span>;<br>        <span class="hljs-keyword">private</span> String addUser = <span class="hljs-string">&quot;INSERT INTO user (age, name) values(?, ?)&quot;</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MySQLiteHelper</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Context context, <span class="hljs-meta">@Nullable</span> String name, <span class="hljs-meta">@Nullable</span> SQLiteDatabase.CursorFactory factory, <span class="hljs-keyword">int</span> version)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(context, name, factory, version);<br>            <span class="hljs-keyword">this</span>.context = context;<br>            <span class="hljs-keyword">this</span>.name = name;<br>            <span class="hljs-keyword">this</span>.version = version;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(SQLiteDatabase db)</span> </span>&#123;<br>            db.execSQL(createDatabase);<br>            db.execSQL(addUser, <span class="hljs-keyword">new</span> String[] &#123;<span class="hljs-string">&quot;22&quot;</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>&#125;);<br>            db.execSQL(addUser, <span class="hljs-keyword">new</span> String[] &#123;<span class="hljs-string">&quot;23&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>&#125;);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpgrade</span><span class="hljs-params">(SQLiteDatabase db, <span class="hljs-keyword">int</span> oldVersion, <span class="hljs-keyword">int</span> newVersion)</span> </span>&#123;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> MySQLiteHelper mySQLiteHelper;<br><br>    <span class="hljs-keyword">private</span> String addUser = <span class="hljs-string">&quot;INSERT INTO user (age, name) values(?, ?)&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SQLiteRepository</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context);<br>        mySQLiteHelper = <span class="hljs-keyword">new</span> MySQLiteHelper(context, <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span> </span>&#123;<br>        Cursor cursor = mySQLiteHelper.getReadableDatabase().query(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>        List&lt;User&gt; userList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (cursor.moveToNext()) &#123;<br>            userList.add(<span class="hljs-keyword">new</span> User(cursor.getInt(cursor.getColumnIndex(<span class="hljs-string">&quot;id&quot;</span>)), cursor.getInt(cursor.getColumnIndex(<span class="hljs-string">&quot;age&quot;</span>)), cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;name&quot;</span>))));<br>        &#125;<br>        <span class="hljs-keyword">return</span> userList;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        mySQLiteHelper.getWritableDatabase().execSQL(addUser, <span class="hljs-keyword">new</span> String[]&#123;String.valueOf(user.getAge()), user.getName()&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>定义<strong>ViewModel</strong>层，实现主要的业务逻辑。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在ViewModel中不能持有任何View中的引用</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserListViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModel</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span>  MutableLiveData&lt;List&lt;User&gt;&gt; mUserListLiveData;<br>    <span class="hljs-keyword">private</span> UserRepository mUserRepository;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> initAge = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">private</span> String initName = <span class="hljs-string">&quot;nobody&quot;</span>;<br>    <span class="hljs-keyword">private</span> ScheduledExecutorService scheduledExecutorService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserListViewModel</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        mUserListLiveData = <span class="hljs-keyword">new</span> MutableLiveData&lt;&gt;();<br>        mUserRepository = <span class="hljs-keyword">new</span> SQLiteRepository(context);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LiveData <span class="hljs-title">getUserListLiveData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mUserListLiveData;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUserInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;User&gt; userList = mUserRepository.getUserList();<br>        mUserListLiveData.postValue(userList);<br>    &#125;<br><br><span class="hljs-comment">// 不重要，这里只是用于测试数据流从Model -&gt; ViewModel -&gt; View</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduledAddUser</span><span class="hljs-params">()</span> </span>&#123;<br>        scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();<br>        scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;<br>            mUserRepository.addUser(<span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, initAge++, initName + initAge));<br>            getUserInfo();<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br>````<br><br><span class="hljs-number">4.</span> 定义**View**层，添加一些UI和交互逻辑。<br>```java<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> UserListViewModel mUserListViewMode;<br>    <span class="hljs-keyword">private</span> Button btn_show_message, btn_autoget_message;<br>    <span class="hljs-keyword">private</span> TextView tv_get_message;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        mUserListViewMode = <span class="hljs-keyword">new</span> UserListViewModel(<span class="hljs-keyword">this</span>);<br><br>        initWidget();<br><br>        observeLiveData();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initWidget</span><span class="hljs-params">()</span> </span>&#123;<br>        btn_show_message = (Button) findViewById(R.id.btn_get_message);<br>        btn_autoget_message = (Button) findViewById(R.id.btn_autoget_message);<br>        tv_get_message = (TextView) findViewById(R.id.tv_show_message);<br>        btn_show_message.setOnClickListener(v -&gt; &#123;<br>            mUserListViewMode.getUserInfo();<br>        &#125;);<br>        btn_autoget_message.setOnClickListener(v -&gt; &#123;<br>            mUserListViewMode.scheduledAddUser();<br>        &#125;);<br>    &#125;<br><span class="hljs-comment">// 对数据设置观察，当数据发生变动时将自动到地主动获取数据更新UI</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">observeLiveData</span><span class="hljs-params">()</span> </span>&#123;<br>        mUserListViewMode.getUserListLiveData().observe(<span class="hljs-keyword">this</span>, v -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;<br>                List&lt;User&gt; list = (List&lt;User&gt;) v;<br>                StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>                <span class="hljs-keyword">for</span> (User u : list) sb.append(<span class="hljs-string">&quot;id : &quot;</span> + u.getId() +<span class="hljs-string">&quot;, age : &quot;</span> + u.getAge() + <span class="hljs-string">&quot;, name : &quot;</span> + u.getName() + <span class="hljs-string">&quot;\n&quot;</span>);<br>                tv_get_message.setText(sb.toString());<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>注释：</p><ol><li><strong>View</strong>层的<code>MainActivity</code>持有<strong>ViewModel</strong>的<code>UserListViewModel</code>的引用，而<code>UserListViewModel</code>不持有<code>MainActivity</code>的引用，减少<strong>View</strong>和<strong>ViewModel</strong>之间的依赖。</li><li><strong>ViewModel</strong>层的<strong>UserListViewModel</strong>持有<strong>Model</strong>层<strong>UserRepository</strong>的引用而反过来没有依赖关系。并且通过抽象类<strong>UserRepository</strong>保证可以在多个数据源之间自如切换。</li><li>数据的更新通过<code>LiveData</code>对<strong>View</strong>层设置的观察进行通知，避免<strong>ViewModel</strong>之间操作<strong>View</strong>层。</li></ol><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.android.com/jetpack/guide">应用架构指南</a></li><li><a href="https://juejin.cn/post/6921321173661777933">“终于懂了“系列：Jetpack AAC完整解析（四）MVVM - Android架构探索！</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>请求应用权限</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/RequestAppPermissions/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/RequestAppPermissions/</url>
    
    <content type="html"><![CDATA[<h1 id="请求应用权限"><a href="#请求应用权限" class="headerlink" title="请求应用权限"></a>请求应用权限</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>每个Android应用运行在一个权限受限的沙盒中，若一个应用需要额外的权限，则需要声明所需的权限。</li><li>当应用运行在API 23及以上时，对于一些关键权限需要在运行时请求对应的权限。对于API 22及以下，会自动授予对应的权限。</li></ul><hr><h2 id="请求权限的流程"><a href="#请求权限的流程" class="headerlink" title="请求权限的流程"></a>请求权限的流程</h2><ol><li>在应用的<code>AndroidManifest.xml</code>文件中声明所需的权限。</li><li>等待用户使用需要特定权限的功能，此时请求所需的运行时权限。</li><li>对于需要特定权限的功能，每次使用前都需要检查是否被授权。</li><li>请求运行时权限。</li><li>检查用户是否授予权限。</li><li>若用户授予权限，则可以请求访问数据；否则可以关闭部分功能。</li></ol><p>整个请求权限的流程如图：<br><img src="../../../imgs/request_permission_workflow.png"></p><p><strong>各步骤细节如下</strong>(以访问位置权限为例):</p><h3 id="确定应用是否已经授权特定权限"><a href="#确定应用是否已经授权特定权限" class="headerlink" title="确定应用是否已经授权特定权限"></a>确定应用是否已经授权特定权限</h3><p>代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> isGranted = ContextCompat.checkSelfPermission(context, android.Manifest.permission.ACCESS_FINE_LOCATION)<br><br><span class="hljs-comment">// 如果 isGranted == PackageManager.PERMISSION_GRANTED，则已经被授权</span><br><span class="hljs-comment">// 如果 isGranted == PackageManager.PERMISSION_DENIED，则没有被授权</span><br></code></pre></td></tr></table></figure><h3 id="解释需要特定权限的原因"><a href="#解释需要特定权限的原因" class="headerlink" title="解释需要特定权限的原因"></a>解释需要特定权限的原因</h3><p>如果权限检查结果为<code>PackageManager.PERMISSION_DENIED</code>，则意味着申请权限被拒，应该首次被拒应该给出需要权限的原因并再次申请权限。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// shouldShowRequestPermissionRationale()的结果为true表示首次拒绝请求权限，可以再次请求权限</span><br><span class="hljs-keyword">if</span> (shouldShowRequestPermissionRationale(android.Manifest.permission.ACCESS_FINE_LOCATION)) &#123;<br><span class="hljs-comment">// show why application needs special permission and requests permission again</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="请求权限"><a href="#请求权限" class="headerlink" title="请求权限"></a>请求权限</h3><p>在请求权限时，有两种方式管理请求码(request code):</p><ul><li>在请求权限回调逻辑中自行处理。</li><li>使用系统提供的<code>RequestPermission</code>由系统管理权限请求码。</li></ul><h4 id="由系统管理请求码"><a href="#由系统管理请求码" class="headerlink" title="由系统管理请求码"></a>由系统管理请求码</h4><ol><li>自定义<code>ActvitiyResultCallback</code>的实现，用于对请求权限后对结果进行处理。</li><li>为特定结果进行注册，使用方法<code>registerResultCallback()</code>获得<code>ActivityResultLauncher</code>对象。该方法需要传入两个参数：<code>ActivityResultContract</code>对象和<code>ActivityResultCallback</code>对象，其中<code>ActivityResultCallback</code>为上面自定义的结果处理回调函数，而<code>ActivityResultContract</code>为一个Activity转换器，可以将一个类型转换为另外一个类型。一般使用工具类中已经定义好的转换器<code>ActivityResultContracts</code>。</li><li>使用<code>ActivityResultLauncher</code>对象的<code>launch()</code>方法，参数为需要申请的权限，来发起权限申请。</li><li>获得权限申请结果后，系统或异步调用传入的结果回调函数<code>ActivityResultCallback</code>。</li></ol><p>流程图示：<br><img src="../../../imgs/RegisterResultCallback.png"></p><h3 id="自行管理权限请求码"><a href="#自行管理权限请求码" class="headerlink" title="自行管理权限请求码"></a>自行管理权限请求码</h3><p>通过<code>requestPermissions()</code>方法可以自行管理权限请求码，具体实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 自定义权限请求码</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SELF_DEFINED_REQUEST_CODE = <span class="hljs-number">100</span><br><span class="hljs-comment">// 请求权限</span><br>ActivityCompat.requestPermissions(activity, arrayOf(android.Manifest.permission.ACCESS_FINE_LOCATION), SELF_DEFINED_REQUEST_CODE))<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>当系统获得请求结果后，会调用<code>activity</code>中的<code>onRequestPermissionResult()</code>来处理获得的结果。在该方法中可以自定义获得权限结果后的处理逻辑。示例代码如下：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onRequestPermissionsResult</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">requestCode: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">permissions: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">String</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">grantResults: <span class="hljs-type">IntArray</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br><span class="hljs-keyword">when</span> (requestCode) &#123;<br>    SELF_DEFINED_REQUEST_CODE -&gt; &#123;<br><span class="hljs-keyword">if</span> (grantResults.isNotEmpty() &amp;&amp;<br>grantedResult[<span class="hljs-number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;<br><span class="hljs-comment">// permission is granted</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// permission is denied </span><br>&#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> -&gt; &#123;<br><span class="hljs-comment">// request other permissions</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="应对申请权限被拒"><a href="#应对申请权限被拒" class="headerlink" title="应对申请权限被拒"></a>应对申请权限被拒</h2><p>最佳实践：</p><ul><li>告知缺失权限将导致哪些功能无法继续使用。</li><li>避免阻止用户继续使用应用中的其他功能。</li></ul><blockquote><p>在API 30及以后，当用户多次拒绝特定权限的申请时，后续的权限申请将不在显示。</p></blockquote><hr><h2 id="一次权限"><a href="#一次权限" class="headerlink" title="一次权限"></a>一次权限</h2><p>在API 30及以后，当应用申请<strong>位置</strong>，<strong>麦克风</strong>，<strong>相机</strong>等权限时，弹出的权限对话框中包含“仅限本次”选项。当用户选择该选项时，则应用会被授权临时的一次权限。</p><p>一次权限在以下情况下有效：</p><ul><li>当应用的Activity可见。</li><li>当应用进入后台时，应用将可以在短期内具有权限。</li><li>当应用启动一个前台服务，然后用户将应用放置后台，则应用可以访问前台服务知道其结束。</li><li>如果用户取消一次权限（通过系统设置），应用将无法访问权限，直到下次获取权限。</li></ul><hr><h2 id="不常用应用的权限撤销"><a href="#不常用应用的权限撤销" class="headerlink" title="不常用应用的权限撤销"></a>不常用应用的权限撤销</h2><ul><li>在API 30及以后，当应用长时间没被使用，系统将撤销该应用被赋予的一些敏感权限。</li><li>系统只会撤销运行时权限。</li><li>通过方法<code>isAutoRevokeWhitelisted()</code>方法可以检查特定权限是否会被自动撤销。若返回值为<code>true</code>，则该权限不会被撤销。</li></ul><hr><h2 id="请求权限示例"><a href="#请求权限示例" class="headerlink" title="请求权限示例"></a>请求权限示例</h2><h3 id="传统的申请权限的方法"><a href="#传统的申请权限的方法" class="headerlink" title="传统的申请权限的方法"></a>传统的申请权限的方法</h3><p>代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>(), ActivityCompat.OnRequestPermissionsResultCallback &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> REQUEST_LOCATION_ACCESS_CODE = <span class="hljs-number">100</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> REQUEST_SETTINGS_CODE = <span class="hljs-number">101</span><br>    &#125;<br><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> btnLocationAccess : Button<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        btnLocationAccess = findViewById(R.id.btn_location_access)<br>        btnLocationAccess.setOnClickListener &#123;requestForegroundLocationAccessPermission(baseContext)&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestForegroundLocationAccessPermission</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">if</span> (!checkGrantedLocationPermission(context)) &#123;<br>            ActivityCompat.requestPermissions(<span class="hljs-keyword">this</span>, arrayOf(android.Manifest.permission.ACCESS_FINE_LOCATION), REQUEST_LOCATION_ACCESS_CODE)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            successGetLocationAccessPermission(baseContext)<br>        &#125;<br>        <span class="hljs-keyword">return</span> checkGrantedLocationPermission(context)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkGrantedLocationPermission</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span>: <span class="hljs-built_in">Boolean</span> =<br>        ContextCompat.checkSelfPermission(context, android.Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">successGetLocationAccessPermission</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> &#123;Toast.makeText(context, <span class="hljs-string">&quot;success get location access permission&quot;</span>, Toast.LENGTH_SHORT).show()&#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onRequestPermissionsResult</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        requestCode: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        permissions: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">String</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">        grantResults: <span class="hljs-type">IntArray</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        <span class="hljs-keyword">when</span> (requestCode) &#123;<br>            REQUEST_LOCATION_ACCESS_CODE -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (grantResults.size == <span class="hljs-number">1</span> &amp;&amp; grantResults[<span class="hljs-number">0</span>] == PackageManager.PERMISSION_GRANTED) successGetLocationAccessPermission(<span class="hljs-keyword">this</span>.baseContext)<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (shouldShowRequestPermissionRationale(android.Manifest.permission.ACCESS_FINE_LOCATION)) &#123;<br>                        showPermissionRationale(btnLocationAccess, <span class="hljs-string">&quot;需要位置权限&quot;</span>)<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        Snackbar.make(btnLocationAccess, <span class="hljs-string">&quot;需要打开位置权限，可以通过设置 --&gt; 应用设置权限&quot;</span>, Snackbar.LENGTH_INDEFINITE)<br>                            .setAction(<span class="hljs-string">&quot;确定&quot;</span>) &#123;<br>                                <span class="hljs-keyword">val</span> intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)<br>                                intent.<span class="hljs-keyword">data</span> = Uri.parse(<span class="hljs-string">&quot;package:<span class="hljs-variable">$packageName</span>&quot;</span>)<br>                                startActivityForResult(intent, REQUEST_SETTINGS_CODE)<br>                            &#125;<br>                            .show()<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showPermissionRationale</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, s: <span class="hljs-type">String</span>)</span></span> &#123;<br>        Snackbar.make(view, s, Snackbar.LENGTH_INDEFINITE)<br>            .setAction(<span class="hljs-string">&quot;确定&quot;</span>) &#123;requestForegroundLocationAccessPermission(baseContext)&#125;<br>            .setDuration(<span class="hljs-number">3000</span>)<br>            .show()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用registerForActivityResult-API申请单个权限"><a href="#使用registerForActivityResult-API申请单个权限" class="headerlink" title="使用registerForActivityResult API申请单个权限"></a>使用<code>registerForActivityResult</code> API申请单个权限</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义ActivityResultLauncher</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> activityResultLauncher = registerForActivityResult(ActivityResultContracts.RequestPermission()) &#123;<br>    isGranted -&gt;<br><span class="hljs-keyword">when</span> &#123;<br>    isGranted -&gt; &#123;<br><span class="hljs-comment">// got permission</span><br>&#125;<br>    <span class="hljs-keyword">else</span> -&gt; &#123;<br><span class="hljs-comment">// permission denied</span><br>    &#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 使用launch方法申请权限</span><br>activityResultLauncher.launch(android.Manifest.permission.ACCESS_FINE_LOCATION)<br></code></pre></td></tr></table></figure><h3 id="申请多个权限"><a href="#申请多个权限" class="headerlink" title="申请多个权限"></a>申请多个权限</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义ActivityResultLauncher</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> multiPermissionLauncher = registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) &#123;<br>permissions -&gt;<br>permissions.entries.forEach &#123;<br><span class="hljs-keyword">val</span> permissionName = it.key<br><span class="hljs-keyword">val</span> isGranted = it.value<br><span class="hljs-keyword">when</span> &#123;<br>isGranted -&gt; &#123;<br><span class="hljs-comment">// you get permission</span><br>&#125; <br><span class="hljs-keyword">else</span> -&gt; &#123;<br><span class="hljs-comment">// you do not get permission</span><br>&#125; <br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 使用launch方法申请多个多个权限</span><br><span class="hljs-keyword">var</span> permissionArray = arrayOf(android.Manifest.permission.ACCESS_FINE_LOCATION, android.Manifest.permission.READ_EXTERNAL_STORAGE)<br>multiPermissionLauncher.launch(permissionArray)<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.android.com/training/permissions/requesting">Request app permissions</a></li><li><a href="https://juejin.cn/post/6844903717670486030">在Android上优雅的申请权限</a></li><li><a href="https://medium.com/codex/android-runtime-permissions-using-registerforactivityresult-68c4eb3c0b61">Android Runtime Permissions using registerForActivityResult</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SEAndroid（Android中的安全增强型Linux）</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/SEAndroid/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/SEAndroid/</url>
    
    <content type="html"><![CDATA[<h1 id="SEAndroid（Android中的安全增强型Linux）"><a href="#SEAndroid（Android中的安全增强型Linux）" class="headerlink" title="SEAndroid（Android中的安全增强型Linux）"></a>SEAndroid（Android中的安全增强型Linux）</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Android中使用SELinux对所有进程强制执行强制访问控制(MAC)。<br>SELinux有两种全局模式：</p><ul><li>宽容模式：权限拒绝事件会被记录下来，但不会强制执行。</li><li>强制模式：权限拒绝事件会被记录下来并强制执行。所有违规行为会被记录到<code>dmesg</code>和<code>logcat</code>中。</li></ul><h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><h3 id="强制访问控制-MAC"><a href="#强制访问控制-MAC" class="headerlink" title="强制访问控制(MAC)"></a>强制访问控制(MAC)</h3><ul><li>SELinux是一种适用于Linux系统的<strong>MAC系统</strong>。</li><li>SELinux作为Linux安全模块(LSM)的一部分实现，用于识别<strong>内核对象对对象执行敏感操作,通过政策决定是否允许相应的访问</strong>。</li></ul><h3 id="标签、规则和域"><a href="#标签、规则和域" class="headerlink" title="标签、规则和域"></a>标签、规则和域</h3><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://source.android.com/security/selinux?hl=zh-cn">Android 中的安全增强型 Linux</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>定时重复任务</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/ScheduleRepeatingAlarms/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/ScheduleRepeatingAlarms/</url>
    
    <content type="html"><![CDATA[<h1 id="定时重复任务"><a href="#定时重复任务" class="headerlink" title="定时重复任务"></a>定时重复任务</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>闹钟(<code>AlarmManager</code>)提供一种在应用生命周期之外执行基于时间的操作。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>增加一个随机时间间隔，避免不同设备的任务同时启动对服务器的请求造成服务器负担增大。</li><li>减少闹钟的频率。</li><li>非必要不唤醒设备。</li><li>非必要不要要求过高的时间精度(使用<code>setInexactRepeating()</code>而非<code>setRepeating()</code>)(注：<strong>API 19后所有的重复性闹钟都是不精确的</strong>)</li><li>避免闹钟基于<strong>real time clock</strong>，推荐使用<strong>elapsed real time</strong>。</li></ul><hr><h2 id="设置定时闹钟"><a href="#设置定时闹钟" class="headerlink" title="设置定时闹钟"></a>设置定时闹钟</h2><p>一个定时闹钟具有以下特征：</p><ul><li>一种闹钟类型</li><li>一个触发时间（如果触发时间已经过去，则立即触发）</li><li>闹钟间隔</li><li>一个<code>PendingIntent</code>，若在同一个<code>PendingIntent</code>中设置新的闹钟，则这将取代原有的闹钟。</li></ul><h3 id="选择闹钟类型"><a href="#选择闹钟类型" class="headerlink" title="选择闹钟类型"></a>选择闹钟类型</h3><p>目前有两种闹钟类型：</p><ul><li><strong>elapsed real time</strong>：使用自系统启动的时间作为参考。适合于时间段的闹钟（如：每1小时触发一次），不受到时区/当前时区的影响。</li><li>**real time clock(RTC)**：使用UTC时间作为参考。适合于依赖于当前时区的闹钟任务。</li></ul><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>ELAPSED_REALTIME</code></td><td>基于设备启动后的时间间隔触发特定的<code>PendingIntent</code>，不唤醒设备。时间间隔统计设备睡眠时间</td></tr><tr><td><code>ELAPSED_REALTIME_WAKEUP</code></td><td>基于设备启动后的时间间隔唤醒设备并触发闹钟</td></tr><tr><td><code>RTC</code></td><td>特定时间触发<code>PendingIntent</code>，不唤醒时间</td></tr><tr><td><code>RTC_WAKEUP</code></td><td>特定时间唤醒设备并<code>PendingIntent</code></td></tr></tbody></table><p>注意：</p><ul><li>两种闹钟都有”唤醒”版本，这将确保在指定周期内出发闹钟。即使屏幕关闭也能唤醒设备的CPU。若不使用唤醒版本，则所有的重复闹钟将在设备下次唤醒时触发闹钟。</li><li>若需要特定时间的闹钟任务，可以使用<strong>real time clock</strong>，但是该类型在用户更改设备时间设置时可能无法正常工作。</li></ul><blockquote><p><strong>elapsed real time</strong>代码示例</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br></code></pre></td></tr></table></figure><blockquote><p><strong>real time clock</strong>代码示例</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br></code></pre></td></tr></table></figure><h3 id="确定所需的时间精度"><a href="#确定所需的时间精度" class="headerlink" title="确定所需的时间精度"></a>确定所需的时间精度</h3><p>在<code>setInexactRepeating()</code>中无法指定精确的时间，可以使用<code>AlarmManager</code>提供的时间间隔常量设定定时任务的时间周期。</p><hr><h2 id="取消一个闹钟"><a href="#取消一个闹钟" class="headerlink" title="取消一个闹钟"></a>取消一个闹钟</h2><p>若要取消一个闹钟，可以使用<code>AlarmManger</code>的<code>cancel()</code>方法，将待取消的<code>PendingIntent</code>传入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">alarmMgr?.cancel(alarmIntent)<br></code></pre></td></tr></table></figure><hr><h2 id="设备重启后设置闹钟"><a href="#设备重启后设置闹钟" class="headerlink" title="设备重启后设置闹钟"></a>设备重启后设置闹钟</h2><p>默认情况下，当设备关闭后，所有的闹钟将被取消。可以通过如下方式在用户重启机器后重新开始一个重复任务。</p><p>流程：</p><ol><li>在<code>AndroidManifest.xml</code>中设置开机启动权限：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li>创建一个自定义的<code>BroadcastReceiver</code>接收开机广播：</li></ol><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.android.com/training/scheduling/alarms">Schedule repeating alarms</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WorkManager学习小结</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/WorkManager/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/WorkManager/</url>
    
    <content type="html"><![CDATA[<h1 id="WorkManager学习小结"><a href="#WorkManager学习小结" class="headerlink" title="WorkManager学习小结"></a>WorkManager学习小结</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>WorkManager</code>API提供一种简单的方式在应用退出或设备重启仍然可靠地执行异步任务。</p><p>特点：</p><ul><li>只在指定的情况下才启动任务。</li><li>鲁棒性：<code>WorkManager</code>允许你执行一次或重复性任务。任务可以进行标记从而同时监视或取消一组任务。周期性任务存储在内部管理的SQLite数据库中，由<code>WorkManager</code>管理以确保这些任务在设备重启仍然有效。</li><li>灵活的重试机制：<code>WorkManager</code>提供灵活的重试机制。</li><li>任务链：<code>WorkManager</code>提供接口可以将多个独立的任务链接起来，可以控制任务是顺序执行或并行执行，可以定义每个任务的输入输出数据类型，从而可以将一个任务的输出结果自动的传入到下一个任务的输入。</li><li>线程互操作性：集成<code>RxJava</code>和协程，可以灵活地插入到异步API中。</li></ul><hr><h2 id="一个简单的WorkManager示例"><a href="#一个简单的WorkManager示例" class="headerlink" title="一个简单的WorkManager示例"></a>一个简单的<code>WorkManager</code>示例</h2><ol><li>添加依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">dependencies &#123;<br>    def work_version = &#x27;2.6.0&#x27;<br>    implementation &#x27;androidx.core:core-ktx:1.6.0&#x27;<br>    implementation &#x27;androidx.appcompat:appcompat:1.3.1&#x27;<br>    implementation &#x27;com.google.android.material:material:1.4.0&#x27;<br>    implementation &#x27;androidx.constraintlayout:constraintlayout:2.1.0&#x27;<br>    implementation &quot;androidx.work:work-runtime-ktx:$work_version&quot;<br>    implementation &quot;androidx.work:work-multiprocess:$work_version&quot;<br>    testImplementation &#x27;junit:junit:4.+&#x27;<br>    androidTestImplementation &#x27;androidx.test.ext:junit:1.1.3&#x27;<br>    androidTestImplementation &#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>定义一个自定义的任务，继承自<code>Worker</code>：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWorker</span></span>(appContext: Context, workerParams: WorkerParameters) : Worker(appContext, workerParams) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span></span>: Result &#123;<br>        myTask(applicationContext)<br>        <span class="hljs-keyword">return</span> Result.success()<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">myTask</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>?)</span></span> &#123;<br><span class="hljs-comment">// do something here</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>创建一个工作请求（设置任务类型：一次任务/重复任务）<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 一次任务</span><br><span class="hljs-keyword">val</span> notificationRequest : WorkRequest = OneTimeWorkRequestBuilder&lt;MyNotificationWork&gt;()<br>            .build()<br></code></pre></td></tr></table></figure></li><li>将任务提交给系统进行处理<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">WorkManager.getInstance(applicationContext)<br>            .enqueue(notificationRequest)<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="定制个性化的任务"><a href="#定制个性化的任务" class="headerlink" title="定制个性化的任务"></a>定制个性化的任务</h2><ul><li>自定义的任务包装成<code>WorkRequest</code>类交由<code>WorkManager</code>进行处理。</li><li><code>WorkRequest</code>中可以设定任务执行的限制条件、执行任务的信息如延迟或重复间隔、重试机制以及需要的输入数据。</li><li><code>WorkRequest</code>是一个抽象类，提供两个实现类<code>OneTimeWorkRequest</code>用于一次性的非重复任务，而<code>PeriodicWorkRequest</code>用于周期性任务。</li></ul><h3 id="一次性任务"><a href="#一次性任务" class="headerlink" title="一次性任务"></a>一次性任务</h3><p>一个简单的没有额外配置的一次性任务可以通过如下方式实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> oneTimeWork = OneTimeWorkRequest.from(MyWork::<span class="hljs-keyword">class</span>.java)<br></code></pre></td></tr></table></figure><p>若需要额外的配置信息，可以通过构造器构建：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> oneTimeWork: WorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()<br><span class="hljs-comment">// additional configuration</span><br>.build()<br></code></pre></td></tr></table></figure><h3 id="周期性任务"><a href="#周期性任务" class="headerlink" title="周期性任务"></a>周期性任务</h3><p>代码示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> periodicWork = PeriodicWorkRequestBuilder&lt;MyWork&gt;(<span class="hljs-number">1</span>, TimeUnit.HOURS)<br><span class="hljs-comment">// additional configuration</span><br>.build()<br></code></pre></td></tr></table></figure><p>注意：最小的重复任务的时间间隔是15分钟。</p><h4 id="弹性运行时间"><a href="#弹性运行时间" class="headerlink" title="弹性运行时间"></a>弹性运行时间</h4><p>可以在每个时间间隔中设置弹性周期间隔，对应的任务可以在指定的弹性周期中运行。弹性周期开始于(repeatInterval - flexInterval)，结束于时间间隔结束。<br><img src="../../../imgs/flex_period.png"></p><p>代码示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> myWork = PeriodicWorkRequestBuilder&lt;MyWork&gt;(<span class="hljs-number">1</span>, TimeUnit.HOURS, <span class="hljs-number">15</span>, TimeUnit.MINUTES)<br>.build()<br></code></pre></td></tr></table></figure><h4 id="条件约束"><a href="#条件约束" class="headerlink" title="条件约束"></a>条件约束</h4><p>可以对一个任务添加约束条件，这样即使指定的时间点到达时，任务也不会执行，除非指定的任务都满足。这可能导致任务延迟执行，或者被直接跳过。</p><hr><h3 id="任务约束"><a href="#任务约束" class="headerlink" title="任务约束"></a>任务约束</h3><p>主要有以下几种约束条件：<br>|类型|约束条件|<br>|NetworkType|WiFi等网络相关的约束|<br>|BatteryNotLow|低电量不执行|<br>|RequiresCharging|只有充电才运行|<br>|DeviceIdle|设备处于空闲状态才执行，适用于批处理|<br>|StorageNotLow|存储不足不执行|</p><p>可以通过<code>Constraints.Builder()</code>构建一个<code>Constraints</code>实例用于表示任务约束，并将其分配给<code>WorkRequest</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> constraints = Constraints.Builder()<br>.setRequiredNetworkType(NetworkType.UNMETERED)<br>.setRequiresCharging(<span class="hljs-literal">true</span>)<br>.build()<br><br><span class="hljs-keyword">val</span> myWork: WorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()<br>.setConstraints(constraints)<br>.build()<br></code></pre></td></tr></table></figure><hr><h3 id="延迟任务"><a href="#延迟任务" class="headerlink" title="延迟任务"></a>延迟任务</h3><p>若需要对任务设置一个执行延迟时间，可以指定任务初次执行时的时延。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> myWork = OneTimeWorkRequestBuilder&lt;MyWork&gt;()<br>.setInitialDelay(<span class="hljs-number">10</span>, TimeUnit.MINUTES)<br>.build()<br></code></pre></td></tr></table></figure><p>注意：对于周期任务，只有初次执行任务会被延迟，后续任务将按指定时间执行。</p><hr><h3 id="重试和放弃策略"><a href="#重试和放弃策略" class="headerlink" title="重试和放弃策略"></a>重试和放弃策略</h3><p>可以通过在<code>doWork()</code>中返回<code>Result.retry()</code>使得任务重新执行。对应的任务将根据对应的策略进行重新执行:</p><ul><li><em>Backoff delay</em>：设定重新执行任务的最小时延。</li><li><em>Backoff policy</em>：设定连续的重试任务之间时延的增长规律，目前有两种：<code>LINEAR</code>和<code>EXPONENTIAL</code>。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> myWork = OneTimeWorkRequestBuilder&lt;MyWork&gt;()<br>.setBackOffCriteria(<br>BackOffPolicy.LINEAR,<br>OneTimeWorkRequest.MIN_BACKOFF_MILLS,<br>TimeUnit.MILLISECONDS)<br>.build()<br></code></pre></td></tr></table></figure><p>注意：<code>LINEAR</code>是按照10, 20, 30, …的规律增加重试任务时延，而<code>EXPONENTIAL</code>是按照20, 40, 80, …的规律增加时延。</p><hr><h3 id="标记任务"><a href="#标记任务" class="headerlink" title="标记任务"></a>标记任务</h3><p>通过对任务添加标记，可以对于相同标记的进行操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 给任务添加标签</span><br><span class="hljs-keyword">val</span> myWork = OneTimeWorkRequestBuilder&lt;MyWor&gt;()<br>.addTag(<span class="hljs-string">&quot;work1&quot;</span>)<br>.build()<br><br><span class="hljs-comment">// 获取指定任务的所有标记</span><br><span class="hljs-keyword">val</span> tags = myWork.tags<br><br><span class="hljs-comment">// 取消指定标签的任务</span><br>WorkManager.getInstance(applicationContext).cancelAllWorkByTag(<span class="hljs-string">&quot;work1&quot;</span>)<br><br><span class="hljs-comment">// 获取指定标记的任务信息</span><br><span class="hljs-keyword">val</span> workInfo = WorkManager.getInstance(applicationContext).getWorkInfoByTag(<span class="hljs-string">&quot;work1&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="分配输入数据"><a href="#分配输入数据" class="headerlink" title="分配输入数据"></a>分配输入数据</h3><p>对于一些任务执行需要输入数据，可以将数据以键值对的形式保存到<code>Data</code>对象中，在<code>WorkManager</code>中传入输入数据，而通过<code>Worker.getInputData()</code>方法获取输入数据。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 添加输入数据</span><br><span class="hljs-keyword">val</span> myWork = OneTimeRequestBuilder&lt;MyWork&gt;()<br>.setInputData(workDataOf(<br><span class="hljs-string">&quot;key1&quot;</span> to <span class="hljs-string">&quot;value1&quot;</span>,<br><span class="hljs-string">&quot;key2&quot;</span> to <span class="hljs-string">&quot;value2&quot;</span>))<br>.build()<br><br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span></span>: Result &#123;<br><span class="hljs-keyword">val</span> res = inputData.getString(<span class="hljs-string">&quot;key1&quot;</span>) ?: <span class="hljs-keyword">return</span> Result.failure()<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h2 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h2><h3 id="一次任务状态"><a href="#一次任务状态" class="headerlink" title="一次任务状态"></a>一次任务状态</h3><p>一次任务主要有五种状态：<br><img src="../../../imgs/one_time_work_state.png"></p><ul><li>任务刚开始进入任务队列，处于<code>ENQUEUED</code>状态。</li><li>当约束条件满足并且到达指定时间时，任务被调度执行，处于<code>RUNNING</code>状态。</li><li>根据任务执行的结果，可以为不同的状态：执行成功的<code>SUCCEEDED</code>，执行失败的<code>FAILED</code>。</li><li>重试的任务重新进入<code>ENQUEUED</code>状态。</li><li>处于<code>ENQUEUED</code>或<code>RUNNING</code>状态的任务可以被取消<code>cancel()</code>，处于<code>CANCELLED</code>状态。</li></ul><p>结束状态：<code>SUCCEEDED</code>,<code>FAILED</code>和<code>CANCELLED</code>。通过<code>WorkInfo.State.isFinished()</code>检查任务是否处于结束状态，返回值为true即为结束状态。</p><hr><h3 id="周期性任务-1"><a href="#周期性任务-1" class="headerlink" title="周期性任务"></a>周期性任务</h3><p>周期性任务只有一种终止状态：<code>CANCELLED</code>。整体的执行流程如下：<br><img src="../../../imgs/peridoc_task_state.png"></p><hr><h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><p>一旦确定了<code>Worker</code>和<code>WorkRequest</code>，最后一步是将任务进入到任务队列中。<br>最简单的方法是调用<code>WorkManager</code>的<code>enqueue()</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> myWork: WorkRequest = <span class="hljs-comment">//</span><br>WorkManager.getInstance(context).enqueue(myWork)<br></code></pre></td></tr></table></figure><p>为了避免相同任务重复执行，可以将任务设为唯一任务。</p><h3 id="唯一任务"><a href="#唯一任务" class="headerlink" title="唯一任务"></a>唯一任务</h3><p>唯一任务用于保证对于特定名称一次只有一个任务实例。<br>唯一的命名只能分配给一个任务实例，而相同的标签可以分配给多个任务实例。</p><p>针对不同类型的任务，使用不同的方法创建唯一任务序列：</p><ul><li>一次任务：<code>WorkManager.enqueueUniqueWork()</code></li><li>重复任务：<code>WorkManager.enqueueUniquePeriodicWork()</code></li></ul><p>需要三个参数进行配置：</p><ul><li>`uniqueWorkName: 唯一任务的命名，唯一标识不同的任务。</li><li><code>existingWorkPolicy</code>: 对于出现重复任务时的处理策略。</li><li><code>work</code>: 待执行的任务<code>WorkRequest</code>。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> myWorkRequest = PeriodicWorkRequestBuilder&lt;MyWork&gt;(<span class="hljs-number">10</span>, TimeUnit.MINUTES).build()<br><br>WorkManager.getInstance(context).enqueueUniquePeriodicWork(<br><span class="hljs-string">&quot;work1&quot;</span>,<br>ExistingPeriodicWorkPolicy.KEEP,<br>myWorkRequest)<br></code></pre></td></tr></table></figure><h4 id="冲突解决政策"><a href="#冲突解决政策" class="headerlink" title="冲突解决政策"></a>冲突解决政策</h4><p>对于一个唯一任务，若发生多个重复任务时，会使用<code>ExistingWorkPolicy</code>来决定如何处理：</p><ul><li><code>REPLACE</code>：使用新的任务取代已有的任务。</li><li><code>KEEP</code>：保留已有的任务而放弃新的任务。</li><li><code>APPEND</code>：将新的任务链接到已有任务之后，这将导致已有任务完成之后执行新的任务。</li></ul><p>注意：</p><ul><li><code>APPEND</code>取决于前一个任务的状态，若为<code>CANCELLED</code>或<code>FAILED</code>，则新任务将被取消或失败。若想分离两个任务之间的关联，可以使用<code>APPEND_OR_REPLCAE</code>。</li><li>对于重复任务，支持两种政策：<code>REPLACE</code>和<code>KEEP</code>。</li></ul><h3 id="监测任务状态"><a href="#监测任务状态" class="headerlink" title="监测任务状态"></a>监测任务状态</h3><p>可以通过<code>name</code>，<code>id</code>或<code>tag</code>检查队列中的任务状态：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> workManager = WorkManager.getInstance(applicationContext)<br><br><span class="hljs-comment">// by id</span><br>workManager.getWorkInfoById(myWork.id)<br><br><span class="hljs-comment">// by name</span><br>workManager.getWorkInfosForUniqueWork(<span class="hljs-string">&quot;work1&quot;</span>)<br><br><span class="hljs-comment">// by tag</span><br>workManager.getWorkInfosByTag(<span class="hljs-string">&quot;tag1&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意：返回的结果为<code>ListenableFuture&lt;List&lt;WorkInfo&gt;&gt;</code>对象，其中取出<code>List&lt;WorkInfo&gt;</code>，而每个<code>WorkInfo</code>中包含着该任务的<code>id</code>，<code>tag</code>等信息：</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> listenableFuture = workManager.getWorkInfosByTag(<span class="hljs-string">&quot;tag1&quot;</span>)<br><span class="hljs-keyword">val</span> workInfoList = listenableFuture.<span class="hljs-keyword">get</span>()<br><span class="hljs-keyword">for</span> (work <span class="hljs-keyword">in</span> workInfoList) &#123;<br><span class="hljs-keyword">val</span> id = work.id<br><span class="hljs-keyword">val</span> tag = work.tag<br><span class="hljs-keyword">val</span> outputData = work.outputData<br><span class="hljs-keyword">val</span> currentState = work.state <span class="hljs-comment">// 当前任务的状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p>若想要对<code>WorkInfo</code>进行监听，可以利用<code>LiveData</code>对<code>WorkInfo</code>的改变进行监听：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">workManager.getWorkInfoByIdLiveData(myWork.id)<br>.observe(<span class="hljs-keyword">this</span>) &#123; workInfo -&gt;<br><span class="hljs-keyword">if</span> (workInfo?.state == WorkInfo.State.SUCCEEDED) &#123;<br><span class="hljs-comment">// do work succeeded</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于更加复杂的任务查询需求，可以通过<code>WorkQuery.Builder</code>构建<code>WorkQuery</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> queries = WorkQuery.Builder<br>.fromTags(listOf(<span class="hljs-string">&quot;tag1&quot;</span>)<br>.addIds(listOf(myWork.id))<br>.build()<br><span class="hljs-keyword">val</span> workInfos = workManager.getWorkInfos(queries)<br></code></pre></td></tr></table></figure><h3 id="取消或暂停任务"><a href="#取消或暂停任务" class="headerlink" title="取消或暂停任务"></a>取消或暂停任务</h3><p>可以通过<code>name</code>，<code>id</code>或<code>tag</code>取消一个任务：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// by id</span><br>workManager.cancelWorkById(myWork.id)<br><br><span class="hljs-comment">// by name</span><br>workManager.cancelUniqueWork(<span class="hljs-string">&quot;work_name&quot;</span>)<br><br><span class="hljs-comment">// by tag</span><br>workManager.cancelAllWorkByTag(<span class="hljs-string">&quot;tag1&quot;</span>)<br></code></pre></td></tr></table></figure><p>对于当前正在运行的任务(RUNNING)，其会受到一个<code>ListenableWorker.onStopped()</code>方法调用。可以通过重载该方法来进行清理工作。</p><p><strong>停止一个正在执行的任务的原因</strong>：</p><ul><li>通过调用<code>WorkManager.cancelWorkById()</code>方法显式的中止任务。</li><li>在唯一任务中，向一个<code>ExistingWorkPolicy</code>设置为<code>REPLACE</code>的任务。则旧的任务则会被取消。</li><li>任务的约束条件无法满足。</li></ul><p>对于被取消的任务，应该考虑释放持有的资源。主要通过重载两个方法来实现对任务的取消：</p><ul><li><code>onStopped()</code>：<code>WorkManager</code>会调用<code>ListenableWorker.onStopped()</code>方法来取消任务，通过重载该方法来释放持有的资源。</li><li><code>isStopped()</code>：该方法用来检查一个任务是否已经取消。</li></ul><hr><h2 id="观察运行中的任务"><a href="#观察运行中的任务" class="headerlink" title="观察运行中的任务"></a>观察运行中的任务</h2><p><code>ListenableWorker</code>支持<code>setProgressAsync()</code>方法，其提供保留中间进度的能力，进度由<code>Data</code>进行表示。</p><p>代码示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 创建一个可观察的任务</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProgressWorker</span></span>(context: Context, parameters: WorkParameters) : CoroutineWorker(context, parameters) &#123;<br><span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> Progress = <span class="hljs-string">&quot;Progress&quot;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> delay = <span class="hljs-number">1000L</span><br>&#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span></span>: Result &#123;<br><span class="hljs-keyword">val</span> firstUpdate = workDataOf(Progress to <span class="hljs-number">0</span>)<br><span class="hljs-keyword">val</span> lastUpdate = workDataOf(Progress to <span class="hljs-number">100</span>)<br>setProgress(firstUpdate)<br>delay(delay)<br>setProgress(lastUpdate)<br>delay(delay)<br><span class="hljs-keyword">return</span> Result.success()<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 观察中间进展</span><br><span class="hljs-keyword">val</span> myWork = OneTimeWorkRequestBuilder&lt;ProgressWorker&gt;().build()<br><span class="hljs-keyword">val</span> workManager = WorkManager.getInstance(applicationContext)<br>workManager.enqueue(myWork)<br><br>workManager.getWorkInfoByIdLiveData(myWork.id)<br>.observe(<span class="hljs-keyword">this</span>) &#123; workInfo: WorkInfo? -&gt;<br><span class="hljs-keyword">if</span> (workInfo != <span class="hljs-literal">null</span>) &#123;<br>Log.d(TAG, <span class="hljs-string">&quot;current state is : <span class="hljs-subst">$&#123;workInfo.state&#125;</span>, current progress is <span class="hljs-subst">$&#123;workInfo.progress&#125;</span>&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li>若任务正在执行(RUNNING)，此时取消任务<code>cancel()</code>，任务如何处理？</li><li>唯一任务和非唯一任务之间是否产生冲突，同一个任务是否可以同时进入唯一任务队列和非唯一任务队列？</li><li>若存在五个任务：task1 … task5，其中task4依赖于task1和task2，task5依赖于task2和task3。如何设计链式任务，避免task2重复执行？</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.android.com/topic/libraries/architecture/workmanager">Schedule tasks with WorkManager</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android中的IPC</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/androidipc/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/androidipc/</url>
    
    <content type="html"><![CDATA[<h1 id="Android中的IPC"><a href="#Android中的IPC" class="headerlink" title="Android中的IPC"></a>Android中的IPC</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><strong>IPC</strong>：<em>Inter-Process Communication</em>，进程间通信。两个进程间进行数据交换。</li><li>进程：一个执行任务，一般包含一个或多个线程。不同进程之间内存空间相互独立。</li><li>线程：CPU调度的最小单元，同一进程的不同线程共享该进程的资源。</li><li>Android中一般一个应用对应一个进程，其中有一个主线程（也称UI线程），用于UI和交互操作。</li><li>主线程不要执行UI操作以外的操作，否则会导致ANR。</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.broadview.com.cn/book/539">Android开发艺术探索</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android中应用启动过程</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/app_launch/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/app_launch/</url>
    
    <content type="html"><![CDATA[<h1 id="Android中应用启动过程"><a href="#Android中应用启动过程" class="headerlink" title="Android中应用启动过程"></a>Android中应用启动过程</h1><p>[toc]</p><hr><h2 id="系统启动过程"><a href="#系统启动过程" class="headerlink" title="系统启动过程"></a>系统启动过程</h2><blockquote><p>加载<strong>BootLoader</strong> –&gt; 初始化内核 –&gt; 启动<strong>init</strong>进程 –&gt; 由<strong>init</strong>进程<code>fork</code>出<strong>Zygote</strong>进程 –&gt; <strong>Zygote</strong>进程<code>fork</code>出<strong>SystemServer</strong>进程</p></blockquote><p><img src="../../../imgs/androidsystemstart.png"></p><p>解释：</p><ul><li>系统的所有进程是由<strong>Zygote</strong>进程<code>fork</code>出来的。</li><li><code>SystemServer</code>进程是系统进程，很多系统服务是该进程创建后启动的。</li><li><code>ActivityManagerServices</code>：是一个服务端对象，负责所有<code>Activity</code>的生命周期，AMS通过<code>Binder</code>与<code>Actvity</code>通信，通过Socket与<strong>Zygote</strong>通信。</li><li><code>ActivityThread</code>：主线程/UI线程，其<code>main()</code>方法是APP的真正入门。</li><li><code>ApplicatioinThread</code>：<code>ActivityThread</code>的内部类，用于<code>ActivityThread</code>与AMS的所在进程间通信。</li></ul><hr><h2 id="应用启动过程"><a href="#应用启动过程" class="headerlink" title="应用启动过程"></a>应用启动过程</h2><blockquote><p>接下来解释从用户点击应用图标到应用展示在屏幕的全过程。</p></blockquote><p>注意：</p><ul><li>多个入口：每个Android应用是由多个不同的组件组合而成的，这些组件可以被其他应用调用，所有应用可以从任意一种组件开始应用。</li><li>独立进程：每个应用运行在各自独立的进程中，他们有自己的虚拟机实例以及唯一的UID。</li></ul><h3 id="Android进程何时启动"><a href="#Android进程何时启动" class="headerlink" title="Android进程何时启动"></a>Android进程何时启动</h3><ul><li>用户或其他的系统组件想要启动目标应用中的某个组件时，而此时该应用没有对应的进程正在运行，则Android系统将为该应用创建一个进程。</li><li>默认情况下，Android系统为每个运行的应用创建一个进程。且该进程中默认只有一个线程。</li></ul><h3 id="Zygote-创建所有Android进程的进程"><a href="#Zygote-创建所有Android进程的进程" class="headerlink" title="Zygote-创建所有Android进程的进程"></a><code>Zygote</code>-创建所有Android进程的进程</h3><ul><li>Android是基于Linux内核，Linux内核的启动过程如下：<ul><li>先通过BootLoader加载Linux内核并启动init进程。</li><li>init进程创建一些守护线程：adb守护线程，usb守护线程。</li></ul></li><li>init进程启动一个重要的进程：<strong>Zygote</strong>，该进程初始化一些重要的资源：预加载类，众多应用。</li><li><strong>Zygote</strong>进程创建一个<em>system server</em>进程，用于开始所有核心的平台服务。</li><li>当收到启动新应用的请求时，<strong>Zygote</strong>进程将会通过<code>fork</code>创建新的进程。</li></ul><h3 id="当用户点击应用图标时"><a href="#当用户点击应用图标时" class="headerlink" title="当用户点击应用图标时"></a>当用户点击应用图标时</h3><p>流程简介：</p><ul><li>创建进程。</li><li>绑定应用。</li><li>启动<code>Activity</code>/<code>Service</code>。</li></ul><h4 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h4><p>基本流程：</p><ul><li>用户的点击事件由<code>LauncherActivity</code>捕获到并通过<code>startActivity</code>方法启动。</li><li>由<code>Instrumentation</code>类的<code>execStartActivity</code>方法。</li><li>通过<code>ActivityManagerProxy</code>的<code>startActivity</code>方法。</li><li>通过<code>ActivityManagerNativeProxy</code>的<code>transact()</code>的方法。</li><li>通过<code>ActivityManagerNative</code>的<code>onTransact()</code>的方法。</li><li>调用<code>ActivityManagerService</code>调用<code>startActivity()</code>方法。</li><li>调用<code>ActivityManagerService</code>的<code>startActivityLocked</code>,<code>resumeTopActivityLocked</code>,<code>startSpecificActivityLocked</code>。</li><li>若对应的进程存在，则调用<code>realStartActivityLocked</code>；否则创建新的进程。</li><li>通过<code>Process</code>的<code>start</code>方法创建新的进程，获取pid。</li><li>由<strong>Zygote</strong>类返回到<code>ActivityThread</code>类的<code>main</code>方法。</li></ul><ol><li><code>ActivityManagerService</code>通过调用<code>startProcessLocked()</code>由<strong>Zygote</strong>进程创建新的进程。</li><li><strong>Zygote</strong>通过fork方法并调用<code>ZygoteInit.main()</code>方法实例化<code>ActivityThread</code>对象，返回新进程的pid。</li><li>每个进程中有一个<code>Looper</code>实例，<code>Looper</code>对象通过<code>loop()</code>方法循环将<code>MessageQueue</code>中的<code>Message</code>取出并分发给对应的<code>Handler</code>进行处理。而<code>ActivityThread</code>初始化时通过<code>Looper.prepareLoop()</code>和<code>Looper.loop()</code>方法开始循环。</li></ol><h4 id="绑定应用"><a href="#绑定应用" class="headerlink" title="绑定应用"></a>绑定应用</h4><p>基本流程：</p><ol><li>通过调用Thead对象中的<code>bindApplication()</code>方法将新创建的进程绑定到对应的进程。</li><li>该方法通过发送<strong>BIND_APPLICATION</strong>的<code>handleMessage()</code>方法执行特定的action：<code>handleBindApplication()</code>。</li><li>该方法调用<code>makeApplication()</code>方法将特定的类加载到内存中。</li></ol><h4 id="启动Activity"><a href="#启动Activity" class="headerlink" title="启动Activity"></a>启动Activity</h4><ul><li>经过之前的流程，系统中有对应应用的进程并该应用类已加载到内存中。</li><li>实际的启动流程是由<code>realStartActivity</code>开始的，其调用应用进程中的<code>sheduleLaunchActivity()</code>方法。</li><li>该方法发送<strong>LAUNCH_ACTIVITY</strong>的消息到<code>MessageQueue</code>中。</li><li>对应的<code>Handler</code>通过<code>handleLaunchActivity</code>方法启动Activity。</li></ul><p><img src="../../../imgs/androidapplaunch.png"></p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/hzwailll/article/details/85339714">ActivityThread的理解和APP的启动过程</a></li><li><a href="https://medium.com/android-news/android-application-launch-explained-from-zygote-to-your-activity-oncreate-8a8f036864b">Android Application Launch explained: from Zygote to your Activity.onCreate()</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android应用中的Context</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/context_in_android_application/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/context_in_android_application/</url>
    
    <content type="html"><![CDATA[<h1 id="Android应用中的Context"><a href="#Android应用中的Context" class="headerlink" title="Android应用中的Context"></a>Android应用中的Context</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Android中，许多场景会用到<code>Context</code>，而可以通过多种方式获取<code>Context</code>。如在Activity中可以通过<code>getContext()</code>，<code>getApplicationContext()</code>或者通过<code>getBaseContext()</code>等方式获取<code>Context</code>。而通过不同方式的<code>Context</code>有什么区别呢？接下来解释不同的方式获取的<code>Context</code>的不同之处。</p><p><strong>官方解释</strong>:</p><ul><li>应用的全局信息。</li><li>可以获取应用级的资源或类。</li><li>执行应用级的操作，如：启动<code>Activity</code>，广播和接收<code>Intent</code>。</li></ul><hr><h2 id="不同Context之间的对比"><a href="#不同Context之间的对比" class="headerlink" title="不同Context之间的对比"></a>不同<code>Context</code>之间的对比</h2><table><thead><tr><th>获取方式</th><th>对应的组件</th><th>生命周期</th><th>主要用途</th></tr></thead><tbody><tr><td><code>getContext()</code></td><td>对应的Activity</td><td>与对应的Activity生命周期相同</td><td>与UI操作有关：绘制布局视图(inflate layout),启动<code>Activity</code>，展示对话框，启动或绑定<code>Service</code>，发送或绑定广播</td></tr><tr><td><code>getApplicationContext()</code></td><td>整个Application</td><td>与整个Application生命周期相同</td><td>加载资源，开始或绑定<code>Service</code>，发送广播</td></tr></tbody></table><hr><h2 id="案例：单例模式中的Context选择"><a href="#案例：单例模式中的Context选择" class="headerlink" title="案例：单例模式中的Context选择"></a>案例：单例模式中的<code>Context</code>选择</h2><p>若在一个单例模式中需要<code>Context</code>变量，则需要使用Application Context。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonContext</span> </span>&#123;<br><span class="hljs-keyword">private</span> Context mContext;<br><span class="hljs-keyword">private</span> SingletonContext instance;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonContext</span><span class="hljs-params">(Context mContext)</span> </span>&#123;<span class="hljs-keyword">this</span>.mContext = mContext.getApplicationContext();&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonContext <span class="hljs-title">getInstance</span><span class="hljs-params">(Context mContext)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) instance = <span class="hljs-keyword">new</span> SingletonContext(mContext);<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：</p><ul><li>使用<code>mContext.getApplicationContext()</code>获取Application Context，一般情况下单例类生命周期比特定Activity的生命周期长。</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://medium.com/@banmarkovic/what-is-context-in-android-and-which-one-should-you-use-e1a8c6529652">What is Context in Android and which one should you use?</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android中的消息机制</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/handler_looper_messagequeue/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/handler_looper_messagequeue/</url>
    
    <content type="html"><![CDATA[<h1 id="Android中的消息机制"><a href="#Android中的消息机制" class="headerlink" title="Android中的消息机制"></a>Android中的消息机制</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Android的消息机制是通过<code>Handler</code>以及配合<code>Looper</code>和<code>MessageQueue</code>实现将在指定线程运行任务并在主线程更新UI。</li><li>Android中可能出现多个线程并发执行UI更新操作，中指定只能在主线程中更新UI，保证更新UI操作的线程安全。</li><li>工作线程需要更新UI时，通过<code>Handler</code>通知主线程，由主线程进行更新操作。</li></ul><hr><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ul><li><code>MessageQueue</code>：是用于保存<code>Message</code>的队列，不独立存在。每个<code>MessageQueue</code>都有对应的<code>Looper</code>。<code>Message</code>是通过<code>Handler</code>添加到MessageQueue`中。</li><li>可以通过<code>Looper.myQueue()</code>获取当前线程的<code>MessageQueue</code>对象。</li><li><code>Handler</code>：将<code>Message</code>传输给对应的<code>MessageQueue</code>，并处理<code>MessageQueue</code>中接受的<code>Message</code>。</li><li>若不指定，新创建的<code>Handler</code>与创建的线程绑定。在这种情况下，相当于自己将<code>Message</code>传送给队列并从队列中获取<code>Message</code>。</li><li><code>Handler</code>可以用于处理<code>Message</code>和<code>Runnable</code>，通过<code>post()</code>方法发送<code>Runnable</code>任务，通过<code>sendMessage()</code>发送<code>Message</code>消息。</li><li><code>Handler</code>常用于一下两种情况：<ul><li>周期性的执行某个任务。</li><li>在其他线程中执行某项任务。</li></ul></li><li></li></ul><hr><h2 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h2><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/huansky/p/9427854.html">Android Handler 源码分析（详细）</a></li><li><a href="https://www.jianshu.com/p/f0b23ee5a922">Android Handler：图文解析 Handler通信机制的工作原理</a></li><li><a href="https://medium.com/@ankit.sinhal/handler-in-android-d138c1f4980e">Handler in Android</a></li><li><a href="https://proandroiddev.com/decoding-handler-and-looper-in-android-d4f3f2449513">Decoding Handler and Looper in Android</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android隐藏标题栏、状态栏</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/hidetitlebar/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/hidetitlebar/</url>
    
    <content type="html"><![CDATA[<h1 id="Android隐藏标题栏、状态栏"><a href="#Android隐藏标题栏、状态栏" class="headerlink" title="Android隐藏标题栏、状态栏"></a>Android隐藏标题栏、状态栏</h1><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.jianshu.com/p/598f7fa86544">Android隐藏标题栏、状态栏、导航栏及全屏方法总结</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Intent中的flag属性解析</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/intentflags/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/intentflags/</url>
    
    <content type="html"><![CDATA[<h1 id="Intent中的flag属性解析"><a href="#Intent中的flag属性解析" class="headerlink" title="Intent中的flag属性解析"></a><code>Intent</code>中的flag属性解析</h1><p>[toc]</p><hr><h2 id="了解任务和返回堆栈"><a href="#了解任务和返回堆栈" class="headerlink" title="了解任务和返回堆栈"></a>了解任务和返回堆栈</h2><blockquote><p>任务：一系列Activity的集合，这些Activity按照打开的先后顺序在返回堆栈中保存。</p></blockquote><p>基本流程：</p><ul><li>系统会为首次启动应用创建一个返回栈。</li><li>主Activity会进栈。</li><li>当栈顶的Activity调用其他Acitivity时，被调用的Activity会入栈，成为栈顶。</li><li>用户按返回键时，栈顶的Activity会出栈被销毁，上一个Acitivity自动成为栈顶。</li><li>当返回栈为空时，对应任务也就不再存在。</li></ul><hr><h2 id="Intent中的常见flag属性"><a href="#Intent中的常见flag属性" class="headerlink" title="Intent中的常见flag属性"></a><code>Intent</code>中的常见flag属性</h2><table><thead><tr><th>flag</th><th>功能</th></tr></thead><tbody><tr><td><code>FLAG_ACTIVITY_CLEAR_TASK</code></td><td>清除当前task栈中的所有Activity实例，使得启动的Activity入栈，必须与<code>FLAG_ACTIVITY_NEW_TASK</code>搭配使用</td></tr><tr><td><code>FLAG_ACTIVITY_CLEAR_TOP</code></td><td>若启动的Activity在当前的task栈中正在运行，则将栈中该Activity上的所有Activity关闭，并将该<code>Intent</code>传递给对应的Activity。若没有设置<code>FLAG_ACTIVITY_SINGLE_TOP</code>，则结束当前Activity并创建新的Activity实例；其他情况下（设置<code>FLAG_ACTIVITY_SINGLE_TOP</code>或其他情况），则该<code>Intent</code>将被传递给当前Activity的<code>onNewIntent()</code>方法。当与<code>FLAG_ACTIVITY_NEW_TASK</code>搭配使用，使得对应的task栈成为前台，清空task栈并使得启动的Activity进入task栈中</td></tr><tr><td><code>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</code></td><td>新的Activity不会保存在最近启动的Activity中</td></tr><tr><td><code>FLAG_ACTIVITY_FORWARD_RESULT</code></td><td>使得不同的Activity可以跨Activity获得结果，使用方法参见<a href="https://gist.github.com/mcelotti/cc1fc8b8bc1224c2f145">mcelotti/android_forward_result</a></td></tr><tr><td><code>FLAG_ACTIVITY_LAUNCH_ADJACENT</code></td><td>必须与<code>FLAG_ACTIVITY_NEW_TASK</code>搭配使用，用于分屏或多窗口模式，启动的Activity将显示为发起Activity的大小</td></tr><tr><td><code>FLAG_ACTIVITY_MATCH_EXTERNAL</code></td><td></td></tr><tr><td><code>FLAG_ACTIVITY_MULTIPLE_TASK</code></td><td>必须与<code>FLAG_ACTIVITY_NEW_DOCUMENT</code>或<code>FLAG_ACTIVITY_NEW_TASK</code>搭配使用，不管对应的task是否存在直接创建新的task</td></tr><tr><td></td><td></td></tr></tbody></table><hr><h2 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h2><h3 id="FLAG-ACTIVITY-CLEAR-TASK"><a href="#FLAG-ACTIVITY-CLEAR-TASK" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TASK"></a><code>FLAG_ACTIVITY_CLEAR_TASK</code></h3><p>正常情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"> * Hist #3: ActivityRecord&#123;c937110 u0 com.xiaomi.intentflags/.MainActivity2 t86&#125;<br> keysPaused=false inHistory=true mIsCastMode=false mIsLastFrame=false setToSleep=false idle=true mStartingWindowState=STARTING_WINDOW_NOT_SHOWN<br>* Hist #2: ActivityRecord&#123;94432e5 u0 com.xiaomi.intentflags/.MainActivity3 t86&#125;<br>         keysPaused=false inHistory=true mIsCastMode=false mIsLastFrame=false setToSleep=false idle=true mStartingWindowState=STARTING_WINDOW_NOT_SHOWN<br>* Hist #1: ActivityRecord&#123;2428814 u0 com.xiaomi.intentflags/.MainActivity2 t86&#125;<br>         keysPaused=false inHistory=true mIsCastMode=false mIsLastFrame=false setToSleep=false idle=true mStartingWindowState=STARTING_WINDOW_NOT_SHOWN<br>* Hist #0: ActivityRecord&#123;677d32e u0 com.xiaomi.intentflags/.MainActivity t86&#125;<br>         keysPaused=false inHistory=true mIsCastMode=false mIsLastFrame=false setToSleep=false idle=true mStartingWindowState=STARTING_WINDOW_REMOVED<br><br></code></pre></td></tr></table></figure><p>使用flag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">* Hist #0: ActivityRecord&#123;3c8de80 u0 com.xiaomi.intentflags/.MainActivity2 t85&#125;<br>keysPaused=false inHistory=true mIsCastMode=false mIsLastFrame=false setToSleep=false idle=true mStartingWindowState=STARTING_WINDOW_SHOWN<br></code></pre></td></tr></table></figure><p>解释：<code>MainActivity3</code>设置跳转到<code>MainActivity2</code>的<code>Intent</code>。可以看出没有设置<code>FLAG_ACTIVITY_CLEAR_TASK</code>会创建新的<code>MainActivity2</code>实例。而使用该flag后会清除当前task栈中的所有Activity，并将启动的Activity入栈。</p><h3 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a><code>FLAG_ACTIVITY_CLEAR_TOP</code></h3><p>正常情况：<br>同上</p><p>使用flag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">* Hist #1: ActivityRecord&#123;ce97396 u0 com.xiaomi.intentflags/.MainActivity2 t88&#125;<br>    keysPaused=false inHistory=true mIsCastMode=false mIsLastFrame=false setToSleep=false idle=true mStartingWindowState=STARTING_WINDOW_NOT_SHOWN<br>* Hist #0: ActivityRecord&#123;47e2fd u0 com.xiaomi.intentflags/.MainActivity t88&#125;<br>    keysPaused=false inHistory=true mIsCastMode=false mIsLastFrame=false setToSleep=false idle=true mStartingWindowState=STARTING_WINDOW_REMOVED<br></code></pre></td></tr></table></figure><p>解释：使用flag后，<code>MainActivity2</code>上的<code>MainActivity3</code>会被清除。</p><h3 id="FLAG-ACTIVITY-FORWARD-RESULT"><a href="#FLAG-ACTIVITY-FORWARD-RESULT" class="headerlink" title="FLAG_ACTIVITY_FORWARD_RESULT"></a><code>FLAG_ACTIVITY_FORWARD_RESULT</code></h3><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="developer.android.com/guide/components/activities/tasks-and-back-stack">了解任务和返回堆栈</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android中解析JSON文件的方法</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/json/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/json/</url>
    
    <content type="html"><![CDATA[<h1 id="Android中解析JSON文件的方法"><a href="#Android中解析JSON文件的方法" class="headerlink" title="Android中解析JSON文件的方法"></a>Android中解析JSON文件的方法</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>可以使用Android中<code>JSONObject</code>和<code>JSONArray</code>解析JSON数据，具体的数据结构与解析方式如下。</p><hr><h2 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h2><h3 id="解析JSON对象"><a href="#解析JSON对象" class="headerlink" title="解析JSON对象"></a>解析JSON对象</h3><p><strong>JSON数据格式</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">39</span>,<br>  <span class="hljs-attr">&quot;salary&quot;</span>: <span class="hljs-number">20.34</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解析方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    JSONObject jo = <span class="hljs-keyword">new</span> JSONObject(readFile(path));<br>    <span class="hljs-keyword">if</span> (jo != <span class="hljs-keyword">null</span>) &#123;<br>String name = jo.optString(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">int</span> age = jo.optInt(<span class="hljs-string">&quot;age&quot;</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-keyword">double</span> salary = jo.optDouble(<span class="hljs-string">&quot;salary&quot;</span>, <span class="hljs-number">0.0</span>);<br>String res = <span class="hljs-string">&quot;name : &quot;</span> + name + <span class="hljs-string">&quot;, age : &quot;</span> + age + <span class="hljs-string">&quot;, salary : &quot;</span> + salary;<br>sendMessage(res);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解析JSON对象（包含嵌套对象）"><a href="#解析JSON对象（包含嵌套对象）" class="headerlink" title="解析JSON对象（包含嵌套对象）"></a>解析JSON对象（包含嵌套对象）</h3><p><strong>JSON数据结构</strong>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;student&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;李四&quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">22</span>,<br>    <span class="hljs-attr">&quot;dog&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;阿黄&quot;</span>,<br>      <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">2</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解析方式代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    JSONObject jo = <span class="hljs-keyword">new</span> JSONObject(readFile(path));<br>    String res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span> (jo != <span class="hljs-keyword">null</span>) &#123;<br>JSONObject jo1 = jo.getJSONObject(<span class="hljs-string">&quot;student&quot;</span>);<br><span class="hljs-keyword">if</span> (jo1 != <span class="hljs-keyword">null</span>) &#123;<br>    String name = jo1.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>    <span class="hljs-keyword">int</span> age = jo1.getInt(<span class="hljs-string">&quot;age&quot;</span>);<br>    JSONObject jo2 = jo1.getJSONObject(<span class="hljs-string">&quot;dog&quot;</span>);<br>    <span class="hljs-keyword">if</span> (jo2 != <span class="hljs-keyword">null</span>) &#123;<br>String name1 = jo2.getString(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">int</span> age1 = jo2.getInt(<span class="hljs-string">&quot;age&quot;</span>);<br>res = <span class="hljs-string">&quot;name : &quot;</span> + name + <span class="hljs-string">&quot;, age : &quot;</span> + age + <span class="hljs-string">&quot;, dog name : &quot;</span> + name1 + <span class="hljs-string">&quot;, dog age : &quot;</span> + age1;<br>    &#125;<br>&#125;<br>    &#125;<br>    sendMessage(res);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解析JSON数组"><a href="#解析JSON数组" class="headerlink" title="解析JSON数组"></a>解析JSON数组</h3><p><strong>JSON数据结构</strong>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">22</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;李四&quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">23</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p><strong>解析方式代码</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    JSONArray ja = <span class="hljs-keyword">new</span> JSONArray(readFile(path));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ja.length(); ++i) &#123;<br>JSONObject jo = ja.getJSONObject(i);<br>sb.append(<span class="hljs-string">&quot;name : &quot;</span> + jo.getString(<span class="hljs-string">&quot;name&quot;</span>) + <span class="hljs-string">&quot;, age : &quot;</span> + jo.getInt(<span class="hljs-string">&quot;age&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    sendMessage(sb.toString());<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用<code>JSONObject</code>解析JSON数据结构<code>&#123;&#125;</code>。</li><li>使用<code>JSONArray</code>解析JSON数据结构<code>[]</code>。</li><li>通过<code>optString(&quot;key&quot;)</code>获取键为”key”的String对象。</li><li>不使用<code>getXXX()</code>而使用<code>optXXX()</code>方式因为后者若获取失败会抛出异常而前者返回null。</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/android-deli/p/10167395.html">ANDROID-解析JSON数据（JSON对象/JSON数组）</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android中的用户位置</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/location/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/location/</url>
    
    <content type="html"><![CDATA[<h1 id="Android中的用户位置"><a href="#Android中的用户位置" class="headerlink" title="Android中的用户位置"></a>Android中的用户位置</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p>位置信息访问权限主要分为两种：</p><ul><li>前台位置信息</li><li>后台位置信息</li></ul></li><li><p><strong>前台位置信息</strong>：只接收一次位置信息或只在特定时间段内接受位置信息。</p><ul><li>该应用中可见的Activity正在请求Activity。</li><li>该应用在前台运行，系统会展示一个持续的提示。若该应用由于Home键转入后台，仍然可以访问位置信息。</li></ul></li><li><p>在<code>AndroidManifest.xml</code>中声明如下权限表示要获取前台位置信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_COARSE_LOCATION&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_FINE_LOCATION&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>ACCESS_COARSE_LOCATION</code>：位置位置的估算值，范围约为1.6公里。</p></li><li><p><code>ACCESS_FINE_LOCATION</code>：准确的设备位置估算值，范围约为50米。</p></li><li><p><strong>后台位置信息</strong>：不断的与其他用户分享位置信息，或其他非前台位置信息行为。</p></li><li><p>在<code>AndroidManifest.xml</code>中声明使用权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="运行时请求位置访问"><a href="#运行时请求位置访问" class="headerlink" title="运行时请求位置访问"></a>运行时请求位置访问</h2><ul><li>请求位置访问流程：请求位置访问权限 –&gt; 用户授予权限 –&gt; 应用拿到位置权限</li><li>应用只有在请求位置权限后才能被授予位置权限，否则处于非授权状态。</li><li>权限申请按照：前台位置访问权限 –&gt; 后台位置访问权限 的顺序，在API 30以后同时请求两个权限时请求会被忽略。</li></ul><h3 id="请求后台位置信息"><a href="#请求后台位置信息" class="headerlink" title="请求后台位置信息"></a>请求后台位置信息</h3><p>若要请求后台位置权限，需要在<code>AndroidManifest.xml</code>文件中设置权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.android.com/training/location?hl=zh-cn">用户位置</a></li><li><a href="https://blog.csdn.net/ccpat/article/details/106380620">Android定位功能实现(强烈推荐)</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android中的内存泄漏</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/memory_leaks/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/memory_leaks/</url>
    
    <content type="html"><![CDATA[<h1 id="Android中的内存泄漏"><a href="#Android中的内存泄漏" class="headerlink" title="Android中的内存泄漏"></a>Android中的内存泄漏</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>内存泄漏(Memory Leak):垃圾回收器无法对内存中不再使用的对象进行回收。</p><p>内存泄漏主要分为两类：</p><ul><li>占用内存直到应用结束。</li><li>占用内存直到方法结束：一个需要长时间运行的任务持有无用对象的引用时，该对象无法被回收，直到方法执行完成。</li></ul><p>Java内存划分：</p><ul><li>堆(Heap)：动态内存分配，主要用于保存创建的对象，JVM负责回收堆内存中没有引用的对象。</li><li>栈(Stack):静态内存分配，用于为方法执行生成对应的栈内存块(stack memory block)。</li></ul><p>注：</p><ul><li>Android为每个应用所使用的堆内存设置限制，若超过限制则会产生<code>OutOfMemoryError</code>错误。</li><li>可以通过<code>ActivityManager</code>的<code>getMemoryClass()</code>方法或的堆内存限制。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ActivityManager am = getSystemService(ACTIVIYT_SERVICE);<br>am.getMemoryClass(); <br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="实例说明Java内存分配流程"><a href="#实例说明Java内存分配流程" class="headerlink" title="实例说明Java内存分配流程"></a>实例说明Java内存分配流程</h2><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memory</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-comment">// 2</span><br>Object obj = <span class="hljs-keyword">new</span> Object(); <span class="hljs-comment">// 3</span><br>Memory memo = <span class="hljs-keyword">new</span> Memory(); <span class="hljs-comment">// 4</span><br>memo.foo(obj); <span class="hljs-comment">// 5</span><br>&#125; <span class="hljs-comment">// 9</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Object param)</span> </span>&#123; <span class="hljs-comment">// 6</span><br>String str = param.toString(); <span class="hljs-comment">// 7</span><br>System.out.println(str);<br>&#125; <span class="hljs-comment">// 8</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法执行"><a href="#方法执行" class="headerlink" title="方法执行"></a>方法执行</h3><p>当执行到第7行时，此时内存中的对象如图：<br><img src="../../../imgs/androidmemoryleak_1.png"></p><blockquote><p>说明：</p><ul><li>左侧是栈内存，右侧为堆内存。当执行一个方法时，会为该方法生成栈帧并入栈。当创建一个对象时，会在堆内存中分配内存，并且栈帧中的引用指向该对象。</li><li>方法中基本数据类型的变量直接保存到对应的栈帧中。</li><li>堆内存中存在一个常量池，用于保存类似<code>String</code>类型的常量。</li><li>Java中只有<strong>值传递</strong>。所以传递的参数为变量时，参数总是指向堆内存中的真实对象。</li></ul></blockquote><h3 id="方法结束"><a href="#方法结束" class="headerlink" title="方法结束"></a>方法结束</h3><p>当执行到第8行时，方法<code>foo()</code>结束。<br>当执行到第9行时，方法<code>main()</code>结束。</p><blockquote><p>方法<code>foo()</code>结束：</p><ul><li>指定String常量池的引用消失，对应的栈帧从栈内存弹出。<br><img src="../../../imgs/androidmemoryleak_2.png"></li></ul></blockquote><blockquote><p>方法<code>main()</code>结束：</p><ul><li>指定对象<code>Object</code>和<code>Memory</code>的引用消失，对应栈帧从栈内存弹出。</li><li>JVM的垃圾回收器将会回收这些对象占用的内存。<br><img src="../../../imgs/androidmemoryleak_3.png"></li></ul></blockquote><h3 id="垃圾回收原理简介"><a href="#垃圾回收原理简介" class="headerlink" title="垃圾回收原理简介"></a>垃圾回收原理简介</h3><p>JVM的垃圾回收器按照可达性原理来确定一个对象是否需要被回收，当一个对象无法从所谓的GC Roots对象遍历到，则认为该对象不可达，被标记为可以回收，从而进行回收。</p><p><img src="../../../imgs/javagcreachable.png"></p><hr><h2 id="内存泄漏的几种情况"><a href="#内存泄漏的几种情况" class="headerlink" title="内存泄漏的几种情况"></a>内存泄漏的几种情况</h2><blockquote><p>当栈内仍然引用着堆内存中无用的对象，会发生内存泄漏。<br>在Android中，常在使用<code>AsyncTasks</code>，<code>Handlers</code>，<strong>Singletons</strong>模式，<code>Threads</code>等出现内存泄漏。</p></blockquote><h3 id="示例1：内部类持有外部类的引用"><a href="#示例1：内部类持有外部类的引用" class="headerlink" title="示例1：内部类持有外部类的引用"></a>示例1：内部类持有外部类的引用</h3><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ImageView iv_show_image1;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        iv_show_image1 = (ImageView) findViewById(R.id.iv_show_image1);<br>        iv_show_image1.setImageResource(R.drawable.nature);<br>        <span class="hljs-keyword">new</span> MyThread(<span class="hljs-keyword">this</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> MainActivity mainActivity;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(MainActivity mainActivity)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.mainActivity = mainActivity;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.currentThread().wait(<span class="hljs-number">1000</span> * <span class="hljs-number">10</span>);<br>                    Log.d(<span class="hljs-string">&quot;MyThread&quot;</span>, <span class="hljs-string">&quot;task is done!&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析</strong>：</p><ul><li>上述代码中在<code>MainActivity</code>中创建新的线程并运行，随后我们退出该<code>Activity</code>。而新线程要等到10秒才能结束。</li><li>由于新线程<code>MyThread</code>中持有<code>MainActivity</code>的引用，导致虽然<code>MainActivity</code>已经退出，但垃圾回收器无法回收内存。</li></ul><p><img src="../../../imgs/androidmemoryleak_4.png"></p><h3 id="示例2：单例模式导致内存泄漏"><a href="#示例2：单例模式导致内存泄漏" class="headerlink" title="示例2：单例模式导致内存泄漏"></a>示例2：单例模式导致内存泄漏</h3><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// singleton class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonManager</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonManager singleton;<br>    <span class="hljs-keyword">private</span> Context context;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonManager</span><span class="hljs-params">(Context context)</span> </span>&#123;<span class="hljs-keyword">this</span>.context = context;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> SingletonManager <span class="hljs-title">getInstance</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) singleton = <span class="hljs-keyword">new</span> SingletonManager(context);<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// pass activity context to singleton class in an activity</span><br>SingletonManager.getInstance(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><p><strong>分析</strong>：</p><ul><li>单例类中使用<code>Context</code>类，而在<code>Activity</code>中传入Activity Context，使得单例类间接持有<code>Activity</code>的引用。</li><li>当<code>Activity</code>退出时，由于有引用指向而无法被回收。</li><li>为了避免内存泄漏，传递Context时使用Application Context而非Activity Context。无论传入的Context是何种Context，均使用Application Context。<code>context.getApplicationContext()</code></li></ul><h3 id="示例3：监听器导致内存泄漏"><a href="#示例3：监听器导致内存泄漏" class="headerlink" title="示例3：监听器导致内存泄漏"></a>示例3：监听器导致内存泄漏</h3><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LocationListener</span> </span>&#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLocationUpdated</span><span class="hljs-params">(Location location)</span></span>&#123;<br>  <span class="hljs-comment">// do something</span><br>  &#125;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span></span>&#123;<br>    LocationManager.getInstance().register(<span class="hljs-keyword">this</span>);<br>  &#125;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span></span>&#123;<br>    LocationManager.getInstance().unregister(<span class="hljs-keyword">this</span>);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他常见的内存泄漏的情况"><a href="#其他常见的内存泄漏的情况" class="headerlink" title="其他常见的内存泄漏的情况"></a>其他常见的内存泄漏的情况</h3><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>若一个匿名类的生命周期比容器类的生命周期长，并且在匿名类中调用容器类的任何方法、读写容器类的属性等，这将导致容器类无法被销毁，从而引起内存泄漏。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类是另一个常见的内存泄漏的原因。由于内部类可能持有外部类的引用，所以在内部类的生命周期比外部类的生命周期长并且内部类会使用外部类的变量时，会导致外部类无法被回收。</p><p>可能的解决方式：内部类中使用弱引用<code>WeakReference</code>来指向外部类对象，这样不会影响垃圾收集器对外部类的回收。</p><h3 id="静态变量-static-variables"><a href="#静态变量-static-variables" class="headerlink" title="静态变量(static variables)"></a>静态变量(static variables)</h3><blockquote><p>Kotlin中<code>companion object</code>块中都是静态变量。</p></blockquote><p>静态变量不与具体的实例对象的生命周期有关，只要类加载器首次加载该类，则静态变量则一直存活。所以避免使用静态变量引用指向Activity，只会导致Activity无法被回收。</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>如果一个单例对象持有Activity并且其生命周期比Activity长，将会导致内存泄漏。<br>为了避免这一问题，可以在但里方法中提供方法用于清除对于Activity的引用，并且在该Activity的<code>onDestroy()</code>方法调用单例中的该方法。</p><blockquote><p>注意：<br>在使用<strong>匿名类</strong>或<strong>内部类</strong>时要警惕使用外部类的引用。<br>同时在使用<strong>延迟任务</strong>或<strong>其他与线程相关的类</strong>(如：<code>Handlers</code>,<code>TimerTasks</code>,<code>Threads</code>,<code>AsyncTasks</code>或<code>RxJava</code>)时务必警惕。</p></blockquote><p><strong>分析</strong>:</p><ul><li>上面的代码中在Start阶段注册监听器，在Stop阶段取消监听器。</li><li>若在<code>onStop()</code>方法中忘记取消监听器，则导致监听器持有Activity的引用，Activity退出时无法被回收。</li><li>在<code>onDestory()</code>或<code>onStop()</code>方法中执行注销操作。</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://proandroiddev.com/everything-you-need-to-know-about-memory-leaks-in-android-d7a59faaf46a">Everything you need to know about Memory Leaks in Android.</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>进程与线程</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/processes_threads/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/processes_threads/</url>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>默认情况下，同一个应用的所有组件在一个进程中执行。若没有创建新的线程，则所有组件在主线程中执行。</li><li>可以设置应用中的组件在新的进程或新的线程中执行。</li></ul><hr><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>可以通过<code>AndroidManifest.xml</code>控制应用中组件所属的进程。</li><li>在<code>&lt;application&gt;</code>中设置<code>android:process</code>属性，可以设置所有组件的默认值。</li><li>在<code>&lt;activity&gt;</code>组件中设置<code>android:process</code>属性，可以指定组件运行的进程。每个组件可以处于各自的进程或者共享同一个进程。</li><li>系统是否中止某个进程取决于该进程中运行组件的状态。</li></ul><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.android.com/guide/components/processes-and-threads">进程和线程概览</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>任务和返回堆栈</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/tasksandbackstack/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/notes/tasksandbackstack/</url>
    
    <content type="html"><![CDATA[<h1 id="任务和返回堆栈"><a href="#任务和返回堆栈" class="headerlink" title="任务和返回堆栈"></a>任务和返回堆栈</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>任务（task）：一系列Activity的集合。这些Activity按照打开的先后顺序进入返回堆栈（back stack，task栈）。</li></ul><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://developer.android.google.cn/guide/components/activities/tasks-and-back-stack?hl=zh-cn">了解任务和返回堆栈</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Go连接数据库</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/go-webservices/connect_databased/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/go-webservices/connect_databased/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Go连接数据库"><a href="#使用Go连接数据库" class="headerlink" title="使用Go连接数据库"></a>使用Go连接数据库</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>目的：通过Go连接到数据库，并实现增删改查。</p><hr><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><ol><li>首先操作数据库准备好对应的数据。</li><li>编写go代码连接数据库。</li><li>执行增删改查操作。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建测试数据库</span><br><span class="hljs-keyword">CREATE</span> DATABASE sql_test;<br><br><span class="hljs-comment">-- USE sql_test;</span><br><br><span class="hljs-comment">-- 创建数据表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> sql_test.user(<br>    `id`        <span class="hljs-type">int</span>         AUTO_INCREMENT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    `name`      <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `age`       <span class="hljs-type">int</span>         <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>)ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> data<br><br><span class="hljs-comment">// 创建数据表对应的结构体</span><br><span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span>&#123;<br>    id      <span class="hljs-keyword">int</span><br>    name    <span class="hljs-keyword">string</span><br>    age     <span class="hljs-keyword">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>安装go对MySQL的驱动包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get -u github.com/go-sql-driver/mysql<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> data<br><br><span class="hljs-comment">// 数据库操作集合</span><br><br><span class="hljs-keyword">import</span>(<br>    <span class="hljs-string">&quot;database/sql&quot;</span><br>    _ <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">var</span>(<br>    mysqldb *sql.DB<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    dsn := <span class="hljs-string">&quot;&lt;user_name&gt;:&lt;user_password&gt;@tcp(127.0.0.1:3306)/sql_test&quot;</span><br>    <span class="hljs-keyword">var</span> err error<br>    db, err = sql.Open(<span class="hljs-string">&quot;mysql&quot;</span>, dsn)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    err = db.Ping()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 通过ID查用户</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QueryUserById</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(u user)</span></span> &#123;<br>    queryStr := <span class="hljs-string">&quot;SELECT * FROM user WHERE id = ?&quot;</span><br>    stmtOut, err := mysqldb.Prepare(queryStr)<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">defer</span> stmtOut.Close()<br>        err = stmtOut.QueryRow(id).Scan(&amp;u.id, &amp;u.name, &amp;u.age)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Fatalln(err.Error())<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 查所有用户</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QueryAllUser</span><span class="hljs-params">()</span> <span class="hljs-params">(users []user)</span></span> &#123;<br>    queryStr := <span class="hljs-string">&quot;SELECT * FROM user&quot;</span><br>    rows, err := mysqldb.Query(queryStr)<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">defer</span> rows.Close()<br>        <span class="hljs-keyword">for</span> rows.Next() &#123;<br>            <span class="hljs-keyword">var</span> u user<br>            err = rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)<br>            users = <span class="hljs-built_in">append</span>(users, u)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 添加用户</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUser</span><span class="hljs-params">(u user)</span></span> &#123;<br>    au := <span class="hljs-string">&quot;INSERT INTO user(name, age) VALUES(?, ?)&quot;</span><br>    _, err := mysqldb.Exec(au, u.name, u.age)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalln(err.Error())<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 更新用户</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdateUser</span><span class="hljs-params">(u user)</span></span> &#123;<br>    us := <span class="hljs-string">&quot;UPDATE user SET name=?, age=? WHERE id=?&quot;</span><br>    _, err := mysqldb.Exec(us, u.name, u.age, u.id)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalln(err.Error())<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 删除用户</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeleteUser</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    du := <span class="hljs-string">&quot;DELETE FROM user WHERE id=?&quot;</span><br>    _, err := mysqldb.Exec(du, id)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalln(err.Error())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="针对NULL值的处理"><a href="#针对NULL值的处理" class="headerlink" title="针对NULL值的处理"></a>针对NULL值的处理</h2><p>当从数据库中获得数据并映射到对应的结构体上时，若存在NULL值，则会发生异常：<code>sql: Scan error on column index 1: converting NULL to string is unsupported</code>。</p><p>处理方式：</p><ol><li>使用<code>sql.NullString</code>。</li><li>将其看作空字符串。使用<code>[]byte</code>替代<code>string</code>:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span>&#123;<br>    id      <span class="hljs-keyword">int</span><br>    name    []<span class="hljs-keyword">byte</span><br>    age     <span class="hljs-keyword">int</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><code>sql.Open()</code>方法<strong>并没有建立任何与数据库的连接</strong>，也不会验证连接数据库的参数。只有在第一次需要连接数据库时才建立连接。可以通过<code>db.Ping()</code>方法检查可以正常连接到数据库。</li><li>不要频繁地调用<code>Open()</code>和<code>Close()</code>。对于每个数据库创建一个<code>sql.DB</code>，将其作为参数传入到需要访问数据库的所有方法。直到不再需要访问数据库时才关闭数据库<code>Close()</code>。</li><li>频繁的与数据库建立连接可能导致由于大量TCP处于<code>TIME_WAIT</code>状态而无法建立连接。</li></ul><hr><h2 id="database-sql包解析"><a href="#database-sql包解析" class="headerlink" title="database/sql包解析"></a><code>database/sql</code>包解析</h2><h3 id="sql-Open-函数"><a href="#sql-Open-函数" class="headerlink" title="sql.Open()函数"></a><code>sql.Open()</code>函数</h3><ul><li>通过<code>sql.Open()</code>函数返回一个<code>sql.DB</code>对象引用。<code>sql.DB</code><strong>并不是一个数据库连接</strong>。<code>Open()</code>只会检查数据库驱动或数据源格式是否正确。如需要检查数据源正确，可以通过调用<code>Ping()</code>方法。</li></ul><blockquote><p>测试结果：</p><ul><li>当驱动名(<code>driverName</code>)错误或数据源名(<code>dataSourceName</code>)，<code>Open()</code>会返回错误，否则不会返回错误。</li></ul></blockquote><h3 id="sql-Ping-函数"><a href="#sql-Ping-函数" class="headerlink" title="sql.Ping()函数"></a><code>sql.Ping()</code>函数</h3><p>验证一个数据库连接是否存活，若没有建立连接则先建立连接。</p><hr><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li>针对<code>int</code>类型可能为NULL时，如何处理<code>Scan()</code>产生的错误？</li><li>坑1：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mydb *sql.DB<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    mydb, err := sql.Open(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;there is dsn statement&quot;</span>) <span class="hljs-comment">// 此时:=相当于给变量mydb在局部进行声明并初始化，后续调用mydb会抛出空指针异常</span><br>    mydb, _ = sql.Open(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;there is dsn statement&quot;</span>) <span class="hljs-comment">// 正确的写法</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://github.com/go-sql-driver/mysql/wiki/Examples">go-sql-driver:Examples</a></li><li><a href="http://go-database-sql.org/">Go database/sql tutorial</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP请求</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/go-webservices/http_request/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/go-webservices/http_request/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTTP协议是一个<strong>无状态</strong>，基于<strong>客户端-服务端</strong>的<strong>请求-响应</strong>协议。</p><p>客户端和服务端是通过HTTP请求和HTTP响应进行数据的传输的。</p><p>HTTP请求：客户端请求获取服务端的特定数据。对应的请求报文格式如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode">请求行<span class="hljs-comment">(request-line)</span><br><br>若干个请求首部<span class="hljs-comment">(header)</span><br><br>一个空行<br><br>报文主体<span class="hljs-comment">(body，可选)</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0<br><br><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>GET /index.html HTTP/1.1</code>为请求行，<code>GET</code>为请求方法(request method)，<code>/index.html</code>为统一资源标识符(Uniform Resource Identifier, URI)，<code>HTTP/1.1</code>为HTTP版本。</li><li><code>Host: www.example.com User-Agent: Mozilla/5.0</code>为请求首部。用于标识用户信息和请求信息。</li></ul><hr><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>请求方法定义了对于特定资源的操作方式。主要有以下几种：<br>|请求方法|作用|<br>|—|—|<br>|<code>GET</code>|返回指定的资源|<br>|<code>HEAD</code>|返回响应的首部，不要求报文的主体|<br>|<code>POST</code>|将报文的主体中的数据传输到URI指定的资源|<br>|<code>PUT</code>|将报文主体中的数据设置为URI指定的资源|<br>|<code>DELETE</code>|删除URI指定的资源|<br>|<code>TRACE</code>|返回请求本身|<br>|<code>OPTIONS</code>|返回服务器支持的HTTP方法列表|<br>|<code>CONNECT</code>|服务器和客户端建立一个网络连接|<br>|<code>PATCH</code>|使用报文主体中的数据修改URI指定的资源|</p><h3 id="请求方法的特性"><a href="#请求方法的特性" class="headerlink" title="请求方法的特性"></a>请求方法的特性</h3><ul><li>安全性：若请求方法不会对服务器的状态进行修改，则该方法是安全的。<code>GET</code>、<code>HEAD</code>、<code>TRACE</code>、<code>OPTIONS</code>是安全的，<code>POST</code>、<code>PUT</code>、<code>DELETE</code>不是安全的。</li><li><code>幂等性</code>：若一个HTTP方法在使用相同的数据进行第二次调用时不会对服务器的状态造成改变，则该方法是幂等的(idempotent)。所有安全的方法都是幂等的，<code>PUT</code>和<code>DELETE</code>虽然不安全，但是幂等的。第二次调用不会修改服务器的状态。<code>POST</code>不是幂等的。</li></ul><hr><h2 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h2><p>请求首部记录了与请求本身以及客户端有关的信息。</p><ul><li>使用多行键值对表示，每个键值对使用:分隔。</li><li>“Host”首部字段是必须的，其他字段可选。</li><li>若有主体部分，请求首部还需要“Content-Lenght”(内容长度)和“Transfer-Encoding”(传输编码)。</li></ul><p>常见的请求首部字段：<br>|首部字段|用途|<br>|—|—|<br>|<code>Accept</code>|客户端在响应中能接收的内容类型。<code>text/html</code>表示希望接收HTML类型的内容|<br>|<code>Accept-Charset</code>|客户端要求的字符集编码。<code>utf-8</code>表示主体使用UTF-8字符集|<br>|<code>Cookie</code>|客户端再次请求时需要带上服务器发送的Cookie，用于标识客户端|<br>|<code>Content-Length</code>|请求主体的字节长度|<br>|<code>Content-Type</code>|主体内容的类型，POST或PUT一般为<code>x-www-form-urlen-coded</code>，上传文件一般为<code>multipart/form-data</code>|<br>|<code>Host</code>|服务器名称和端口号|<br>|<code>Referrer</code>|发起请求的页面地址|<br>|<code>User-Agent</code>|客户端描述|</p><hr><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP响应</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/go-webservices/http_response/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/go-webservices/http_response/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTTP响应报文是对HTTP请求报文的回复。主要格式为：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode">状态行<br><br>若干个响应首部<br><br>一个空行<br><br>报文主体<span class="hljs-comment">(可选)</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">200</span> OK<br><span class="hljs-attribute">date</span>: Mon, <span class="hljs-number">25</span> Oct <span class="hljs-number">2021</span> <span class="hljs-number">04</span>:<span class="hljs-number">49</span>:<span class="hljs-number">43</span> GMT<br><span class="hljs-attribute">content</span>-type: text/html; charset=utf-<span class="hljs-number">8</span><br><br><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>200 OK</code>：状态行，包含状态码(status code)和原因短语(reason phrase)。</li><li><code>date: Mon, 25 Oct 2021 04:49:43 GMT content-type: text/html; charset=utf-8</code>：响应首部。包含服务器信息和响应报文信息。</li><li>报文主体：报文的主要内容。</li></ul><hr><h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p>响应状态码表示响应的类型，主要分为五种：<br>|状态码类型|描述|<br>|—|—|<br>|1XX|表明服务器已接收请求并已对请求进行处理|<br>|2XX|成功状态码。服务器已经收到并处理客户端的请求|<br>|3XX|重定向状态码。服务器接收并处理客户端的请求，需要客户端后续动作，一般用于URL重定向|<br>|4XX|客户端错误状态码。客户端发送请求出现问题|<br>|5XX|服务器错误状态码。服务器无法正确处理请求|</p><hr><h2 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h2><ul><li>多行键值对，使用冒号:分割键与值。</li><li>用于告知客户端响应相关与服务器的信息。</li></ul><table><thead><tr><th>首部字段</th><th>作用</th></tr></thead><tbody><tr><td><code>Allow</code></td><td>服务器的请求方法</td></tr><tr><td><code>Content-Length</code></td><td>响应主体的字节长度</td></tr><tr><td><code>Content-Type</code></td><td>主体内容的类型</td></tr><tr><td><code>Date</code></td><td>当前时间</td></tr><tr><td><code>Location</code></td><td>用于重定向，告知客户端后续访问的URL</td></tr><tr><td><code>Server</code></td><td>返回响应的服务器域名</td></tr><tr><td><code>Set-Cookie</code></td><td>在客户端中设置cookie</td></tr></tbody></table><hr><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>URI(Uniform Resource Identifier, 统一资源标识符)：使用一个唯一的字符序列标识网络资源。主要由两种：</p><ul><li>URN(Uniform Resource Name, 统一资源名称)：使用字符串表示资源名字。</li><li>URL(Uniform Resource Location, 统一资源定位符)：使用字符串表示资源所在的位置。</li></ul><p>URI的一般格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;方案名称&gt;</span>:<span class="hljs-attribute">&lt;分层部分&gt;</span>[? <span class="hljs-attribute">&lt;查询参数&gt;</span>][#<span class="hljs-attribute">&lt;片段&gt;</span>]<br></code></pre></td></tr></table></figure><blockquote><p>URI本质上是一种对于网络资源的<strong>命名规则</strong>。<br>URI有许多实现的方案，最常用的是<strong>HTTP</strong></p></blockquote><h3 id="URI的分层部分-hierarchical-part"><a href="#URI的分层部分-hierarchical-part" class="headerlink" title="URI的分层部分(hierarchical part)"></a>URI的分层部分(hierarchical part)</h3><ul><li>包含资源识别信息，以<strong>分层方式</strong>方式进行组织。</li><li>分层部分使用“双斜线//”开头，“@”符号结尾表示可选的用户信息。</li><li>用户信息后面跟分层路径，路径是由一连串的分段(segment)组成，不同分段之间使用单斜线“/”分隔。</li><li>问号?后接查询参数(query)，多个查询参数被组织成一连串的键值对，不同的键值对之间使用&amp;分隔。</li></ul><p>一个URL示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.example.com/docs?name=haha&amp;id=<span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>http</code>：使用的协议为HTTP协议。</li><li><code>www.example.com/docs</code>：目标主机为<a href="http://www.example.com,目标资源路径为`/docs%60%E3%80%82%E6%9C%AA%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%B8%BA80%E3%80%82">www.example.com，目标资源路径为`/docs`。未指定端口，默认为80。</a></li><li><code>name=haha&amp;id=123</code>：查询参数为<code>name=haha</code>，<code>id=123</code>。</li></ul><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><p>由于URL为一连串字符，所以不能存在空格，并且?和#为保留符号，所以不能用作URL中的查询参数。一些特殊的字符(如中文)无法直接表示，所以需要对URL进行编码。</p><p>编码规则：</p><ul><li>对于保留字符进行URL编码，非保留字符可以直接保存。</li><li>将保留字符转换为对应的ASCII编码，然后将字节值表示为两位长的十六进制数字，在这个十六进制数字前添加百分号%。</li></ul><p>示例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">你 =<span class="hljs-function">=&gt;</span> 对应的ASCII码为E4 BD A0<br>添加百分号后 =<span class="hljs-function">=&gt;</span> %E4%BD%A0<br><br>空格 =<span class="hljs-function">=&gt;</span> <span class="hljs-number">20</span><br>添加百分号 =<span class="hljs-function">=&gt;</span> %<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Web应用</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/go-webservices/web_application/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/golang/go-webservices/web_application/</url>
    
    <content type="html"><![CDATA[<h1 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Web应用工作基本流程：</p><ol><li>通过HTTP协议，通过HTTP请求报文获取客户端输入。</li><li>对HTTP请求报文进行处理。</li><li>生成HTML，并以HTTP响应报文的形式将返回给客户端。</li></ol><p>Web应用被分为两个部分：</p><ul><li>处理器(Handler)</li><li>模板引擎(template engine)</li></ul><hr><h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><blockquote><p>作用：接收、处理客户端发送的请求，调用模板引擎。</p></blockquote><p>基于MVC模式，则处理器是控制器(controller)和模型(model)。<br>理想情况下，控制器只包含<strong>路由(routing)和HTTP报文的解包和打包逻辑</strong>。模型包含应用的逻辑和数据。为了代码复用，一般采用服务对应(service object)对模型进行操作。相同的逻辑放在服务对象里，不同的模型使用相同的服务对象。</p><hr><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><blockquote><p>作用：通过模板和数据生成最终的HTML并返回给客户端。</p></blockquote><h3 id="模板分类"><a href="#模板分类" class="headerlink" title="模板分类"></a>模板分类</h3><ul><li>静态模板：夹杂占位符的HTML，模板引擎通过将占位符替换成对应的数据生成最终的HTML。基本不包含逻辑嗲吗。</li><li>动态模板：除了占位符和HTML外，还包含编程语言结构，如条件语句、迭代语句等。</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>注解</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/annotations/BasicsAnnotation/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/annotations/BasicsAnnotation/</url>
    
    <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>[toc]</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>是一种元数据（metadata），给应用提供非程序的数据。不对注解的代码的行为产生直接的影响。</li><li>用法：<ul><li>编译器的信息：检测error或忽视warning。</li><li>编译时或部署时信息：可以利用注解生成代码或xml文件。</li><li>运行时处理：可以在运行时进行检查。</li></ul></li></ul><hr><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>前面是标识符@，后面跟着对应的注解信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br></code></pre></td></tr></table></figure><ul><li>注解中可以包含信息：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Author(</span><br><span class="hljs-meta">  name=&quot;zhangsan&quot;,</span><br><span class="hljs-meta">  date=&quot;2021/1/1&quot;</span><br><span class="hljs-meta">)</span><br><br><span class="hljs-comment">// 若只有一个元素，则为</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br></code></pre></td></tr></table></figure></li><li>可以同时具有多个注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Author(name=&quot;zhangsan&quot;)</span><br><span class="hljs-meta">@EBook</span><br></code></pre></td></tr></table></figure></li><li>相同类型的注解可以重复出现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Author(name=&quot;zhangsan&quot;)</span><br><span class="hljs-meta">@Author(name=&quot;lisi&quot;)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="注解使用位置"><a href="#注解使用位置" class="headerlink" title="注解使用位置"></a>注解使用位置</h3><ul><li>创建实例时：<code>new @Interned MyObject();</code></li><li>类型转换：<code>myString = (@NonNull String) str;</code></li><li><code>implements</code>语句：<code>implements @Readonly List&lt;@Readonly T&gt;</code></li><li><code>thrown</code>语句：<code>throws @Critical TemperatureException</code></li></ul><hr><h2 id="预定义的注解类型"><a href="#预定义的注解类型" class="headerlink" title="预定义的注解类型"></a>预定义的注解类型</h2><ul><li>预定义的注解中一些被编译器使用，一些是可以用于其他注解。</li></ul><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td><code>@Deprecated</code></td><td>标记注解的元素不再使用</td></tr><tr><td><code>@Override</code></td><td>注解的元素是对父类对应元素的重写</td></tr><tr><td><code>@SuppressWarnings</code></td><td>使得编译器不抛出特定的warning</td></tr><tr><td><code>@SafeVarargs</code></td><td>表示方法或构造器不会使用不安全的参数</td></tr><tr><td><code>@FunctionalInterface</code></td><td>声明的元素为函数式接口</td></tr></tbody></table><h3 id="用于其他注解的元注解（meta-annotations）"><a href="#用于其他注解的元注解（meta-annotations）" class="headerlink" title="用于其他注解的元注解（meta-annotations）"></a>用于其他注解的元注解（meta-annotations）</h3><table><thead><tr><th>注解</th><th>功能</th></tr></thead><tbody><tr><td><code>@Retention</code></td><td>表示被指定的注解如何存储</td></tr><tr><td><code>@Documented</code></td><td>表明指定的注解可以生成Javadoc</td></tr><tr><td><code>@Target</code></td><td>表明指定的注解可以用于何处</td></tr><tr><td><code>@Inherited</code></td><td>表示注解类型可以继承，若子类没有对应，则从父类查询对应的注解</td></tr><tr><td><code>@Repeatable</code></td><td>表示在相同的声明中可以重复使用该注解</td></tr></tbody></table><blockquote><p>注意：</p><ol><li><code>@Retenttion</code>注解中可以指定如下三种值：<ol><li><code>RetentionPolicy.SOURCE</code>：注解只保留在源码中。</li><li><code>RetentionPolicy.CLASS</code>：注解保留在编译期，在JVM中会被忽视。</li><li><code>RetentionPolicy.RUNTIME</code>：注解可以用于运行时环境。</li></ol></li><li><code>@Target</code>的值可以为：<ol><li><code>ElementType.ANNOTATION_TYPE</code>：可以用于其他的注解。</li><li><code>ElementType.CONSTRUCTOR</code>：可以用于构造器。</li><li><code>ElementType.FIELD</code>：用于域或属性。</li><li><code>ElementType.LOCAL_VARIABLE</code>：用于本地变量。</li><li><code>ElementType.METHOD</code>：用于方法。</li><li><code>ElementType.PACKAGE</code>：用于包声明。</li><li><code>ElementType.PARAMETER</code>：用于一个方法中的参数。</li><li><code>ElementType.TYPE</code>：用于一个类中任意元素。</li></ol></li></ol></blockquote><hr><h2 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h2><p>重复注解需要存储在一个容器注解中，定义一个可重复的注解，需要遵循如下步骤：</p><ol><li><p>定义一个可重复注解类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repeatable(Apps.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> App &#123;<br><span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义对应的容器注解：（注意：容器类必须有<code>value()</code>方法，并且返回值类型为对应元素的数组）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Apps &#123;<br>App[] value();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以使用定义的<code>@App</code>进行注解。</p></li></ol><h3 id="获取注解"><a href="#获取注解" class="headerlink" title="获取注解"></a>获取注解</h3><ol><li>可以通过<code>AnnotatedElement.getAnnotation(Class&lt;T&gt;)</code>获取一个注解。</li><li>使用<code>AnnotatedElement.getAnnotationByType(Class&lt;T&gt;)</code>可以通过容器注解获得多个注解。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/annotations/index.html">Lesson: Annotations</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>通过注解实现自定义的自动注入</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/annotations/autowiredbyannotation/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/annotations/autowiredbyannotation/</url>
    
    <content type="html"><![CDATA[<h1 id="通过注解实现自定义的自动注入"><a href="#通过注解实现自定义的自动注入" class="headerlink" title="通过注解实现自定义的自动注入"></a>通过注解实现自定义的自动注入</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Spring中，可以通过<code>Autowired</code>注解实现对于成员变量的自动注入。<br>而实现注解自动注入其实很简单，以下通过一个简单的示例说明如何利用注解和反射实现自动注入。</p><hr><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>基本原理：</p><ul><li>通过反射获取指定对象的所有成员变量</li><li>检查该成员变量是否存在注解。若存在指定注解则进入下一步</li><li>获取成员变量上的注解，并获取注解上的值。</li><li>将指定对象中成员变量设置为注解的值。</li></ul><p>注解类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Autowired &#123;<br>    <br>    <span class="hljs-function">String <span class="hljs-title">key</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">def</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><code>@Target</code>注解表示该注解可以用于哪些地方。如：域变量，方法，类等。</li><li><code>Retention</code>注解表示该注解的生命周期，是在运行时还是编译期保存。</li></ul><p>配置类(通过反射从注解中获取值并填入到对象中对应的变量)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Configuration</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">autowired</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;<br>        Field[] fields = o.getClass().getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field f : fields) &#123;<br>            f.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">if</span> (f.isAnnotationPresent(Autowired.class)) &#123;<br>                Autowired a = f.getAnnotation(Autowired.class);<br>                f.set(o, a.key());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired(key=&quot;mytest&quot;)</span><br><span class="hljs-keyword">private</span> String myKey;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        App app = <span class="hljs-keyword">new</span> App();<br>        Configuration.autowired(app);<br>        System.out.println(app.myKey);<br>&#125;<br><br><span class="hljs-comment">// output: mytest</span><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://markey.cc/2019/02/16/SpringBoot%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%8F%8D%E5%B0%84%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%89/">自定义注解注入属性值（基于反射和静态变量）</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java参数命名小结</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/argsname/JavaArgsName/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/argsname/JavaArgsName/</url>
    
    <content type="html"><![CDATA[<h1 id="Java参数命名小结"><a href="#Java参数命名小结" class="headerlink" title="Java参数命名小结"></a>Java参数命名小结</h1><p>[toc]</p><hr><h2 id="参数命名"><a href="#参数命名" class="headerlink" title="参数命名"></a>参数命名</h2><table><thead><tr><th>类型</th><th>参数名</th></tr></thead><tbody><tr><td><code>Class</code></td><td><code>cls</code></td></tr><tr><td>参数</td><td><code>par</code>/<code>param</code>/<code>arg</code></td></tr><tr><td><code>Method</code></td><td><code>meth</code></td></tr><tr><td><code>Object</code></td><td><code>obj</code></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java中的类初始化顺序</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/class/class_initialization/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/class/class_initialization/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中的类初始化顺序"><a href="#Java中的类初始化顺序" class="headerlink" title="Java中的类初始化顺序"></a>Java中的类初始化顺序</h1><p>[toc]</p><hr><p>顺序：</p><ul><li>先父类，再子类。</li><li>先成员变量，再构造器。</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>枚举类（Enum）</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/enum/enum/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/enum/enum/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举类（Enum）"><a href="#枚举类（Enum）" class="headerlink" title="枚举类（Enum）"></a>枚举类（Enum）</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>定义一些预先定义的常量，变量必须等于预先定义的值之一。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/enum.htmle">Enum Types</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Basic I/O</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/io/BasicIO/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/io/BasicIO/</url>
    
    <content type="html"><![CDATA[<h1 id="Basic-I-O"><a href="#Basic-I-O" class="headerlink" title="Basic I/O"></a>Basic I/O</h1><p>[toc]</p><hr><h2 id="I-O流（I-O-stream）"><a href="#I-O流（I-O-stream）" class="headerlink" title="I/O流（I/O stream）"></a>I/O流（I/O stream）</h2><ul><li>一个I/O流（I/O Stream）表示一系列数据。可以是输入或输出的数据。数据的形式可以为多种：磁盘文件、设备、程序等等。</li><li>任何实体都可能生成、持有和消费I/O流。</li></ul><h3 id="字节流（Byte-Streams）"><a href="#字节流（Byte-Streams）" class="headerlink" title="字节流（Byte Streams）"></a>字节流（Byte Streams）</h3><ul><li>所有字节流类都继承自<code>InputStream</code>或<code>OutputStream</code>。</li><li><code>FileInputStream</code>：从一个文件中获取输入的字节数据。</li><li>注意：当不使用一个流时，一定要及时将流关闭，避免产生内存泄漏。通常在<code>finally</code>语句中保证流的关闭。</li><li>避免使用<em>Byte Stream</em>，其作为底层I/O操作。</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">String inFilePath = <span class="hljs-string">&quot;src/in&quot;</span>, outFilePath = <span class="hljs-string">&quot;src/out&quot;</span>;<br>FileInputStream fInputStream = <span class="hljs-keyword">null</span>;<br>FileOutputStream fOutputStream = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>    fInputStream = <span class="hljs-keyword">new</span> FileInputStream(inFilePath);<br>    fOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(outFilePath);<br>    <span class="hljs-keyword">int</span> c;<br>    <span class="hljs-comment">// 一个字节一个字节地获取数据</span><br>    <span class="hljs-keyword">while</span> ((c = fInputStream.read()) != -<span class="hljs-number">1</span>) &#123;<br>        fOutputStream.write(c);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (fInputStream != <span class="hljs-keyword">null</span>) fInputStream.close();<br>    <span class="hljs-keyword">if</span> (fOutputStream != <span class="hljs-keyword">null</span>) fOutputStream.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符流（Character-Streams）"><a href="#字符流（Character-Streams）" class="headerlink" title="字符流（Character Streams）"></a>字符流（Character Streams）</h3><ul><li>Java中使用Unicode存储字符，而字符流可以自动实现本地字符集和Unicode的转换。</li><li><code>FileReader</code>的继承关系：<code>FileReader</code> –&gt; <code>InputStreamReader</code> –&gt; <code>Reader</code>。<ul><li><code>Reader</code>：读取字符流的抽象类。</li><li><code>InputStreamReader</code>：用于字节流到字符流的转换。读取字节并使用特定的字符集解码成对应的字符。</li><li><code>FileReader</code>：使用默认的缓存从字符文件中读取数据。通过调用<code>FileInputStream</code>通过字节流方式执行I/O操作。</li></ul></li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">FileReader reader = <span class="hljs-keyword">null</span>;<br>FileWriter writer = <span class="hljs-keyword">null</span>;<br>String inPath = <span class="hljs-string">&quot;com.xiaomi.iostream/src/in&quot;</span>, outPath = <span class="hljs-string">&quot;com.xiaomi.iostream/src/out&quot;</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>    reader = <span class="hljs-keyword">new</span> FileReader(inPath);<br>    writer = <span class="hljs-keyword">new</span> FileWriter(outPath);<br>    <span class="hljs-keyword">int</span> c;<br>    <span class="hljs-keyword">while</span> ((c = reader.read()) != - <span class="hljs-number">1</span>) &#123;<br>        writer.write(c);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (reader != <span class="hljs-keyword">null</span>) reader.close();<br>    <span class="hljs-keyword">if</span> (writer != <span class="hljs-keyword">null</span>) writer.close();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>逐行进行I/O操作</strong></p><ul><li>通过使用<code>\r</code>，<code>\n</code>或者两者组合进行分行。</li></ul><hr><h2 id="缓冲流（Buffered-Stream）"><a href="#缓冲流（Buffered-Stream）" class="headerlink" title="缓冲流（Buffered Stream）"></a>缓冲流（Buffered Stream）</h2><ul><li>非缓冲流为每次读写操作都会引起操作系统的I/O操作，涉及到磁盘读写、网络活动等，效率低。</li><li>缓冲流在内存中一个叫缓存（cache）的地方进行读写操作。只有在缓存为空或为满时才引起底层的I/O操作。</li><li>通过缓存流对非缓存流进行包装，可以将其转换为缓存流。主要有四种类：<ul><li><code>BufferedInputStream</code>：读取字节流</li><li><code>BufferedOutputStream</code></li><li><code>BufferedReader</code>：读取字符流</li><li><code>BufferedWriter</code></li></ul></li></ul><h3 id="刷新（flush）"><a href="#刷新（flush）" class="headerlink" title="刷新（flush）"></a>刷新（flush）</h3><p>默认情况下，只有当缓存已满时才触发刷新操作，将缓存中的数据保存到磁盘中。而通过调用<code>flush()</code>方法可以手动触发刷新操作。</p><hr><h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>若需要将格式化的数据进行切分成独立的组合，并根据数据格式进行类型转换。则可以使用<code>Scanner</code>类。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Scanner scanner = <span class="hljs-keyword">null</span>;<br>String inPath = <span class="hljs-string">&quot;scranner\\src\\main\\java\\com\\xiaomi\\in&quot;</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    scanner = <span class="hljs-keyword">new</span> Scanner(<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(inPath)));<br>    <span class="hljs-comment">// scanner.useDelimiter(&quot;\\s+&quot;); // 可以指定特定的分隔符模式</span><br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        <span class="hljs-comment">// 读取数据中的double数据</span><br>        <span class="hljs-keyword">if</span> (scanner.hasNextDouble()) System.out.println(scanner.nextDouble());<br>        <span class="hljs-keyword">else</span> scanner.next();<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> handle exception</span><br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (scanner != <span class="hljs-keyword">null</span>) scanner.close();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="格式化（formatting）"><a href="#格式化（formatting）" class="headerlink" title="格式化（formatting）"></a>格式化（formatting）</h2><ul><li>流的格式化使用的<code>PrintWriter</code>或<code>PrintStream</code>，其中<code>PrintWriter</code>是针对字符流，<code>PrintStream</code>是针对字节流。</li><li>一般是<code>System.out</code>或<code>System.err</code>方法内部调用<code>PrintStream</code>的<code>write()</code>方法。</li><li><code>format()</code>方法使用特定的格式限定符%将数据填充到特定位置。</li><li>“%1$+020.10f”：1$：指定第一个参数，+0：使用+作为前缀，使用0填充剩余部分，20：字符总长度，.10：小数部分为10位。<br><img src="../../../imgs/formatspec.jpg"></li></ul><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>%d</td><td>十进制整数</td></tr><tr><td>%f</td><td>十进制浮点数</td></tr><tr><td>%n</td><td>换行符</td></tr><tr><td>%x</td><td>十六进制整数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%tB</td><td>月数</td></tr></tbody></table><hr><h2 id="与命令行的I-O"><a href="#与命令行的I-O" class="headerlink" title="与命令行的I/O"></a>与命令行的I/O</h2><ul><li>通过<code>System.in</code>访问标准输入流。</li><li>通过<code>System.out</code>访问标准输出流。</li><li>通过<code>System.err</code>访问标准错误流。</li><li><code>System.in</code>是一个字节流。若需要使用字符流，可以：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStreamReader cin = <span class="hljs-keyword">new</span> InputStreamReader(System.in);<br></code></pre></td></tr></table></figure></li></ul><p>若要与控制台（console）交互，需要先获取<code>Console</code>对象，然后进行后续的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Console console = System.console();<br>String id = console.readLine(<span class="hljs-string">&quot;请输入账户&quot;</span>);<br><span class="hljs-keyword">char</span>[] pwd = console.readPassword(<span class="hljs-string">&quot;请输入密码&quot;</span>); <span class="hljs-comment">// 专门用于读取密码</span><br></code></pre></td></tr></table></figure><hr><h2 id="数据流（Data-Stream）"><a href="#数据流（Data-Stream）" class="headerlink" title="数据流（Data Stream）"></a>数据流（Data Stream）</h2><ul><li>数据流支持Java中的基本数据类型以及String类型。</li><li>所有的数据流都继承自<code>DataInput</code>或<code>DataOutput</code>。</li><li>针对不同的数据类型，可以使用不同的方法进行读写。</li></ul><table><thead><tr><th>数据类型</th><th>读写方法</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>readInt()</code>/<code>writeInt()</code></td></tr><tr><td><code>double</code></td><td><code>readDouble()</code>/<code>writeDouble()</code></td></tr><tr><td><code>String</code></td><td><code>readUTF()</code>/<code>writeUTF()</code></td></tr></tbody></table><p>示例：<br>通过<code>DataOutputStream</code>写出数据，通过<code>DataInputStream</code>写入数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String outPath;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span>[] prices = &#123; <span class="hljs-number">19.99</span>, <span class="hljs-number">9.99</span>, <span class="hljs-number">15.99</span>, <span class="hljs-number">3.99</span>, <span class="hljs-number">4.99</span> &#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] units = &#123; <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">29</span>, <span class="hljs-number">50</span> &#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] descs = &#123;<br><span class="hljs-string">&quot;Java T-shirt&quot;</span>,<br><span class="hljs-string">&quot;Java Mug&quot;</span>,<br><span class="hljs-string">&quot;Duke Juggling Dolls&quot;</span>,<br><span class="hljs-string">&quot;Java Pin&quot;</span>,<br><span class="hljs-string">&quot;Java Key Chain&quot;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeAndRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>    outPath = <span class="hljs-string">&quot;src\\main\\java\\com\\xiaomi\\in.md&quot;</span>;<br>    DataInputStream inStream = <span class="hljs-keyword">null</span>;<br>    DataOutputStream outStream = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        outStream = <span class="hljs-keyword">new</span> DataOutputStream(<span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(outPath)));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; ++i) &#123;<br>            outStream.writeDouble(prices[i]);<br>            outStream.writeInt(units[i]);<br>            outStream.writeUTF(descs[i]);<br>        &#125;<br>        outStream.flush();<br><br>        inStream = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(outPath)));<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                System.out.println(inStream.readDouble() + <span class="hljs-string">&quot; &quot;</span> + inStream.readInt() + inStream.readUTF());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (EOFException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> handle exception</span><br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (inStream != <span class="hljs-keyword">null</span>) inStream.close();<br>        <span class="hljs-keyword">if</span> (outStream != <span class="hljs-keyword">null</span>) outStream.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="对象流（Object-Streams）"><a href="#对象流（Object-Streams）" class="headerlink" title="对象流（Object Streams）"></a>对象流（Object Streams）</h2><ul><li>Java中的对象流支持对对象的I/O操作。支持序列化的对象（实现<code>Serializable</code>接口的类）。</li><li><code>ObjectInputstream</code>和<code>ObjectOutputStream</code>是两个主要用于对对象读写的流，其继承自<code>ObjectInput</code>和<code>ObjectOutput</code>，而这两个类又是<code>DataInput</code>和<code>DataOutput</code>类的子类。所以对于基本数据类型的读写操作也可以用于对象流中。</li><li><code>readObject()</code>方法返回的对象可以通过转型变换到对应的类型。</li><li>若进行读写的对象中包含其他对象的引用，则这些引用的对象同样也会进行读写操作。从而对一个对象的读写可能导致多个对象的读写。</li><li>若在一个流中对同一个对象进行多次读写，则多个引用会指向同一个对象。</li><li>若在多个流中对同一个对象进行读写，则每个流中会生成单独的一个对象。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        ObjectOutputStream oos = <span class="hljs-keyword">null</span>;<br>        ObjectInputStream ois = <span class="hljs-keyword">null</span>;<br>        String path = <span class="hljs-string">&quot;src//main//java//io//github//in&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(path)));<br>            MyClass c = <span class="hljs-keyword">new</span> MyClass();<br>            oos.writeObject(c);<br>            oos.flush();<br>            MyClass c1 = <span class="hljs-keyword">null</span>;<br>            ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(path)));<br>            c1 = (MyClass) ois.readObject();<br>            System.out.println(c1);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">catch</span>( ClassNotFoundException cnfe) &#123;<br>            cnfe.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (oos != <span class="hljs-keyword">null</span>) oos.close();<br>            <span class="hljs-keyword">if</span> (ois != <span class="hljs-keyword">null</span>) ois.close(); <br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br>    String s = <span class="hljs-string">&quot;MyClass&quot;</span>;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">12345</span>;<br>    <span class="hljs-keyword">double</span> d = <span class="hljs-number">12.42</span>;<br>    MyClass1 myClass1 = <span class="hljs-keyword">new</span> MyClass1();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s + i + d + myClass1.toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">54321</span>;<br>    <span class="hljs-keyword">long</span> l = <span class="hljs-number">123123l</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> i1 + <span class="hljs-string">&quot; &quot;</span> + l;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/index.html">Lesson: Basic I/O</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文件系统概念介绍</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/io/FileSystem/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/io/FileSystem/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统概念介绍"><a href="#文件系统概念介绍" class="headerlink" title="文件系统概念介绍"></a>文件系统概念介绍</h1><p>[toc]</p><blockquote><p>文件系统是对文件进行存储、组织和提取。<br>大多数的文件系统是呈现树状结构，数中的节点是由文件和文件夹组成。文件夹中可能包含多个文件和子文件夹，从而构成树状结构。</p></blockquote><hr><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><ul><li>路径是文件在文件系统中的唯一标识。</li><li>路径一般分为两种：<ul><li>绝对路径：从根目录开始的路径。是在文件系统中唯一确定文件的方式。</li><li>相对路径：需要与其他路径组合达到唯一确定文件。（例如：不同项目中可以包含同名文件，其相对路径相同，但绝对路径不同）</li></ul></li></ul><hr><h2 id="软链接（符号链接，soft-link）和硬链接（hard-link）"><a href="#软链接（符号链接，soft-link）和硬链接（hard-link）" class="headerlink" title="软链接（符号链接，soft link）和硬链接（hard link）"></a>软链接（符号链接，soft link）和硬链接（hard link）</h2><p>硬链接与软链接的对比：</p><table><thead><tr><th>对比</th><th>硬链接</th><th>软链接</th></tr></thead><tbody><tr><td>通过链接编辑</td><td>目标文件</td><td>目标文件</td></tr><tr><td>指向文件夹</td><td>❌</td><td>✔</td></tr><tr><td>指向文件</td><td>✔</td><td>✔</td></tr><tr><td>指向其他分区的文件</td><td>❌</td><td>✔</td></tr><tr><td>指向网络文件</td><td>❌</td><td>✔</td></tr><tr><td>指向打印机</td><td>❌</td><td>❌</td></tr><tr><td>使用相对路径</td><td>❌</td><td>✔</td></tr><tr><td>删除链接即删除文件</td><td>✔</td><td>❌</td></tr><tr><td>类型</td><td>文件</td><td>NTFS重解析点</td></tr></tbody></table><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://sites.google.com/site/freeavvarea/hardlink-softlink-en">Hardlinks, Softlinks</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java中IO类的继承关系</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/io/IOInheritance/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/io/IOInheritance/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中IO类的继承关系"><a href="#Java中IO类的继承关系" class="headerlink" title="Java中IO类的继承关系"></a>Java中IO类的继承关系</h1><p>TODO..</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Path 类</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/io/PathClass/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/io/PathClass/</url>
    
    <content type="html"><![CDATA[<h1 id="Path-类"><a href="#Path-类" class="headerlink" title="Path 类"></a>Path 类</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><code>Path</code>类是对文件系统中路径的对象表示。</li><li><code>Path</code>类与运行的平台有关，即使文件的相对路径相同，不同平台的<code>Path</code>实例也不同。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>行为参数化</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/lambdaexpression/behaviorparameterization/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/lambdaexpression/behaviorparameterization/</url>
    
    <content type="html"><![CDATA[<h1 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h1><p>[toc]</p><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>用于应对频繁更改的需求，通过将代码块传递给其他的方法，实现拼凑组合成目标方法。</li><li>类似于策略模式，通过对策略的抽象，应用不同的算法实现不同的目标。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li>定义一个数据类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> weight;<br>    <span class="hljs-keyword">boolean</span> isRed;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Apple</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight, <span class="hljs-keyword">boolean</span> isRed)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.weight = weight;<br>        <span class="hljs-keyword">this</span>.isRed = isRed;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Apple : weight : &quot;</span> + weight + <span class="hljs-string">&quot;, isRed : &quot;</span> + isRed;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>定义策略接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplePredicate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple a)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>定义不同的策略实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleWeightPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplePredicate</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple a)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.weight &lt; <span class="hljs-number">100</span>;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleGreenPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplePredicate</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple a)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !a.isRed;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>应用策略<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Apple&gt; <span class="hljs-title">filter</span><span class="hljs-params">(List&lt;Apple&gt; appleList, ApplePredicate ap)</span> </span>&#123;<br>List&lt;Apple&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span> (Apple a : appleList) &#123;<br>    <span class="hljs-keyword">if</span> (ap.test(a)) ans.add(a);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h2><ol><li>使用匿名类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Apple&gt; ans = filter(appleList, <span class="hljs-keyword">new</span> ApplePredicate() &#123;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple a)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a.weight &gt;= <span class="hljs-number">100</span>;<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li>使用lambda表达式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Apple&gt; ans = filter(appleList, (Apple a) -&gt; a.weight &gt;= <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="进一步抽象"><a href="#进一步抽象" class="headerlink" title="进一步抽象"></a>进一步抽象</h3><p>使用泛型使得方法适用于不同的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyPredicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(List&lt;T&gt; tList, MyPredicate&lt;T&gt; predicate)</span> </span>&#123;<br>List&lt;T&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span> (T t : tList) &#123;<br>    <span class="hljs-keyword">if</span> (predicate.test(t)) ans.add(t);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java8入门介绍</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/lambdaexpression/java8introduction/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/lambdaexpression/java8introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="Java8入门介绍"><a href="#Java8入门介绍" class="headerlink" title="Java8入门介绍"></a>Java8入门介绍</h1><p>[toc]</p><hr><h2 id="Java8的新特性"><a href="#Java8的新特性" class="headerlink" title="Java8的新特性"></a>Java8的新特性</h2><ul><li>Stream API</li><li>向方法中传递代码 –&gt; 行为参数化 –&gt; 将不同的行为作为参数进行传递 –&gt; 函数式编程：被称为函数的代码作为参数传递从而组合成不同的逻辑的方法</li><li>接口中的默认方法</li></ul><hr><h2 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h2><ul><li>流：一系列数据项，一次只产生一项。</li><li>程序从输入流中一个一个读取数据项，再一个一个将数据项写入到输出流。</li><li>一个程序的输出流可以是另一个程序的输入流。</li></ul><hr><h2 id="用行为参数化将代码传递给方法"><a href="#用行为参数化将代码传递给方法" class="headerlink" title="用行为参数化将代码传递给方法"></a>用行为参数化将代码传递给方法</h2><p>将行为作为参数进行传递，通过拼凑不同的行为使得代码实现不同的功能。</p><hr><h2 id="并行与共享的可变数据"><a href="#并行与共享的可变数据" class="headerlink" title="并行与共享的可变数据"></a>并行与共享的可变数据</h2><p>只要保证函数为“纯函数”（或称“无状态函数”），不访问共享的可变数据，即可以毫不费力的实现并行操作。</p><blockquote><p>避免使用<code>synchronized</code>等锁操作实现纯函数，这会导致所有的并行化毫无意义。</p></blockquote><hr><h2 id="Java中的函数"><a href="#Java中的函数" class="headerlink" title="Java中的函数"></a>Java中的函数</h2><ul><li>函数一般指方法（特别是静态方法，无状态的方法）。</li><li>一般情况下编程语言是围绕着数据运行的，无论是方法还是类。方法、类等概念是为数据提供服务的。方法作为一个完整单位为数据提供特定的功能。</li><li>若将方法进一步分割，将方法作为参数在其他的方法中传递和组合，可以提供方法的复用性，减少冗余的代码。</li></ul><blockquote><p><strong>函数式编程的核心在于方法的参数化思想</strong>，其他的功能是在此基础上提供更加简单的编程方式。</p></blockquote><ul><li>工具1：<strong>方法引用</strong>：简化方法引用，具体使用方法后面会详述。</li><li>工具2：<strong>lambda</strong>（匿名函数）：极简的函数作为值传递的实现。</li></ul><p>最佳实践：若函数少于几行，可以使用lambda表达式简化方法参数化；反之，定义专门的函数并使用方法引用更加简洁。</p><blockquote><p>谓词：一种函数，接受一个参数，返回true或false。<br><code>Predicate&lt;T&gt;</code>：T -&gt; boolean，将T参数转化为布尔值。</p></blockquote><hr><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li>使用外部循环更加复杂，利用流提供的功能使用内部循环使代码更加简洁。</li><li>流提供的利用多核实现并行避免手动编写多线程代码可能产生的诸多问题。</li></ul><hr><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>目的：为了在接口中添加更多的功能而不强制实现类进行实现。更可能是为了实现函数式编程做的妥协。<br>问题：一个类可能实现多个接口，不同的接口中可能出现重名的默认实现，产生类似C++的菱形继承问题。</p><hr><h2 id="应对空指针异常"><a href="#应对空指针异常" class="headerlink" title="应对空指针异常"></a>应对空指针异常</h2><p>类<code>Optional&lt;T&gt;</code>是一个容器类，可以包含或不包含一个值，提供方法处理值不存在的情况。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java中的Lambda表达式</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/lambdaexpression/lambdaexpression/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/lambdaexpression/lambdaexpression/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中的Lambda表达式"><a href="#Java中的Lambda表达式" class="headerlink" title="Java中的Lambda表达式"></a>Java中的Lambda表达式</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote><p>(parameters) -&gt; expression<br>(parameters) -&gt; {statements;}</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 没有参数，有返回值</span><br>() -&gt; <span class="hljs-number">5</span><br><br><span class="hljs-comment">// 有一个参数，有返回值</span><br>x -&gt; <span class="hljs-number">2</span> * x<br><br><span class="hljs-comment">// 有两个参数，有返回值</span><br>(x, y) -&gt; x - y<br><br><span class="hljs-comment">// 有一个参数，无返回值</span><br>s -&gt; System.out.println(s);<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>参数列表中可以不需要写参数类型。</li><li>只有一个参数时，可以不写括号()。</li><li>方法体中只有一条时，可以不写大括号{}。</li><li>只有一条返回值，可以不写return。</li></ol><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list<br><br>list.forEach( e -&gt; System.out.println(e));<br>list.forEach( System.out::println);<br><br><span class="hljs-comment">// 示例2</span><br><span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">&quot;x&quot;</span>)).start();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java反射(Reflection)</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/reflection/Reflection/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/reflection/Reflection/</url>
    
    <content type="html"><![CDATA[<h1 id="Java反射-Reflection"><a href="#Java反射-Reflection" class="headerlink" title="Java反射(Reflection)"></a>Java反射(Reflection)</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>反射可以使得程序在运行时检查、修改运行时特性。</li><li>反射可以用于类、成员变量、构造器和方法中。    </li></ul><p>使用场景：</p><ul><li>用户可以使用类的全限定名创建并使用外部类。</li><li>通过反射可以获得一个类的信息（类的成员变量等），从而进行更多操作。</li><li>通过反射可以一个类中私有的成员变量。</li></ul><p>慎用：</p><ul><li>性能：反射涉及到动态解析类型，JVM无法对其进行优化。</li><li>安全：反射要求运行时许可，某些情况下可能无法满足。</li><li>暴露：反射可以使得程序访问一个类的私有方法和域，可能导致意想不到的问题。</li></ul><hr><h2 id="反射的使用方法"><a href="#反射的使用方法" class="headerlink" title="反射的使用方法"></a>反射的使用方法</h2><p>反射类位于<code>java.lang.reflect</code>，若使用反射，一般涉及三个步骤：</p><ol><li>获取想要操作的类的<code>java.lang.Class</code>对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c = Class.forName(<span class="hljs-string">&quot;类的全限定名&quot;</span>);<br><br><span class="hljs-comment">// 或者由一个对象获取对应的Class</span><br>String s = <span class="hljs-keyword">new</span> String();<br>Class c = s.getClass();<br><br><span class="hljs-comment">// 对于基本数据类型</span><br>Class c = <span class="hljs-keyword">int</span>.class;<br>Class c = Integer.TYPE;<br></code></pre></td></tr></table></figure></li><li>获取对应类中的定义的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Method[] ms = c.getDeclaredMethods();<br></code></pre></td></tr></table></figure></li><li>利用获得关于类的信息执行对应的操作。</li></ol><hr><h2 id="反射使用示例"><a href="#反射使用示例" class="headerlink" title="反射使用示例"></a>反射使用示例</h2><h3 id="模拟instanceof方法"><a href="#模拟instanceof方法" class="headerlink" title="模拟instanceof方法"></a>模拟<code>instanceof</code>方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// isInstance()：判断一个对象是否为指定类的对象</span><br>Class c = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br><span class="hljs-keyword">boolean</span> b1 = c.isInstance(<span class="hljs-keyword">new</span> Object()); <span class="hljs-comment">// 不是String类</span><br><span class="hljs-keyword">boolean</span> b2 = c.isInstance(<span class="hljs-keyword">new</span> String()); <span class="hljs-comment">// 是String类</span><br></code></pre></td></tr></table></figure><h3 id="获取类中方法的信息"><a href="#获取类中方法的信息" class="headerlink" title="获取类中方法的信息"></a>获取类中方法的信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c = Class.forName(<span class="hljs-string">&quot;class_name&quot;</span>);<br><br><span class="hljs-comment">// 获取类上的所有注解</span><br>Annotation[] as = c.getAnnotations();<br><br><span class="hljs-comment">// 获取类的构造器</span><br>Constructor[] csts = c.getConstructors(); <span class="hljs-comment">// 构造器数组</span><br><br><span class="hljs-comment">// 获取一个类中的所有成员变量</span><br>Field[] fs = c.getDeclaredFields();<br><br><span class="hljs-comment">// 获取一个类中所有的方法</span><br>Method[] ms = c.getDeclaredMethod();<br><span class="hljs-comment">// 获取异常类型</span><br>Class[] exp = ms[<span class="hljs-number">0</span>].getExceptionTypes();<br><span class="hljs-comment">// 获得参数类型列表</span><br>Class[] params = ms[<span class="hljs-number">0</span>].getParameterTypes();<br><br><span class="hljs-comment">// 获得一个类的权限修饰符</span><br><span class="hljs-keyword">int</span> mod = c.getModifiers();<br><span class="hljs-comment">// 通过Modifier类中的方法可以判断对应的修饰符</span><br>String mods = Modifier.toString(mod);<br><br><span class="hljs-comment">// 获取对应的包</span><br>Package pkg = c.getPackage();<br><br><span class="hljs-comment">// 获得类型信息</span><br>String typeInfo = c.getTypeName();<br><br></code></pre></td></tr></table></figure><h3 id="通过反射调用方法"><a href="#通过反射调用方法" class="headerlink" title="通过反射调用方法"></a>通过反射调用方法</h3><blockquote><p>使用场景：可以在运行时动态确定要调用的方法以及对应的参数列表。</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    Class sc = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>    Class[] paramTypes = <span class="hljs-keyword">new</span> Class[<span class="hljs-number">1</span>];<br>    paramTypes[<span class="hljs-number">0</span>] = Integer.TYPE;<br><span class="hljs-comment">// 获取对应的方法</span><br>    Method method = sc.getMethod(<span class="hljs-string">&quot;repeat&quot;</span>, paramTypes);<br>    String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;time&quot;</span>);<br><span class="hljs-comment">// 构造参数列表</span><br>    Object[] params = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">1</span>];<br>    params[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 反射调用方法</span><br>    Object res = method.invoke(s, params);<br>    System.out.println((String)res);<br>    <br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>反射调用类中特定方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">get</span><span class="hljs-params">(String clsName, String methName, Class[] insArgTypes, Object[] insArgList, Class[] argTypes, Object[] argList)</span> </span>&#123;<br>Object res = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 获取Class对象</span><br>Class cls = Class.forName(clsName);<br><span class="hljs-comment">// 获取对应的构造器</span><br>Constructor ct = cls.getConstructor(insArgTypes);<br><span class="hljs-comment">// 获取实例化对象</span><br>Object obj = ct.newInstance(insArgList);<br><span class="hljs-comment">// 获得对应的方法</span><br>Method m = cls.getMethod(methName, argTypes);<br><span class="hljs-comment">// 方法调用</span><br>res = m.invoke(obj, argList);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过反射使用数组"><a href="#通过反射使用数组" class="headerlink" title="通过反射使用数组"></a>通过反射使用数组</h3><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class cls = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>Object arr = Array.newInstance(cls, <span class="hljs-number">10</span>);<br>Array.set(arr, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;This is a test!&quot;</span>);<br>String res = (String)Array.get(arr, <span class="hljs-number">5</span>);<br>System.out.println(res);<br></code></pre></td></tr></table></figure><p>处理多维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] dims = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>&#125;;<br>Object arr = Array.newInstance(<span class="hljs-keyword">int</span>.class, dims);<br><br>Object arri = Array.get(arr, <span class="hljs-number">3</span>);<br>Object arrj = Array.get(arri, <span class="hljs-number">2</span>);<br>Array.setInt(arrj, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">int</span>[][][] arr1 = (<span class="hljs-keyword">int</span>[][][])arr;<br>System.out.println(arr1[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><hr><h2 id="动态代理（dynamic-proxy）"><a href="#动态代理（dynamic-proxy）" class="headerlink" title="动态代理（dynamic proxy）"></a>动态代理（dynamic proxy）</h2><blockquote><p>动态代理，即动态接口实现（dynamic interface implementation）。指通过反射动态地根据接口生成对应的实现类，并调用特定的方法。</p></blockquote><p>作用：</p><ul><li>对已有的class中的方法进行修改，从而实现多个功能。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol><li><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(String s)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(String s)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;This is a test from class MyTest&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自定义<code>InvocationHandler</code>子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    Object obj;<br><br>    MyInvocationHandler(Object obj) &#123;<span class="hljs-keyword">this</span>.obj = obj;&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><span class="hljs-comment">// do something before method is invoked</span><br>        method.invoke(obj, args);<br><span class="hljs-comment">// do something after method is invoked</span><br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用<code>Proxy</code>调用接口中定义的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建被调用接口的class数组</span><br>Class[] interfaces = <span class="hljs-keyword">new</span> Class[] &#123;ITest.class&#125;;<br><br><span class="hljs-comment">// 创建接口对应的实现类</span><br>MyTest mt = <span class="hljs-keyword">new</span> MyTest();<br><br><span class="hljs-comment">// 创建代理对象</span><br>(ITest) it = (ITest)Proxy.newProxyInstance(ITest.class.getClassLoader(), interfaces, <span class="hljs-keyword">new</span> MyInvocationHandler(mt));<br>it.f(<span class="hljs-string">&quot;dynamic proxy&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://b1ngz.github.io/java-dynamic-proxy/">Java Dynamic Proxy</a></li><li><a href="https://www.oracle.com/technical-resources/articles/java/javareflection.html">Using Java Reflection</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java中serialversionuid的作用</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/serialization/serialverisonuid/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/serialization/serialverisonuid/</url>
    
    <content type="html"><![CDATA[<h1 id="java中serialversionuid的作用"><a href="#java中serialversionuid的作用" class="headerlink" title="java中serialversionuid的作用"></a>java中serialversionuid的作用</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>在Java中若需要一个类可以被序列化，则需要使得该类实现<code>Serializable</code>接口。</li><li>在实现<code>Serializable</code>接口时，可以在该类中指定<code>serialVersionUID</code>，也可以不指定。<ul><li>当指定时，则在序列化时将<code>serialVersionUID</code>写入到输出流中，在反序列化时若指定的类的<code>serialVersionUID</code>不一致，则报错。</li><li>若没指定，则编译时会自动生成<code>serailVersionUID</code>用于反序列化时比较。该<code>serialVersionUID</code>与整个类有关，若存在字段改动则报错。</li></ul></li></ul><hr><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>定义待序列化类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">123456789L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;person:\nid: &quot;</span> + id + <span class="hljs-string">&quot;\nname: &quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>序列化方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serial</span><span class="hljs-params">(Person person)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>ObjectOutputStream oos = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    fos = <span class="hljs-keyword">new</span> FileOutputStream(filePath);<br>    oos = <span class="hljs-keyword">new</span> ObjectOutputStream(fos);<br>    oos.writeObject(person);<br>    oos.flush();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (oos != <span class="hljs-keyword">null</span>) oos.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>反序列化方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deserial</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>FileInputStream fis = <span class="hljs-keyword">null</span>;<br>ObjectInputStream ois = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    fis = <span class="hljs-keyword">new</span> FileInputStream(filePath);<br>    ois = <span class="hljs-keyword">new</span> ObjectInputStream(fis);<br>    Person p = (Person) ois.readObject();<br>    System.out.println(p.toString());<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (ois != <span class="hljs-keyword">null</span>) ois.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="序列化前后对象字段不一致"><a href="#序列化前后对象字段不一致" class="headerlink" title="序列化前后对象字段不一致"></a>序列化前后对象字段不一致</h3><ol><li>序列化前的字段在序列化后缺失。<blockquote><p>该字段在反序列化时会被丢弃。</p></blockquote></li><li>序列化后的对象添加新的字段。 <blockquote><p>新增的字段使用默认值进行填充。</p></blockquote></li></ol><hr><h2 id="静态字段序列化"><a href="#静态字段序列化" class="headerlink" title="静态字段序列化"></a>静态字段序列化</h2><ul><li>java不会对静态变量序列化，所以反序列化不会设置对应的值。</li></ul><hr><h2 id="父类序列化和transient关键字"><a href="#父类序列化和transient关键字" class="headerlink" title="父类序列化和transient关键字"></a>父类序列化和<code>transient</code>关键字</h2><p>若父类没有实现序列化接口而子类实现序列化接口，则会调用父类的默认构造器创建对象。</p><h2 id="若要避免序列化特定的字段，可以将其声明为transient。"><a href="#若要避免序列化特定的字段，可以将其声明为transient。" class="headerlink" title="若要避免序列化特定的字段，可以将其声明为transient。"></a>若要避免序列化特定的字段，可以将其声明为<code>transient</code>。</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/duanxz/p/3511695.html">java类中serialversionuid 作用 是什么?举个例子说明</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在Java中执行Shell命令</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/shell/RunShellCommandInJava/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/shell/RunShellCommandInJava/</url>
    
    <content type="html"><![CDATA[<h1 id="在Java中执行Shell命令"><a href="#在Java中执行Shell命令" class="headerlink" title="在Java中执行Shell命令"></a>在Java中执行Shell命令</h1><p>[toc]</p><hr><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ol><li>首先要判断宿主操作系统：为Windows还是Linux。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> isWindows = <br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.baeldung.com/run-shell-command-in-java">How to Run a Shell Command in Java</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java中的线程池</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/thread/threadpool/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/thread/threadpool/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>参考类为<code>ThreadPoolExecutor</code>。</li><li>线程池的核心是<strong>任务管理</strong>和<strong>线程管理</strong>。</li><li>通过内置的阻塞队列实现<strong>任务和线程的解耦</strong>。</li><li>线程池中使用了<strong>生产者-消费者模式</strong>，其中<strong>阻塞队列</strong>是生产者，<strong>工作线程</strong>是消费者。</li><li></li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池的运行流程：<br><img src="../../../imgs/threadpoolexecutorflowprocess.png" alt="线程池的运行流程"></p><h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><p>线程池有五种状态，分别为：<br>|状态|特征|<br>|—|—|<br>|<strong>RUNNING</strong>|能提交新任务，能处理阻塞队列中的任务。|<br>|<strong>SHUTDOWN</strong>|不能提交新任务，可以处理阻塞队列中的任务。|<br>|<strong>STOP</strong>|不能提交任务，不处理队列中的任务，中断正在处理任务的线程。|<br>|<strong>TIDYING</strong>|所有任务被终止，有效线程数为0。|<br>|<strong>TERMINATED</strong>|执行<code>terminated()</code>方法后。|</p><h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><ul><li>任务是通过<code>execute</code>方法提交到线程池中。</li><li>根据线程池目前的状态，被提交的任务会以不同的方式进行处理。<ul><li>直接申请新线程进行执行。</li><li>进入缓冲队列中等待线程执行。</li><li>拒绝该任务。</li></ul></li><li>线程池中使用<strong>阻塞队列</strong>保存等待线程执行的任务。阻塞队列提供任务，为生产者；工作线程执行任务，为消费者。</li><li>采用不同类型的阻塞队列可以实现不同的任务存取策略：<table><thead><tr><th>阻塞队列</th><th>特点</th></tr></thead><tbody><tr><td><code>ArrayBlockingQueue</code></td><td>基于数组实现的有界队列，遵循先进先出。</td></tr><tr><td>…</td><td></td></tr></tbody></table></li></ul><h3 id="任务管理策略"><a href="#任务管理策略" class="headerlink" title="任务管理策略"></a>任务管理策略</h3><p>根据当前线程池的状态，新提交的任务会有不同的处理方式：</p><ol><li>当。。。，直接执行任务</li><li>当。。。，任务进入阻塞队列</li><li>当。。。，任务被直接拒绝</li></ol><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><ul><li>线程在<code>ThreadPoolExecutor</code>中使用内部类<code>Worker</code>进行表示。每个<code>Worker</code>实例用于表示一个线程。</li><li><code>Worker</code>内有两个重要字段：<ul><li><code>thread</code>：表示该<code>Worker</code>对应的线程</li><li><code>firstTask</code>：表示该<code>Worker</code>需要执行的任务，可以为<code>null</code>。</li></ul></li><li>线程的管理主要关注线程生命周期中的三个阶段：<strong>创建线程</strong>，<strong>线程的运行</strong>和<strong>销毁线程</strong>。<ul><li><strong>创建线程</strong>：通过<code>addWorker</code>方法实现的。</li><li><strong>线程的运行</strong>：通过<code>runWorker</code>方法实现。</li><li><strong>销毁线程</strong>：通过<code>processWorkerExit</code>方法实现。</li></ul></li></ul><hr><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li>为什么线程池状态中会同时有<strong>TIDYING</strong>和<strong>TERMINATED</strong>，只需要一种状态表示线程池已经中止即可？</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践(建议全文背诵 : -) )</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池(Wikipedia)</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java中获取系统时间</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/time/getsystemtime/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/java/time/getsystemtime/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中获取系统时间"><a href="#Java中获取系统时间" class="headerlink" title="Java中获取系统时间"></a>Java中获取系统时间</h1><ol><li><p>方式一：通过<code>Date</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Date date = <span class="hljs-keyword">new</span> Date();<br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>String s = sdf.format(date);<br></code></pre></td></tr></table></figure></li><li><p>方式二：通过<code>System</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> time = System.currentTimeMillis();<br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>String s = sdf.format(time);<br></code></pre></td></tr></table></figure></li><li><p>方式三：通过<code>Calendar</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Date date = Calender.getInstance().getTime();<br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>String s = sdf.format(date);<br></code></pre></td></tr></table></figure></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/Ljm15832631631/article/details/79315069">Java获取系统时间的四种方法</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Services</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/10Services/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/10Services/</url>
    
    <content type="html"><![CDATA[<h1 id="10-Services"><a href="#10-Services" class="headerlink" title="10. Services"></a>10. Services</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><code>Service</code>用于实现程序后台运行。</li><li>适用于不需要交互并长期运行的任务。</li><li>即使程序切换到后台，仍然保持正常运行。</li><li><code>Service</code>依赖于创建时的应用进程。若该进程被中止，则对应的<code>Service</code>也停止运行。</li><li><code>Service</code>不会开启线程，所有代码默认在主线程执行。</li></ul><h3 id="线程的基本使用"><a href="#线程的基本使用" class="headerlink" title="线程的基本使用"></a>线程的基本使用</h3><p>两种创建线程的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 继承Thread类，重写run()方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 2. 实现Runnable接口，重写run()方法 </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable()) <span class="hljs-comment">// 再传入新线程中执行</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：无法创建子线程执行UI更新的操作，否则会报<code>CalledFromWrongThreadException</code>错误。</p></blockquote><hr><h2 id="异步消息处理机制"><a href="#异步消息处理机制" class="headerlink" title="异步消息处理机制"></a>异步消息处理机制</h2><p>异步消息处理机制涉及四个部分：</p><ul><li><code>Message</code>：线程之间传递的消息，内部携带少量数据，用于不同线程间传递信息。</li><li><code>Handler</code>：用于发送消息和处理消息。发送的消息最终由<code>handleMessage()</code>方法进行处理。</li><li><code>MessageQueue</code>：消息队列，用于存放所有由<code>Handler</code>发送的消息。（每个线程有唯一的<code>MessageQueue</code>）</li><li><code>Looper</code>：用来处理<code>MessageQueue</code>中存放的任务，通过<code>loop()</code>方法不断的从<code>MessageQueue</code>中取出任务，分配给对应的<code>Handler</code>，调用<code>handleMessage()</code>方法进行处理。</li></ul><p><img src="../../../imgs/handlemessage.jpg"></p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> TextView textView;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_main);<br>    textView = (TextView)(findViewById(R.id.textveiw_readytoupdate));<br>    ((Button)findViewById(R.id.button_updatetext)).setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>            <span class="hljs-comment">// 构建Message</span><br>            Message message = <span class="hljs-keyword">new</span> Message();<br>            <span class="hljs-comment">// 发送消息</span><br>            handler.sendMessage(message);<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 创建Handler处理任务</span><br><span class="hljs-keyword">private</span> Handler handler = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper()) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> </span>&#123;<br>        textView.setText(<span class="hljs-string">&quot;new Line&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="Service的用法"><a href="#Service的用法" class="headerlink" title="Service的用法"></a><code>Service</code>的用法</h2><p>自定义<code>Service</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IBinder <span class="hljs-title">onBind</span><span class="hljs-params">(Intent intent)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Return the communication channel to the service.</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;Not yet implemented&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过重写<code>Service</code>中的方法，可以决定<code>Service</code>在其生命周期中的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里通过log检查各方法的执行时机</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;<br>        Log.d(<span class="hljs-string">&quot;MyService&quot;</span>, <span class="hljs-string">&quot;onCreate&quot;</span>);<br>        <span class="hljs-keyword">super</span>.onCreate();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">onStartCommand</span><span class="hljs-params">(Intent intent, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> startId)</span> </span>&#123;<br>        Log.d(<span class="hljs-string">&quot;MyService&quot;</span>, <span class="hljs-string">&quot;onStartCommand&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onStartCommand(intent, flags, startId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>        Log.d(<span class="hljs-string">&quot;MyService&quot;</span>, <span class="hljs-string">&quot;onDestroy&quot;</span>);<br>        <span class="hljs-keyword">super</span>.onDestroy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动或停止<code>Service</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 启动或停止Service</span><br>Intent intent = <span class="hljs-keyword">new</span> Intent(getApplicationContext(), MyService.class);<br>startService(intent);<br><br><span class="hljs-comment">// 停止Service</span><br>stopService(intent);<br></code></pre></td></tr></table></figure><p><code>Service</code>启动方法调用：<code>onCreate()</code>（只在启动时调用，启动后不再调用） –&gt; <code>onStartCommand()</code>。<br>停止：<code>onDestory()</code>。</p><hr><ul><li><a href="https://book.douban.com/subject/34996842/">《第一行代码》-第十章》</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络技术</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/11Network/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/11Network/</url>
    
    <content type="html"><![CDATA[<h1 id="网络技术"><a href="#网络技术" class="headerlink" title="网络技术"></a>网络技术</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>在<code>Activity</code>中展示网页可以通过<code>WebView</code>组件展示网页。</li><li><code>WebView</code>在后台处理好发送HTTP请求，接收服务器响应，解析返回数据以及最终展示页面。</li></ul><p><code>WebView</code>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">wv.getSettings().setJavaScriptEnabled(<span class="hljs-keyword">true</span>);<br>wv.setWebViewClient(<span class="hljs-keyword">new</span> WebViewClient());<br>wv.loadUrl(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>);<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>应用访问网络需要声明权限：<code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code></li></ul><hr><h2 id="使用HTTP访问网络"><a href="#使用HTTP访问网络" class="headerlink" title="使用HTTP访问网络"></a>使用HTTP访问网络</h2><p>基本流程：</p><ol><li>创建URL对象，传入目标网络地址。</li><li>调用<code>openConnection()</code>方法，获得<code>HttpURLConnection</code>实例。</li><li>设置在<code>HttpURLConnection</code>对象中设置HTTP配置信息。</li><li>调用<code>getInputStream()</code>方法获取返回的输入流。</li><li>最后通过<code>disconnect()</code>关闭HTTP连接。</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendRequestWithHttpURLConnection</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    HttpURLConnection connection = <span class="hljs-keyword">null</span>;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">try</span> &#123;<br>URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>);<br>connection = (HttpURLConnection) url.openConnection();<br>connection.setConnectTimeout(<span class="hljs-number">8000</span>);<br>connection.setReadTimeout(<span class="hljs-number">8000</span>);<br>DataOutputStream outputStream = <span class="hljs-keyword">new</span> DataOutputStream(connection.getOutputStream());<br>outputStream.writeBytes(<span class="hljs-string">&quot;username=admin&amp;password=123456&quot;</span>);<br>InputStream inputStream = connection.getInputStream();<br>BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(inputStream));<br>String tmp = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">while</span> ((tmp = reader.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>    sb.append(tmp);<br>&#125;<br>showResult(sb.toString());<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>    &#125;<br>&#125;).start();<br>&#125;<br><br><span class="hljs-comment">// Android不允许在子线程中进行UI更新操作，调用runOnUiThread在UI线程进行UI更新</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showResult</span><span class="hljs-params">(String s)</span> </span>&#123;<br>runOnUiThread(() -&gt; &#123;tv_show_result.setText(s);&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>若需要提交数据，可将请求改为POST：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">connection.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="使用OkHttp"><a href="#使用OkHttp" class="headerlink" title="使用OkHttp"></a>使用OkHttp</h2><ul><li>OkHttp是一款出色的网络通信库，可以替换<code>HttpURLConnection</code>。</li></ul><p>使用：</p><ol><li>引入依赖：在<code>build.gradle</code>中的<code>dependencies</code>节点加入：<code>implementation &#39;com.squareup.okhttp3:okhttp:4.9.1&#39;</code></li><li>创建<code>OkHttpClient</code>实例。</li><li>如要发起HTTP请求，则创建一个<code>Requet</code>对象，设置url等信息。</li><li>通过<code>newCall()</code>创建<code>Call</code>对象，通过<code>execute()</code>方法发送请求并获取服务器返回的数据。</li><li>返回的结果为<code>Response</code>对象，通过<code>body()</code>获取具体的返回内容。</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendOkHttpRequest</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();<br>    Request request = <span class="hljs-keyword">new</span> Request.Builder().<br>    url(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>    .build();<br>    <span class="hljs-keyword">try</span> &#123;<br>Response response = client.newCall(request).execute();<br>String responseRes = response.body() == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : response.body().string();<br><span class="hljs-keyword">if</span> (responseRes != <span class="hljs-keyword">null</span>) setText(responseRes);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>    &#125;<br>&#125;).start();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setText</span><span class="hljs-params">(String s)</span> </span>&#123;<br>runOnUiThread(() -&gt; &#123;tv_okhttp_show_result.setText(s);&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>网络服务等耗时操作不能直接由UI线程执行，否则会抛出<code>W/System.err: android.os.NetworkOnMainThreadException</code>错误。可以通过创建子线程执行任务。</li></ul><hr><h2 id="解析XML数据"><a href="#解析XML数据" class="headerlink" title="解析XML数据"></a>解析XML数据</h2><ul><li>常见有两种解析方式：<ul><li>Pull解析</li><li>SAX解析</li></ul></li></ul><p>在解析数据前，为发起HTTP的操作创建工具类，从而可以使用不同的解析方法而不用重复编写相同的HTTP请求代码。</p><p>HTTP请求工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpUtil</span> </span>&#123;<br><span class="hljs-comment">// 发送HTTP请求，返回结果调用HttpCallbackListener回调函数进行处理</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendHttpRequest</span><span class="hljs-params">(String address, HttpCallbackListener listener)</span> </span>&#123;<br>ExecutorService service = Executors.newSingleThreadExecutor();<br>service.execute(() -&gt; &#123;<br>    HttpURLConnection connection = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>StringBuilder response = <span class="hljs-keyword">new</span> StringBuilder();<br>URL url = <span class="hljs-keyword">new</span> URL(address);<br>connection = (HttpURLConnection) url.openConnection();<br>connection.setConnectTimeout(<span class="hljs-number">8000</span>);<br>connection.setReadTimeout(<span class="hljs-number">8000</span>);<br>InputStream input = connection.getInputStream();<br>BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(input));<br>String tmp = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">while</span> ((tmp = reader.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>    response.append(tmp);<br>&#125;<br>listener.onFinish(response.toString());<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>listener.onError(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>connection.disconnect();<br>    &#125;<br>&#125;);<br>&#125;<br><br><span class="hljs-comment">// OkHttp封装调用和处理回调操作，需要重写Callback接口实现对返回数据的处理</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendOkHttpRequest</span><span class="hljs-params">(String address, okhttp3.Callback callback)</span> </span>&#123;<br>OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();<br>Request request = <span class="hljs-keyword">new</span> Request.Builder()<br>.url(address)<br>.build();<br>client.newCall(request).enqueue(callback);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 回调接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HttpCallbackListener</span> </span>&#123;<br><span class="hljs-comment">// 处理正常的回调结果</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onFinish</span><span class="hljs-params">(String response)</span></span>;<br><span class="hljs-comment">// 处理异常情况</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Exception e)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Pull解析"><a href="#Pull解析" class="headerlink" title="Pull解析"></a>Pull解析</h3><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseXML</span><span class="hljs-params">(String data)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>    XmlPullParserFactory factory = XmlPullParserFactory.newInstance();<br>    XmlPullParser xmlPullParser = factory.newPullParser();<br>    xmlPullParser.setInput(<span class="hljs-keyword">new</span> StringReader(data));<br>    <span class="hljs-keyword">int</span> eventType = xmlPullParser.getEventType();<br>    String id = <span class="hljs-string">&quot;&quot;</span>, name = <span class="hljs-string">&quot;&quot;</span>, version = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">while</span> (eventType != XmlPullParser.END_DOCUMENT) &#123;<br>String nodeName = xmlPullParser.getName();<br><span class="hljs-keyword">switch</span> (eventType) &#123;<br>    <span class="hljs-keyword">case</span> XmlPullParser.START_TAG:<br><span class="hljs-keyword">switch</span> (nodeName) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;id&quot;</span>:<br>id = xmlPullParser.nextText();<br><span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;name&quot;</span>:<br>name = xmlPullParser.nextText();<br><span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;version&quot;</span>:<br>version = xmlPullParser.nextText();<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> XmlPullParser.END_TAG:<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;app&quot;</span>.equals(nodeName)) &#123;<br>    Log.d(<span class="hljs-keyword">this</span>.getClass().getSimpleName(), <span class="hljs-string">&quot;id is: &quot;</span> + id + <span class="hljs-string">&quot;, name is: &quot;</span> + name + <span class="hljs-string">&quot;, version is: &quot;</span> + version);<br>&#125;<br>&#125;<br>eventType = xmlPullParser.next();<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>HttpUtil</code>中的<code>sendHttpRequest</code>发起HTTP请求，并在回调函数<code>HttpCallbackListener</code>中使用上述Pull解析方式对xml文件进行解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpUtil.sendHttpRequest(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>, <span class="hljs-keyword">new</span> HttpCallbackListener() &#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onFinish</span><span class="hljs-params">(String response)</span> </span>&#123;<br>parseXML(response); <span class="hljs-comment">// 调用Pull解析方式</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onException</span><span class="hljs-params">(Exception e)</span> </span>&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h3><p>这里只展示SAX解析代码：</p><ul><li><p>由于SAX用到<code>ContentHandler</code>接口进行内容的解析，所以需要先实现自定义的<code>ContentHandler</code>类。</p></li><li><p>重写五个方法：</p><ul><li><code>startDocument</code>：开始解析文档</li><li><code>endDocument</code>：结束解析文档</li><li><code>startElement</code>：开始解析单个节点</li><li><code>endElement</code>：结束解析单个节点</li><li><code>characters</code>：对每个节点的数据进行获取、保存<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyContentHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultHandler</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = MyContentHandler.class.getSimpleName();<br><br>    <span class="hljs-keyword">private</span> String nodeName = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">private</span> StringBuilder id, name, version;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SAXException </span>&#123;<br>        id = <span class="hljs-keyword">new</span> StringBuilder();<br>        name = <span class="hljs-keyword">new</span> StringBuilder();<br>        version = <span class="hljs-keyword">new</span> StringBuilder();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SAXException </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startElement</span><span class="hljs-params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="hljs-keyword">throws</span> SAXException </span>&#123;<br>        nodeName = localName;<br>        Log.d(TAG, <span class="hljs-string">&quot;start element: uri : &quot;</span> + uri + <span class="hljs-string">&quot;, local name: &quot;</span> + localName + <span class="hljs-string">&quot;, qName: &quot;</span> + qName + <span class="hljs-string">&quot;, attributes: &quot;</span> + attributes.toString());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endElement</span><span class="hljs-params">(String uri, String localName, String qName)</span> <span class="hljs-keyword">throws</span> SAXException </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;app&quot;</span>.equals(localName)) &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;id : &quot;</span> + id.toString().trim() + <span class="hljs-string">&quot;, name : &quot;</span> + name.toString().trim() + <span class="hljs-string">&quot;, version : &quot;</span> + version.toString().trim());<br>            id.setLength(<span class="hljs-number">0</span>);<br>            name.setLength(<span class="hljs-number">0</span>);<br>            version.setLength(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">characters</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] ch, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> length)</span> <span class="hljs-keyword">throws</span> SAXException </span>&#123;<br>        <span class="hljs-keyword">switch</span> (nodeName) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;id&quot;</span>:<br>                id.append(ch, start, length);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;name&quot;</span>:<br>                name.append(ch, start, length);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;version&quot;</span>:<br>                version.append(ch, start, length);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用SAX进行解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseXMLSAX</span><span class="hljs-params">(String data)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>    SAXParserFactory factory = SAXParserFactory.newInstance();<br>    XMLReader reader = factory.newSAXParser().getXMLReader();<br>    MyContentHandler myContentHandler = <span class="hljs-keyword">new</span> MyContentHandler();<br>    reader.setContentHandler(myContentHandler);<br>    reader.parse(<span class="hljs-keyword">new</span> InputSource(<span class="hljs-keyword">new</span> StringReader(data)));<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="解析Json数据"><a href="#解析Json数据" class="headerlink" title="解析Json数据"></a>解析Json数据</h2><ul><li>可以使用官方提供的<code>JSONObject</code>，或者众多第三方开源库<code>Jackson</code>,<code>GSON</code>等。</li><li>JSON格式的文件体积更小，适合于网络传输，但不够直观。</li></ul><h3 id="使用JSONObject解析JSON数据"><a href="#使用JSONObject解析JSON数据" class="headerlink" title="使用JSONObject解析JSON数据"></a>使用<code>JSONObject</code>解析JSON数据</h3><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseJSONJSONObject</span><span class="hljs-params">(String data)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>JSONArray jsonArray = <span class="hljs-keyword">new</span> JSONArray(data);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; jsonArray.length(); ++i) &#123;<br>JSONObject jsonObject = jsonArray.getJSONObject(i);<br>String id = jsonObject.getString(<span class="hljs-string">&quot;id&quot;</span>);<br>String name = jsonObject.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>String version = jsonObject.getString(<span class="hljs-string">&quot;version&quot;</span>);<br>Log.d(TAG, <span class="hljs-string">&quot;id : &quot;</span> + id + <span class="hljs-string">&quot;, name : &quot;</span> + name + <span class="hljs-string">&quot;, version : &quot;</span> + version);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用GSON解析JSON数据"><a href="#使用GSON解析JSON数据" class="headerlink" title="使用GSON解析JSON数据"></a>使用<code>GSON</code>解析JSON数据</h3><ul><li><code>GSON</code>可以直接将一段JSON字符串直接映射成一个对象。</li></ul><ol><li>添加依赖：<code>implementation &#39;com.google.code.gson:gson:2.8.8&#39;</code>。</li><li>创建数据类，添加对应的字段，使得每个节点中的数据可以映射到数据类的字段。</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 数据类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    String id, name, version;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">App</span><span class="hljs-params">(String id, String name, String version)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.version = version;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用GSON进行解析</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseJSONGSON</span><span class="hljs-params">(String data)</span> </span>&#123;<br>Gson gson = <span class="hljs-keyword">new</span> Gson();<br>Type type = <span class="hljs-keyword">new</span> TypeToken&lt;List&lt;App&gt;&gt;()&#123;&#125;.getType();<br>List&lt;App&gt; apps = gson.fromJson(data, type);<br><span class="hljs-keyword">for</span> (App a : apps) &#123;<br>Log.d(TAG, <span class="hljs-string">&quot;id : &quot;</span> + a.id + <span class="hljs-string">&quot;, name : &quot;</span> + a.name + <span class="hljs-string">&quot;, version : &quot;</span> + a.version);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="网络库-Retrofit"><a href="#网络库-Retrofit" class="headerlink" title="网络库:Retrofit"></a>网络库:<code>Retrofit</code></h2><ul><li>添加依赖（第一个是Retrofit库，第二个是转换库，借助GSON解析JSON数据）:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">implementation &#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;<br>implementation &#x27;com.squareup.retrofit2:converter-gson:2.9.0&#x27;<br></code></pre></td></tr></table></figure></li><li>定义接口，用于获取JSON数据：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AppService</span> </span>&#123;<br><br>    <span class="hljs-meta">@GET(&quot;get_data.json&quot;)</span><br>    Call&lt;List&lt;App&gt;&gt; getAppData();<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用<code>Retrofit</code>解析数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()<br>.baseUrl(MY_URL)<br>.addConverterFactory(GsonConverterFactory.create())<br>.build();<br><br>AppService appService = retrofit.create(AppService.class);<br>appService.getAppData().enqueue(<span class="hljs-keyword">new</span> Callback&lt;List&lt;App&gt;&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call&lt;List&lt;App&gt;&gt; call, retrofit2.Response&lt;List&lt;App&gt;&gt; response)</span> </span>&#123;<br>List&lt;App&gt; body = response.body();<br><span class="hljs-keyword">if</span> (body != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">for</span> (App a : body) &#123;<br>Log.d(TAG, <span class="hljs-string">&quot;id : &quot;</span> + a.id + <span class="hljs-string">&quot;, name : &quot;</span> + a.name + <span class="hljs-string">&quot;, version : &quot;</span> + a.version);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call&lt;List&lt;App&gt;&gt; call, Throwable t)</span> </span>&#123;<br>t.printStackTrace();<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><p>注：</p><ul><li>注解<code>@GET(&quot;url_address&quot;)</code>表示调用该方法为发出GET请求，请求地址为注解内的参数。</li><li>方法的返回值必须为<code>Call</code>类型，通过范型指定返回的数据转换成为的对象。</li></ul><h3 id="处理复杂的接口地址类型"><a href="#处理复杂的接口地址类型" class="headerlink" title="处理复杂的接口地址类型"></a>处理复杂的接口地址类型</h3><p><strong>动态的接口地址</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对应的url为host/1/get_data.json</span><br><span class="hljs-meta">@GET(&quot;&#123;page&#125;/get_data.json&quot;)</span><br>Call&lt;List&lt;App&gt;&gt; getData(<span class="hljs-meta">@Path(&quot;page&quot;)</span> <span class="hljs-keyword">int</span> page);<br></code></pre></td></tr></table></figure><p><strong>带参数的GET请求格式</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对应的url为host/get_data.json?u=admin&amp;t=123456</span><br><span class="hljs-meta">@GET(&quot;get_data.json&quot;)</span><br>Call&lt;List&lt;App&gt;&gt; getData1(<span class="hljs-meta">@Query(&quot;u&quot;)</span> String user, <span class="hljs-meta">@Query(&quot;t&quot;)</span> String token);<br></code></pre></td></tr></table></figure><p><strong>DELETE操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DELELE(&quot;data/&#123;id&#125;&quot;)</span><br><span class="hljs-function">Call&lt;ResponseBody&gt; <span class="hljs-title">deleteData</span><span class="hljs-params">(<span class="hljs-meta">@Path(&quot;id&quot;)</span> String id)</span></span>;<br></code></pre></td></tr></table></figure><p>注意：返回值类型<code>ResponseBody</code>表示对于服务器响应的数据不关心，用于POST，PUT，PATCH，DELETE等操作中。表示接收任何类型的响应数据。不对数据进行解析。</p><p><strong>POST操作</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@POST(&quot;data/create&quot;)</span><br><span class="hljs-function">Call&lt;ResponseBody&gt; <span class="hljs-title">createData</span><span class="hljs-params">(<span class="hljs-meta">@Body</span> Data data)</span></span>;<br></code></pre></td></tr></table></figure><p>注意：将四川的数据包装成一个<code>Data</code>对象，由<code>Retrofit</code>将该对象中的数据自动的转换为JSON格式的文本，放入HTTP请求的body部分。</p><p><strong>HTTP请求的header中指定参数</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GET(&quot;get_data.json&quot;)</span><br><span class="hljs-function">Call&lt;Data&gt; <span class="hljs-title">getData</span><span class="hljs-params">(<span class="hljs-meta">@Header(&quot;User-Agent&quot;)</span> String userAgent, <span class="hljs-meta">@Header(&quot;Cache-Control&quot;)</span> String cacheControl)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>优化</strong>:<br>将<code>Retrofit</code>提供的服务改写成一个工具类，方便重复调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceCreator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String BASE_URL = <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()<br>            .baseUrl(BASE_URL)<br>            .addConverterFactory(GsonConverterFactory.create())<br>            .build();<br><br>    <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> retrofit.create(serviceClass);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://book.douban.com/subject/34996842/">《第一行代码》-第十一章</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Jetpack高级开发组件</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/13Jetpack/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/13Jetpack/</url>
    
    <content type="html"><![CDATA[<h1 id="Jetpack高级开发组件"><a href="#Jetpack高级开发组件" class="headerlink" title="Jetpack高级开发组件"></a>Jetpack高级开发组件</h1><p>[toc]</p><hr><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a><code>ViewModel</code></h2><ul><li>将所有的逻辑处理放在<code>Activity</code>中导致项目难以维护，<code>ViewModel</code>可以分担<code>Activity</code>一部分工作。</li><li>可以将界面的数据存放在<code>ViewModel</code>中，<code>Activity</code>重新创建不会丢失数据。</li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>添加依赖：<code>implementation &#39;androidx.lifecycle:lifecycle-extensions:2.2.0&#39;</code>。</li><li>新建类继承自<code>ViewModel</code>。</li><li>在<code>Activity</code>中使用<code>ViewModel</code>保存相关数据。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义的ViewModel</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainViewModel1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModel</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainViewModel1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainViewModel1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> countReserved)</span> </span>&#123;<br>        count = countReserved;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">plusOne</span><span class="hljs-params">()</span> </span>&#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        count = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取自定义的ViewModel，通过provider方式可以使得Activity被回收也能继续存活</span><br>mainViewModel1 = <span class="hljs-keyword">new</span> ViewModelProvider(<span class="hljs-keyword">this</span>).get(MainViewModel1.class);<br><br><span class="hljs-comment">// 通过ViewModel保存或获取数据</span><br>mainViewModel1.plusOne();<br><span class="hljs-keyword">int</span> count = mainViewModel1.getCount();<br></code></pre></td></tr></table></figure><p>若需要在应用退出时仍然保存数据，则可以在退出时将数据保存到数据库，在重新进入时加载数据。</p><ol><li>创建一个可以接受参数的<code>ViewModel</code>，同上。</li><li>自定义<code>ViewModelFactory</code>类，继承自<code>ViewModelProvider.Factory</code>，用于返回带参数的<code>ViewModel</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainViewModelFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewModelProvider</span>.<span class="hljs-title">Factory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> countReserved;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainViewModelFactory</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<span class="hljs-keyword">this</span>.countReserved = count;&#125;<br><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T extends ViewModel&gt; <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">new</span> MainViewModel1(countReserved);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在<code>Activity</code>中使用持久性方式保存或获取数据。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">sharedPreferences = getSharedPreferences(<span class="hljs-string">&quot;counter&quot;</span>, Context.MODE_PRIVATE);<br><span class="hljs-keyword">int</span> countReserved = sharedPreferences.getInt(<span class="hljs-string">&quot;count_reserved&quot;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 通过ViewModelFactory创建ViewModel</span><br>mainViewModel1 = <span class="hljs-keyword">new</span> ViewModelProvider(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> MainViewModelFactory(countReserved)).get(MainViewModel1.class);<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="Lifecycles"><a href="#Lifecycles" class="headerlink" title="Lifecycles"></a><code>Lifecycles</code></h2><ul><li>可以在一个非<code>Activity</code>类中感知<code>Activity</code>的生命周期。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建自定义类，实现LifecycleObserver，通过注解设置特定生命周期收到通知</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LifecycleObserver</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = MyObserver.class.getSimpleName();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyObserver</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>   <br>    <span class="hljs-comment">// Activity处于START状态时收到通知</span><br>    <span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">activityStart</span><span class="hljs-params">()</span> </span>&#123;<br>        Log.d(TAG, <span class="hljs-string">&quot; : activity start&quot;</span>);<br>        getCurrentState();<br>    &#125;<br><br>    <span class="hljs-comment">// Activity处于STOP收到通知</span><br>    <span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">activityStop</span><span class="hljs-params">()</span> </span>&#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;: activity stop&quot;</span>);<br>        getCurrentState();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 在Activity中设置观察器</span><br>getLifecycle().addObserver(<span class="hljs-keyword">new</span> MyObserver(getLifecycle()));<br></code></pre></td></tr></table></figure><p>若要主动获取当前<code>Activity</code>的生命周期，可以创建带参的Observer，将<code>Lifecycle</code>传入其中，即可通过<code>Lifecycle</code>主动获取生命周期信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Lifecycle lifecycle;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyObserver</span><span class="hljs-params">(Lifecycle lifecycle)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.lifecycle = lifecycle;<br>&#125;<br><br><span class="hljs-comment">// 主动获取生命周期信息</span><br>lifecycle.getCurrentState();<br></code></pre></td></tr></table></figure><hr><h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a><code>LiveData</code></h2><ul><li>可以包含任何类型的数据。</li><li>其他类可以对该数据设置监听器，当数据发生改动时可以收到通知。</li><li>一般用于界面和数据的解耦，使得界面通过<code>ViewModel</code>内置的<code>LiveData</code>获取数据。</li><li><code>MutableLiveData</code>为可以修改的<code>LiveData</code>，可以通过<code>postValue()</code>在非主线程修改数据，通过<code>getValue()</code>获取数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 界面的数据包装成User类，并以MutableLiveData类保存，Activity可以监听该LiveData</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainViewModel1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModel</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> MutableLiveData&lt;User&gt; mUserLiveData;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainViewModel1</span><span class="hljs-params">()</span> </span>&#123;<br>        mUserLiveData = <span class="hljs-keyword">new</span> MutableLiveData&lt;&gt;(<span class="hljs-keyword">new</span> User(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;aa&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LiveData&lt;User&gt; <span class="hljs-title">getUserLiveData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mUserLiveData;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeUserInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        mUserLiveData.postValue(<span class="hljs-keyword">new</span> User(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>), <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>), <span class="hljs-string">&quot;zhangsan&quot;</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在Activity中设置监听器</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">observeUserLiveData</span><span class="hljs-params">()</span> </span>&#123;<br>mainViewModel1.getUserLiveData().observe(<span class="hljs-keyword">this</span>, v -&gt; &#123;<br>    <span class="hljs-comment">// 设置数据改动时动作</span><br>    <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;<br>tv_number.setText(v.toString());<br>    &#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：避免暴露<code>LiveData</code>，方式参见网络相关资料。</p><h3 id="map和switchMap"><a href="#map和switchMap" class="headerlink" title="map和switchMap"></a><code>map</code>和<code>switchMap</code></h3><ul><li>若不想将整个数据全部暴露出，可以使用<code>map()</code>方法将一个<code>LiveData</code>转换为另一个类型的<code>LiveData</code>。如只关注用户名，则可以将<code>User</code>转换为<code>String</code>。</li><li>若<code>LiveData</code>是通过方法获取的，则每次获取新的<code>LiveData</code>实例导致在原对象上设置的监听器失效，可以通过<code>switchMap()</code>方法将一个可能会重新创建的<code>LiveData</code>转换为可观察的<code>LiveData</code>对象。</li></ul><p><code>switchMap()</code>方法基本原理：<br>当转换之前的对象发生改动时，<code>swithcMap()</code>方法会将通过自定义的转换函数生成可观察的<code>LiveData</code>对象。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用map将一种类型的LiveData转换为另一种类型的LiveData</span><br><span class="hljs-keyword">private</span> MutableLiveData&lt;User&gt; mUserLiveData;<br><span class="hljs-keyword">private</span> LiveData&lt;String&gt; mUserNameLiveData;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainViewModel1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> countReserved)</span> </span>&#123;<br>mUserLiveData = <span class="hljs-keyword">new</span> MutableLiveData&lt;&gt;(<span class="hljs-keyword">new</span> User(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;aa&quot;</span>));<br>mUserNameLiveData = Transformations.map(mUserLiveData, x -&gt; x.toString() );<br>&#125;<br><br><span class="hljs-comment">// 使用switchMap将LiveData转换为可观察的对象</span><br><br>```java<br><span class="hljs-keyword">private</span> LiveData&lt;User&gt; mUserIdLiveData;<br>mUserIdLiveData = Transformations.switchMap(mUserLiveData, v -&gt; <span class="hljs-keyword">new</span> MutableLiveData&lt;&gt;(v));<br></code></pre></td></tr></table></figure><hr><h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><ul><li>Room是一个ORM框架（Object Relational Mapping，对象关系映射），可以实现在面向对象语言和面向关系的数据库之间建立映射关系。</li><li>通过ORM框架，可以不需要编写SQL语句实现数据库的操作。</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Room由三个部分组成：<ul><li><strong>Entity</strong>：用于封装实际数据的实体类。</li><li><strong>Dao</strong>：数据访问对象，逻辑层通过<strong>Dao</strong>来实现操作数据库。</li><li><strong>Database</strong>：定义数据库的基本信息，提供Dao层的访问实例。</li></ul></li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>添加依赖：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">implementation &#x27;androidx.room:room-runtime:2.3.0&#x27;<br>annotationProcessor &#x27;androidx.room:room-compiler:2.3.0&#x27;<br></code></pre></td></tr></table></figure></li><li>创建实体类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过注解表示该类为Entity</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-comment">// 注解PrimaryKey设置主键</span><br>    <span class="hljs-meta">@PrimaryKey(autoGenerate = true)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id, <span class="hljs-keyword">int</span> age, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>创建Dao接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不同的注解表示对应的数据库操作</span><br><span class="hljs-meta">@Dao</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-meta">@Insert</span><br>    <span class="hljs-function">Long <span class="hljs-title">insertUser</span><span class="hljs-params">(User user)</span></span>;<br><br>    <span class="hljs-meta">@Update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User newUser)</span></span>;<br><br>    <span class="hljs-meta">@Query(&quot;SELECT * FROM user&quot;)</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">loadAllUsers</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-meta">@Query(&quot;SELECT * FROM user WHERE age &gt; :age&quot;)</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">loadUserOlderThan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>;<br><br>    <span class="hljs-meta">@Delete</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(User user)</span></span>;<br><br>    <span class="hljs-meta">@Query(&quot;DELETE FROM user WHERE name = :name&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteUserByName</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>定义数据库<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// version表示当前数据库的版本，entities表示实体类</span><br><span class="hljs-meta">@Database(version = 1, entities = &#123;User.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDatabase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RoomDatabase</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> AppDatabase instance = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 抽象方法用于获取Dao的实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> UserDao <span class="hljs-title">userDao</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">AppDatabase <span class="hljs-title">getDatabase</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (instance != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> instance;<br>            <span class="hljs-keyword">return</span> instance = Room.databaseBuilder(context.getApplicationContext(), AppDatabase.class, <span class="hljs-string">&quot;app_database&quot;</span>).build();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用Room进行数据库操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">UserDao userDao = <span class="hljs-keyword">new</span> AppDatabase_Impl().getDatabase(<span class="hljs-keyword">this</span>).userDao();<br>userDao.insertUser(user1);<br></code></pre></td></tr></table></figure></li></ul><h3 id="数据库升级"><a href="#数据库升级" class="headerlink" title="数据库升级"></a>数据库升级</h3><p>通过<code>Migration</code>类实现：</p><ul><li>在数据库类中定义<code>Migration</code>类，在其中定义数据库升级操作，两个数值分别表示升级前后的数据库版本。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Migration MIGRATION_1_2 = <span class="hljs-keyword">new</span> Migration(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">migrate</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> SupportSQLiteDatabase database)</span> </span>&#123;<br>    database.execSQL(<span class="hljs-string">&quot;CREATE TABLE book (id INTEGER PRIMARY KEY AUTOINCREMENT, page INTEGER, name TEXT)&quot;</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 通过addMigrations添加数据库升级操作</span><br><span class="hljs-function">AppDatabase <span class="hljs-title">getDatabase</span><span class="hljs-params">(Context context)</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">if</span> (instance != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> instance;<br>    <span class="hljs-keyword">return</span> instance = Room.databaseBuilder(context.getApplicationContext(), AppDatabase.class, <span class="hljs-string">&quot;app_database&quot;</span>).addMigrations(MIGRATION_1_2).build();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a><code>WorkManager</code></h2><ul><li>主要用于处理一些要求定时执行的任务。</li><li><code>Service</code>在没有被销毁时保持在后台运行，而<code>WorkManager</code>是一个处理定时任务的工具，应用退出后任务仍然可以得到执行。</li><li><code>WorkManager</code>注册的周期性任务<strong>不能保证一定准时执行</strong>。</li></ul><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>添加依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">implementation &#x27;androidx.work:work-runtime:2.2.0&#x27;<br></code></pre></td></tr></table></figure></li><li>定义一个后台任务，实现具体的任务逻辑<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义的任务类需要继承自Worker</span><br><span class="hljs-comment">// 任务逻辑在doWork()方法中实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Worker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleWorker</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@NonNull</span> WorkerParameters workerParams)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, workerParams);<br>    &#125;<br><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">doWork</span><span class="hljs-params">()</span> </span>&#123;<br>        Log.d(<span class="hljs-keyword">this</span>.getClass().getSimpleName(), <span class="hljs-string">&quot;this is from worker manager&quot;</span>);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>配置后台任务的运行条件和约束信息，构建后台任务请求。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// setInitiaDelay：设置延迟执行</span><br><span class="hljs-comment">// addTag：添加标签</span><br>OneTimeWorkRequest oneTimeWorkRequest = <span class="hljs-keyword">new</span> OneTimeWorkRequest.Builder(SimpleWorker.class)<br>    .setInitialDelay(<span class="hljs-number">1</span>, TimeUnit.SECONDS)<br>    .addTag(<span class="hljs-string">&quot;simple&quot;</span>)<br>    .build();<br></code></pre></td></tr></table></figure></li><li>将后台任务请求传入WorkManager的enqueue方法，待系统调度执行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">WorkManager.getInstance(<span class="hljs-keyword">this</span>).enqueue(oneTimeWorkRequest);<br></code></pre></td></tr></table></figure></li></ul><h4 id="创建一个周期执行的任务："><a href="#创建一个周期执行的任务：" class="headerlink" title="创建一个周期执行的任务："></a>创建一个周期执行的任务：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">PeriodicWorkRequest request = <span class="hljs-keyword">new</span> PeriodicWorkRequest.Builder(SimpleWorker.class, <span class="hljs-number">1</span>, TimeUnit.SECONDS).setInitialDelay(<span class="hljs-number">2</span>, TimeUnit.SECONDS)<br>    .addTag(<span class="hljs-string">&quot;simple&quot;</span>)<br>    .build();<br></code></pre></td></tr></table></figure><h4 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 取消指定标签的任务</span><br>WorkManager.getInstance(<span class="hljs-keyword">this</span>).cancelAllWorkByTag(<span class="hljs-string">&quot;simple&quot;</span>);<br><br><span class="hljs-comment">// 取消所有任务</span><br>WorkManager.getInstance(<span class="hljs-keyword">this</span>).cancelAllWork();<br></code></pre></td></tr></table></figure><h4 id="社设置失败后重新执行"><a href="#社设置失败后重新执行" class="headerlink" title="社设置失败后重新执行"></a>社设置失败后重新执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">OneTimeWorkRequest oneTimeWorkRequest = <span class="hljs-keyword">new</span> OneTimeWorkRequest.Builder(SimpleWorker.class)<br>    .setInitialDelay(<span class="hljs-number">1</span>, TimeUnit.SECONDS)<br>    .setBackoffCriteria(BackoffPolicy.LINEAR, <span class="hljs-number">10</span>, TimeUnit.SECONDS)<br>    .addTag(<span class="hljs-string">&quot;simple&quot;</span>)<br>    .build();<br></code></pre></td></tr></table></figure><hr><h2 id="链式任务"><a href="#链式任务" class="headerlink" title="链式任务"></a>链式任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">WorkManager.getInstance(<span class="hljs-keyword">this</span>)<br>    .beginWith(oneTask)<br>    .then(anotherTask)<br>    .enqueue();<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.ituring.com.cn/book/2744">第一行代码——Android（第3版）-第十三章</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Activity</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/3activity/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/3activity/</url>
    
    <content type="html"><![CDATA[<h1 id="3-Activity"><a href="#3-Activity" class="headerlink" title="3. Activity"></a>3. Activity</h1><p>[toc]</p><hr><h2 id="Activity简介"><a href="#Activity简介" class="headerlink" title="Activity简介"></a>Activity简介</h2><p>Activity是一个包含用户界面的组件，用于与用户进行交互。</p><h2 id="手动创建Activity"><a href="#手动创建Activity" class="headerlink" title="手动创建Activity"></a>手动创建Activity</h2><ol><li>创建一个新的项目</li><li><code>Add No Activity</code></li><li>确定应用属性信息。</li><li>创建项目成功后改动到Project模式。<br><img src="../../../imgs/projectview.jpg"></li><li>添加一个空的Activity：在<code>app/java/com.XXX</code>文件下新建一个Activity。(注：不要勾选<code>Generate Layout File</code>和<code>Launcher Activity</code>，后续自行添加)<br><img src="../../../imgs/addemptyactivity.jpg"></li><li>创建布局：在<code>app/res/</code>目录下创建<code>layout</code>目录，并在该目录下创建一个layout布局文件：<br><img src="../../../imgs/addlayout.jpg"></li><li>编辑布局文件：点击布局文件，将视图切换到<code>Text</code>模式：<br><img src="../../../imgs/layout_textview.jpg"><br>添加如下：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button1&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Button 1&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li>在启动的Activity中添加该布局，使之显示出来。在<code>onCreate()</code>方法中添加<code>setContentView(R.layout.firstlayout)</code>，其中<code>firstlayout</code>是布局文件名。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.firstlayout);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在<code>AndroidManifest.xml</code>中注册Activity为主Activity。在对应的<code>&lt;activity&gt;</code>标签中加入：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>此时应用构建完成，可以进行测试。</li></ol><hr><h2 id="在Activity中使用Toast"><a href="#在Activity中使用Toast" class="headerlink" title="在Activity中使用Toast"></a>在Activity中使用Toast</h2><blockquote><p><code>Toast</code>：小窗口提示信息。</p></blockquote><ol><li>在创建的Activity中添加如下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Button button = findViewById(R.id.button1);<br>button.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123; <span class="hljs-comment">// 给按钮设置监听器，点击时触发</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-comment">// 弹出提示通知</span><br>        Toast.makeText(getApplicationContext(), <span class="hljs-string">&quot;You clicked this button&quot;</span>, Toast.LENGTH_SHORT).show();<br>    &#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="在Activity中使用Menu"><a href="#在Activity中使用Menu" class="headerlink" title="在Activity中使用Menu"></a>在Activity中使用Menu</h2><ol><li>在<code>/app/res/</code>目录下创建<code>menu</code>目录。</li><li>在<code>menu</code>目录下新建<code>Menu</code>文件，增加两个按钮：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/add_item&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:title</span>=<span class="hljs-string">&quot;Add&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/remove_item&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:title</span>=<span class="hljs-string">&quot;Remove&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li>在主Activity中重写<code>onCreateOptionsMenu</code>方法和<code>onOptionsItemSelected</code>方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 给Activity中创建选项Menu</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onCreateOptionsMenu</span><span class="hljs-params">(Menu menu)</span> </span>&#123;<br>    MenuInflater menuInflater = getMenuInflater();<br>    menuInflater.inflate(R.menu.main, menu);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 设置当Menu中的选择被选定时的操作</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onOptionsItemSelected</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MenuItem item)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> itemId = item.getItemId();<br>    <span class="hljs-keyword">switch</span> (itemId) &#123;<br>        <span class="hljs-keyword">case</span> R.id.add_item : Toast.makeText(getApplicationContext(), <span class="hljs-string">&quot;Add item&quot;</span>, Toast.LENGTH_LONG).show();<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> R.id.remove_item : Toast.makeText(getApplicationContext(), <span class="hljs-string">&quot;Remove Item&quot;</span>, Toast.LENGTH_LONG).show();<span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="摧毁一个Activity"><a href="#摧毁一个Activity" class="headerlink" title="摧毁一个Activity"></a>摧毁一个Activity</h2><p>系统提供<code>finsh()</code>方法实现将一个Activity摧毁。</p><hr><h2 id="使用Intent在Activity间通信"><a href="#使用Intent在Activity间通信" class="headerlink" title="使用Intent在Activity间通信"></a>使用<code>Intent</code>在Activity间通信</h2><blockquote><p><code>Intent</code>：各组件之间进行交互的一种方式，可以指明当前组件的目的和在不同组件之间传递数据。</p></blockquote><ol><li>创建新的Activity。</li><li>在<code>AndroidManifest.xml</code>中对应的<code>&lt;activity&gt;</code>标签中设置过滤器<code>&lt;intent-filter&gt;</code>：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.xiaomi.editmyactivity.ACTION_START&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.APP_CALENDAR&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li>在主Activity中设置调用新Activity的逻辑：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 隐式的Intent</span><br>button.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>    <span class="hljs-comment">// 点击按钮触发第二个Activity</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">&quot;com.xiaomi.editmyactivity.ACTION_START&quot;</span>);<br>        startActivity(intent);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// 显式的Intent</span><br>button.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-comment">// 指定Activity</span><br>        Intent intent = <span class="hljs-keyword">new</span> Intent(getApplicationContext(), Main2Activity.class);<br>        startActivity(intent);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>注意：<code>&lt;action&gt;</code>：可自定义对应组件的标签。</p></blockquote><h3 id="隐式Intent用法"><a href="#隐式Intent用法" class="headerlink" title="隐式Intent用法"></a>隐式<code>Intent</code>用法</h3><ul><li>启动系统提供的Activity：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用系统浏览器</span><br>Intent intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_VIEW);<br>intent.setData(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>);<br>startActivity(intent);<br><br><span class="hljs-comment">// 调用系统拨号</span><br>Intent intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_DIAL);<br>intent.setData(<span class="hljs-string">&quot;tel:110&quot;</span>);<br>startActivity(intent);<br></code></pre></td></tr></table></figure></li><li>定制Activity特性，使其响应特定的<code>action</code>。在对应的<code>&lt;activity&gt;</code>中设置<code>&lt;intent-filter&gt;</code>：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定当前Activity可以响应https请求--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;http&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong><code>&lt;data&gt;</code>可以配置的内容</strong>：<br>|标签|说明|<br>|—|—|<br>|<code>scheme</code>|指定数据的协议|<br>|<code>host</code>|指定数据的主机部分|<br>|<code>port</code>|指定数据的端口|<br>|<code>path</code>|指定主机和端口之后的部分|<br>|<code>mimeType</code>|指定可以处理的数据类型|</p><hr><h2 id="向其他的Activity传递数据"><a href="#向其他的Activity传递数据" class="headerlink" title="向其他的Activity传递数据"></a>向其他的Activity传递数据</h2><ol><li>第一个Activity的<code>onCreate()</code>方法中设置监听器，通过<code>Intent</code>将数据传送到其他的Activity中：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一个Activity的onCreate方法：</span><br>findViewById(R.id.button1).setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        <span class="hljs-comment">// 指定跳转的下一个Activity</span><br>        Intent intent = <span class="hljs-keyword">new</span> Intent(getApplicationContext(), MainActivity2.class);<br>        String data = <span class="hljs-string">&quot;From MainActivity&quot;</span>;<br>        <span class="hljs-comment">// 将数据保存到Intent中</span><br>        intent.putExtra(<span class="hljs-string">&quot;extra_data&quot;</span>, data);<br>        <span class="hljs-comment">// 触发下一个Activity</span><br>        startActivity(intent);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li>第二个Activity中从Intent中获取数据：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从Intent中取出数据</span><br>String extra_data = getIntent().getStringExtra(<span class="hljs-string">&quot;extra_data&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><blockquote><ul><li>Android将Activity存放在返回栈（back stack）中。</li><li>每次启动一个Activity时，会在返回栈入栈，处于栈顶位置。</li><li>当调用<code>finsh()</code>方法或返回键摧毁一个Activity时，处于栈顶的Activity会出栈，前一个Activity处于栈顶，系统将显示给用户。</li></ul></blockquote><p><img src="../../../imgs/cyclelife.jpg"></p><h3 id="Activity状态"><a href="#Activity状态" class="headerlink" title="Activity状态"></a>Activity状态</h3><blockquote><p>每个Activity在生命周期中有四种状态。</p></blockquote><ul><li><strong>运行状态</strong>：此时Activity处于返回栈栈顶。</li><li><strong>暂停状态</strong>：当一个Activity不再处于栈顶但仍然可见。此时Activity是存活状态。除非内存极低，否则系统不会回收。</li><li><strong>停止状态</strong>：当一个Activity不在栈顶并且完全不可见。系统会保存状态和成员变量。</li><li><strong>摧毁状态</strong>：当一个Activity从返回栈移除后就变成销毁状态。系统倾向于回收其内存。</li></ul><h3 id="Activity的生存期"><a href="#Activity的生存期" class="headerlink" title="Activity的生存期"></a>Activity的生存期</h3><table><thead><tr><th>方法</th><th>调用时机</th></tr></thead><tbody><tr><td><code>onCreate</code></td><td>一个Activity第一次被创建</td></tr><tr><td><code>onStart</code></td><td>当一个Activity由不可见变为可见状态</td></tr><tr><td><code>onResume</code></td><td>在Activity准备好与用户进行交互时，此时Activity位于栈顶并处于运行状态</td></tr><tr><td><code>onPause</code></td><td>当系统准备启动或恢复另一个Activity时调用，将系统资源释放，保存关键数据。</td></tr><tr><td><code>onStop</code></td><td>当Activity完全不可见时调用。</td></tr><tr><td><code>onDestory</code></td><td>在一个Activity被摧毁前调用。</td></tr><tr><td><code>onRestart</code></td><td>当Activity由停止状态变为运行状态之前调用。</td></tr></tbody></table><p><img src="../../../imgs/wholecyclelife.jpg"></p><p>其中：</p><ul><li><code>onCreat()</code>–&gt;<code>onDestroy()</code>：是一个Activity的完整生存周期。</li><li><code>onStart()</code>–&gt;<code>onStop()</code>：是一个Activity的可见生存周期。此时Activity对于用户是可见的，但不一定可以进行交互。可以进行资源管理避免占用过多内存。</li><li><code>onResume()</code>–&gt;<code>onPause()</code>：是一个Activity的前台生存期。此时Activity处于运行状态，并且可以进行交互。</li></ul><h3 id="体验不同的生命周期"><a href="#体验不同的生命周期" class="headerlink" title="体验不同的生命周期"></a>体验不同的生命周期</h3><ol><li>创建两个Activity，分别为一般的Activity和对话框式的Activity，在<code>AndoridManifest.xml</code>设置对应的属性：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--一般的Activity--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MainActivity2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--对话框式Activity--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MainActivity3&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/Theme.AppCompat.Dialog&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>在主Activity中设置两个按钮，分别用于跳转到对应的Activity：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_main);<br>    Log.d(<span class="hljs-string">&quot;tags&quot;</span>, <span class="hljs-string">&quot;onCreate&quot;</span>);<br><br>    <span class="hljs-comment">// 跳转一般Activity的按钮</span><br>    findViewById(R.id.normal_button).setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>            Intent intent = <span class="hljs-keyword">new</span> Intent(getApplicationContext(), MainActivity2.class);<br>            startActivity(intent);<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-comment">// 跳转对话框式Activity的按钮</span><br>    findViewById(R.id.dialog_button).setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>            Intent intent = <span class="hljs-keyword">new</span> Intent(getApplicationContext(), MainActivity3.class);<br>            startActivity(intent);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在主Activity中重写<code>onStart</code>、<code>onResume</code>、<code>onPause</code>、<code>onStop</code>、<code>onRestart</code>和<code>onDestroy</code>方法，在其中打印日志明确该方法被调用。</li><li>测试日志：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs log">// 启动第一个Activity<br>2021-07-23 14:13:45.790 10152-10152/com.example.myapplication2 XXX: onCreate<br>2021-07-23 14:13:45.794 10152-10152/com.example.myapplication2 XXX: onStart<br>2021-07-23 14:13:45.796 10152-10152/com.example.myapplication2 XXX: onResume<br><br>// 唤起第二个Activity<br>2021-07-23 14:15:45.779 10152-10152/com.example.myapplication2 XXX: onPause<br>2021-07-23 14:15:46.322 10152-10152/com.example.myapplication2 XXX: onStop<br><br>// 返回第一个Activity<br>2021-07-23 14:16:15.592 10152-10152/com.example.myapplication2 XXX: onRestart<br>2021-07-23 14:16:15.593 10152-10152/com.example.myapplication2 XXX: onStart<br>2021-07-23 14:16:15.594 10152-10152/com.example.myapplication2 XXX: onResume<br><br>// 唤醒对话框式Activity<br>2021-07-23 14:17:01.660 10152-10152/com.example.myapplication2 XXX: onPause<br><br>// 从对话框式Activity中返回<br>2021-07-23 14:17:56.237 10152-10152/com.example.myapplication2 XXX: onResume<br></code></pre></td></tr></table></figure></li></ol><h3 id="Activity被回收"><a href="#Activity被回收" class="headerlink" title="Activity被回收"></a>Activity被回收</h3><p>但一个Activity被回收后，重新进入需要重新经历创建Activity过程。<br>而Activity中的状态和成员变量由于没有保存而消失，可以通过<code>onSaveInstanceState</code>回调方法确保Activity被销毁时保存状态信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@NotNull</span> Bundle outState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onSaveInstanceState(outState);<br>    outState.putString(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>); <span class="hljs-comment">// 以(key, value)形式将数据保存到Bundle</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>onCreate</code>方法中由变量<code>savedInstanceState</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (savedInstanceState != <span class="hljs-keyword">null</span>) &#123;<br>    String value = savedInstanceState.getString(<span class="hljs-string">&quot;key&quot;</span>); <span class="hljs-comment">// 根据key获取对应的value</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：可以将数据保存到<code>Bundle</code>中，然后将<code>Bundle</code>保存到<code>Intent</code>中。</p></blockquote><hr><h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><blockquote><p>Activity共有四种启动模式：</p><ul><li><strong>standard</strong></li><li><strong>singleTop</strong></li><li><strong>singleTask</strong></li><li><strong>singleInstance</strong></li></ul></blockquote><table><thead><tr><th>模式</th><th>特点</th><th>图示</th></tr></thead><tbody><tr><td>standard</td><td>每次启动一个Activity，都会在返回栈中入栈。无论返回栈是否有相同的Activity，都会在栈顶创建新实例</td><td><img src="../../../imgs/standardmode.jpg"></td></tr><tr><td>singleTop</td><td>启动Activity时，若发现为相同的Activity时，则直接使用；否则创建新的Activity入栈。</td><td><img src="../../../imgs/singletopmode.jpg"></td></tr><tr><td>singleTask</td><td>singleTop模式可能在一个返回栈创建多个相同的Activity。若要Activity在整个应用的上下文中只有一个实例，使用singleTask。</td><td><img src="../../../imgs/singletaskmode.jpg"></td></tr><tr><td>singleInstance</td><td>不同的应用的Activity共用同一个返回栈，系统只有一个Activity实例</td><td><img src="../../../imgs/singleinstancemode.jpg"></td></tr></tbody></table><blockquote><p>注意：</p><ol><li><strong>singleTask</strong>模式：启动Activity时，会先检查返回栈是否存在该Activity的实例。<blockquote><ul><li>若不存在，则创建新的Activity并入栈在栈顶。</li><li>若存在，则将<strong>该Activity上面的所有Activity都出栈</strong>，并且直接使用该Activity。</li></ul></blockquote></li><li><strong>singleInstance</strong>模式：返回模式是按照返回栈中的Activity排列顺序。一般是将当前Activity所在的返回栈中的所有Activity出栈然后到其他的返回栈。</li></ol></blockquote><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://book.douban.com/subject/34996842/">《第一行代码》-第三章</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>UILayout</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/4UILayout/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/4UILayout/</url>
    
    <content type="html"><![CDATA[<h1 id="4-UILayout"><a href="#4-UILayout" class="headerlink" title="4. UILayout"></a>4. UILayout</h1><p>[toc]</p><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr><h2 id="三种基本布局"><a href="#三种基本布局" class="headerlink" title="三种基本布局"></a>三种基本布局</h2><p>基本概念：</p><ul><li>一个界面是由多个组件组成。</li><li>布局（layout）是一个可以放多个控件的容器，按照一定的规律调整内部控件的位置。</li><li>布局可以放置控件，也可以放置布局，实现多层嵌套。</li></ul><p><img src="../../../imgs/layoutstructure.jpg"></p><h3 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h3><p>LinearLayout：线性布局。</p><ul><li>所包含的组件在线性方向上依次排列。</li><li>通过<code>orientation</code>指定排列方向是<code>vertical</code>或<code>horizontal</code>。</li><li>当指定排列方向时，组件在该方向不能为<code>match parent</code>，否则导致组件占满，导致其他组件无法放置。</li><li><code>layout_gravity</code>：表示控件在布局中的对齐方式，可以居中“center”，向上“top”或向下“bottom”等。</li><li><code>gravity</code>：表示文字在控件内部的对齐方式，选项类似。</li><li><code>layout_weight</code>：按照指定的比例控制控件的大小。</li><li>将其他组件设为<code>layout_width=&quot;wrap_content&quot;</code>，一个组件设为<code>layout_weight=&quot;1&quot;</code>来使得其他组件固定大小，而一个组件填充剩下的空间。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--将layout_width设为0dp,通过layout_weight设置不同组件之间的比例--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/edittext2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:hint</span>=<span class="hljs-string">&quot;Input message&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button7&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Button 7&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a>RelativeLayout</h3><ul><li>RelativeLayout：相对布局，通过相对定位的方式让控件出现在布局的任何位置。</li><li><code>layout_alignParentTop=&quot;true&quot;</code>：用来控制控件相对于父布局的上方对齐。<code>layout_alignParentLeft</code>：相对于父布局的左边对齐。<code>layout_centerInParent</code>：在父布局居中对齐。</li><li><code>layout_above</code>：相对于指定控件上方。<code>layout_toLeftof</code>：相对于指定控件左侧。</li><li><code>layout_alignTop</code>：与指定控件上侧边缘对齐；<code>layout_alignLeft</code>：与指定控件左侧边缘对齐。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity5&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button9&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_centerInParent</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Button 9&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button10&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Button 10&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_above</span>=<span class="hljs-string">&quot;@+id/button9&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_toRightOf</span>=<span class="hljs-string">&quot;@+id/button9&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button11&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_below</span>=<span class="hljs-string">&quot;@+id/button9&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_toLeftOf</span>=<span class="hljs-string">&quot;@+id/button9&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Button 11&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="FrameLayout"><a href="#FrameLayout" class="headerlink" title="FrameLayout"></a>FrameLayout</h3><ul><li>FrameLayout：帧布局，默认放置在布局的左上角。</li><li>允许不同的控件相互遮蔽，后定义的控件掩盖前定义的控件。</li><li>一般通过<code>layout_gravity</code>控制控件之间的布局。</li></ul><hr><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><p>控件与布局的结构关系：<br><img src="../../../imgs/widgetlayout.jpg"></p><p>其中：</p><ul><li><code>View</code>：基本的UI组件，在屏幕上绘制矩形区域。</li><li><code>ViewGroup</code>：特殊的<code>View</code>，放置控件和布局的容器。</li></ul><p>自定义的控件流程：</p><ol><li>构建自定义的布局。在自定义的布局文件<code>layout.xml</code>中设置布局分布。</li></ol><ul><li>可以直接将自定义的布局引用到目标布局文件中：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/&lt;layout_file&gt;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>创建自定义控件：为了避免引入布局需要编写注册布局的代码，可以自定义控件。<ul><li>新建类，用于成为自定义控件。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelfLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinearLayout</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SelfLayout</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, attrs);<br>        LayoutInflater.from(context).inflate(R.layout.layout, <span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>注意：在构造器中对布局进行动态加载，通过<code>LayoutInflater</code>的<code>from</code>方法构建<code>LayoutInflater</code>对象。调用<code>inflate</code>方法动态加载布局文件。其中第一个参数为要加载文件的布局文件id，第二个参数为加载的布局设置父布局。</p><ol start="3"><li>使用控件。在目标布局文件中引入控件：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.example.myapplication2.SelfLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><ul><li>ListView表现为可以滑动的列表，每一个数据表示为一项。</li><li>无法一次在屏幕中显示所有的信息，通过滑动方式展示更多的信息。</li><li>通过滑动将屏幕外的数据滑动到屏幕内，使得屏幕内的数据滚动出屏幕。</li></ul><h3 id="定制ListView界面"><a href="#定制ListView界面" class="headerlink" title="定制ListView界面"></a>定制ListView界面</h3><blockquote><p>ListView中的每一项由一个图片和一个文字组成。</p></blockquote><p>构建流程：</p><ol><li>定义实体类，用于表示ListView中的子项。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> imageId;<br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fruit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> imageId, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.imageId = imageId;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>为ListView的子项设定自定义的布局：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;60dp&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/imageview1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;40dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;40dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;10dp&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textview2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;10dp&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>创建自定义的适配器，继承自<code>ArrayAdapter</code>，将其泛型指定为<code>Fruit</code>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArrayAdapter</span>&lt;<span class="hljs-title">Fruit</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Context context;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> resource;<br>    <span class="hljs-keyword">private</span> List&lt;Fruit&gt; objects;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FruitAdapter</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@NotNull</span> Context context, <span class="hljs-keyword">int</span> resource, <span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@NotNull</span> List&lt;Fruit&gt; objects)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, resource, objects);<br>        <span class="hljs-keyword">this</span>.context = context;<br>        <span class="hljs-keyword">this</span>.resource = resource;<br>        <span class="hljs-keyword">this</span>.objects = objects;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressLint(&quot;ViewHolder&quot;)</span><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">getView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-meta">@Nullable</span> View convertView, <span class="hljs-meta">@NonNull</span> ViewGroup parent)</span> </span>&#123;<br>        View view = LayoutInflater.from(getContext()).inflate(resource, parent, <span class="hljs-keyword">false</span>);<br>        ImageView image = (ImageView) view.findViewById(R.id.imageview1);<br>        TextView name = (TextView) view.findViewById(R.id.textview2);<br>        Fruit fruit = getItem(position);<br>        <span class="hljs-keyword">if</span> (fruit != <span class="hljs-keyword">null</span>) &#123;<br>            image.setImageResource(fruit.imageId);<br>            name.setText(fruit.name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> view;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>创建<code>ListView</code>布局：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ListView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/listview1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>在主Activity中修改展示方式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ListView listView;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.listview_layout);<br>        <span class="hljs-comment">// 添加数据源</span><br>        List&lt;Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) list.add(<span class="hljs-keyword">new</span> Fruit(R.drawable.apple, <span class="hljs-string">&quot;data &quot;</span> + i));<br>            <span class="hljs-keyword">else</span> list.add(<span class="hljs-keyword">new</span> Fruit(R.drawable.banana, <span class="hljs-string">&quot;data &quot;</span> + i));<br>        &#125;<br>        <span class="hljs-comment">// 构建适配器</span><br>        FruitAdapter adapter = <span class="hljs-keyword">new</span> FruitAdapter(<span class="hljs-keyword">this</span>, R.layout.item_layout, list);<br>        listView = (ListView)findViewById(R.id.listview1);<br>        listView.setAdapter(adapter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="提升ListView的效率"><a href="#提升ListView的效率" class="headerlink" title="提升ListView的效率"></a>提升<code>ListView</code>的效率</h3><p>性能缺陷:</p><ul><li>当滑动时，<code>getView()</code>方法都将布局重新加载一遍。</li><li>重复调用<code>View</code>的<code>findViewById()</code>方法获取一次控件的实例。</li></ul><p>优化:</p><ul><li>参数<code>convertView</code>用来将之前加载好的布局进行缓存，以便之后进行重用。</li><li>创建一个内部类，对布局中的<code>ImageView</code>和<code>TextView</code>控件进行缓存。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewHolder</span> </span>&#123;<br>    ImageView fruitImage;<br>    TextView fruitName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ViewHolder</span><span class="hljs-params">(ImageView fruitImage, TextView fruitName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.fruitImage = fruitImage;<br>        <span class="hljs-keyword">this</span>.fruitName = fruitName;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">getView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-meta">@Nullable</span> View convertView, <span class="hljs-meta">@NonNull</span> ViewGroup parent)</span> </span>&#123;<br>    View view;<br>    ViewHolder viewHolder;<br>    <span class="hljs-comment">// 没有缓存则创建缓存</span><br>    <span class="hljs-keyword">if</span> (convertView == <span class="hljs-keyword">null</span>) &#123;<br>        view = LayoutInflater.from(getContext()).inflate(resource, parent, <span class="hljs-keyword">false</span>);<br>        ImageView fruitImage = view.findViewById(R.id.imageview1);<br>        TextView fruitName = view.findViewById(R.id.textview2);<br>        viewHolder = <span class="hljs-keyword">new</span> ViewHolder(fruitImage, fruitName);<br>        view.setTag(viewHolder);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        view = convertView;<br>        viewHolder = (ViewHolder) view.getTag();<br>    &#125;<br>    Fruit fruit = getItem(position);<br>    <span class="hljs-keyword">if</span> (fruit != <span class="hljs-keyword">null</span>) &#123;<br>        viewHolder.fruitImage.setImageResource(fruit.imageId);<br>        viewHolder.fruitName.setText(fruit.name);<br>    &#125;<br>    <span class="hljs-keyword">return</span> view;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ListView的点击事件"><a href="#ListView的点击事件" class="headerlink" title="ListView的点击事件"></a><code>ListView</code>的点击事件</h3><p>为<code>ListView</code>中的每一项设置点击事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">listView.setOnItemClickListener(<span class="hljs-keyword">new</span> AdapterView.OnItemClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemClick</span><span class="hljs-params">(AdapterView&lt;?&gt; parent, View view, <span class="hljs-keyword">int</span> position, <span class="hljs-keyword">long</span> id)</span> </span>&#123;<br>        Fruit fruit = list.get(position);<br>        Toast.makeText(getApplicationContext(), <span class="hljs-string">&quot;You click on &quot;</span> + fruit.name,Toast.LENGTH_SHORT).show();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a><code>RecyclerView</code></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><code>RecyclerView</code>会在表项滑动出屏幕时不销毁该视图，而是对新出现的表项重用该视图。</li><li><code>RecyclerView</code>是一个<code>ViewGroup</code>，可以添加到布局中。</li><li><code>RecyclerView</code>中的每一表项都由<code>ViewHolder</code>对象定义，通过由<code>Adapter</code>将其绑定到对应的数据上。可以通过扩展<code>RecyclerView.Adapter</code>自定义<code>Adapter</code>。</li><li><code>LayoutManager</code>：为布局管理器，负责排列表中各元素的位置。</li></ul><p><code>RecyclerView</code>控件的特点：</p><ul><li>扩展性更好。</li><li>可以实现横向滑动和纵向滑动。</li><li>性能更好。</li></ul><h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><blockquote><p>流程：添加依赖。–&gt; 改写适配器类。–&gt; 编写Activity类。</p></blockquote><blockquote><p>注意：<code>RecyclerView</code>中每一项使用自定义类<code>Fruit</code>表示。</p></blockquote><ol><li>添加依赖：在<code>app/build.gradle</code>文件中的<code>dependenicies</code>项中添加依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">implementation &#x27;androidx.core:core-ktx:1.0.2&#x27;<br>implementation &#x27;androidx.recyclerview:recyclerview:1.0.0&#x27;<br></code></pre></td></tr></table></figure></li><li>编写适配器类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecyclerViewAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span>&lt;<span class="hljs-title">RecyclerViewAdapter</span>.<span class="hljs-title">ViewHolder</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Fruit&gt; fruitList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RecyclerViewAdapter</span><span class="hljs-params">(List&lt;Fruit&gt; fruitList)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.fruitList = fruitList;<br>    &#125;<br><br>    <span class="hljs-comment">// 内部类用于自定义的ViewHolder</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> ImageView imageView;<br>        <span class="hljs-keyword">private</span> TextView textView;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@NotNull</span> View itemView)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(itemView);<br>            imageView = (ImageView) itemView.findViewById(R.id.imageview1);<br>            textView = (TextView) itemView.findViewById(R.id.textview2);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建初始化ViewHolder和对应的View，不填充视图内容</span><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewHolder <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@NotNull</span> ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;<br>        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_layout, parent, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ViewHolder(view);<br>    &#125;<br><br>    <span class="hljs-comment">// 提取数据并填充到ViewHolder的布局</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@NotNull</span> RecyclerViewAdapter.ViewHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        Fruit fruit = fruitList.get(position);<br>        holder.textView.setText(fruit.name);<br>        holder.imageView.setImageResource(fruit.imageId);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取数据集的大小</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> fruitList.size();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li>在主Activity中使用<code>RecyclerView</code>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.recyclerview_layout);<br>    <span class="hljs-comment">// 准备数据</span><br>    List&lt;Fruit&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) list.add(<span class="hljs-keyword">new</span> Fruit(R.drawable.apple, <span class="hljs-string">&quot;data &quot;</span> + i));<br>        <span class="hljs-keyword">else</span> list.add(<span class="hljs-keyword">new</span> Fruit(R.drawable.banana, <span class="hljs-string">&quot;data &quot;</span> + i));<br>    &#125;<br>    <span class="hljs-comment">// 构造适配器</span><br>    RecyclerViewAdapter adapter = <span class="hljs-keyword">new</span> RecyclerViewAdapter(list);<br>    <span class="hljs-comment">// 构造布局管理器</span><br>    LinearLayoutManager layoutManager = <span class="hljs-keyword">new</span> LinearLayoutManager(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// 获取对应的RecyclerView</span><br>    <span class="hljs-meta">@SuppressLint(&quot;ResourceType&quot;)</span> RecyclerView recycleView = (RecyclerView) findViewById(R.id.recyclerview_layout);<br>    <span class="hljs-comment">// 配置LayoutManager和Adapter</span><br>    recycleView.setLayoutManager(layoutManager);<br>    recycleView.setAdapter(adapter);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="实现横向滚动和瀑布流布局"><a href="#实现横向滚动和瀑布流布局" class="headerlink" title="实现横向滚动和瀑布流布局"></a>实现横向滚动和瀑布流布局</h3><p>只需要在之前的纵向滚动布局上改动部分设置即可。</p><p>横向滚动：修改主Activity中布局管理器的设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);<br></code></pre></td></tr></table></figure><p>注意：同时修改表项布局文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;100dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/imageview1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;40dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;40dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;10dp&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textview2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;left&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;10dp&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>瀑布流布局：修改主Activity中的布局管理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">StaggeredGridLayoutManager layoutManager = <span class="hljs-keyword">new</span> StaggeredGridLayoutManager(<span class="hljs-number">3</span>, StaggeredGridLayoutManager.VERTICAL);<br></code></pre></td></tr></table></figure><p>以及对应的表项布局文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;100dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/imageview1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;40dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;40dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;10dp&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textview2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;left&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;10dp&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h3><p>在<code>RecyclerView</code>中点击事件是由具体的View所注册的。</p><p>只需要在Adapter类中注册对应的监听器即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ViewHolder <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@NotNull</span> ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;<br>    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_layout, parent, <span class="hljs-keyword">false</span>);<br>    ViewHolder viewHolder = <span class="hljs-keyword">new</span> ViewHolder(view);<br>    viewHolder.itemView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> position = viewHolder.getAdapterPosition();<br>            Fruit fruit = fruitList.get(position);<br>            Toast.makeText(parent.getContext(), <span class="hljs-string">&quot;You clicked view &quot;</span> + fruit.name, Toast.LENGTH_SHORT).show();<br>        &#125;<br>    &#125;);<br>    viewHolder.imageView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> position = viewHolder.getAdapterPosition();<br>            Fruit fruit = fruitList.get(position);<br>            Toast.makeText(parent.getContext(), <span class="hljs-string">&quot;You clicked image &quot;</span> + fruit.imageId, Toast.LENGTH_SHORT).show();<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> viewHolder;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><blockquote><p>构建一个聊天界面。</p></blockquote><ol><li>获取聊天框背景图片。</li><li>编写聊天主界面。</li><li>创建消息实体类型。</li><li>创建消息适配器。</li><li>编写主界面代码，注册监听器。</li></ol><p>聊天主界面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.recyclerview.widget.RecyclerView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/recycleview2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/edittext3&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:maxLines</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button14&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Send&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>聊天框布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;left&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/message_left&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textview3&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_margin</span>=<span class="hljs-string">&quot;10dp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>消息实体类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.myapplication2;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Msg</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> TYPE_RECEIVED = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> TYPE_SENT = <span class="hljs-number">0</span>;<br><br>    String content;<br>    <span class="hljs-keyword">int</span> type;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Msg</span><span class="hljs-params">(String content, <span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.content = content;<br>        <span class="hljs-keyword">this</span>.type = type;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消息适配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span>&lt;<span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span>&gt; </span>&#123;<br><br>    List&lt;Msg&gt; msgList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MsgAdapter</span><span class="hljs-params">(List&lt;Msg&gt; msgList)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.msgList = msgList;<br>    &#125;<br><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> RecyclerView.<span class="hljs-function">ViewHolder <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@NotNull</span> ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (viewType == Msg.TYPE_RECEIVED) &#123;<br>            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.msg_left, parent, <span class="hljs-keyword">false</span>);<br>            Log.d(<span class="hljs-string">&quot;receive&quot;</span>, <span class="hljs-string">&quot;1111111111: &quot;</span> + viewType);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LeftViewHolder(view);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.msg_right, parent, <span class="hljs-keyword">false</span>);<br>            Log.d(<span class="hljs-string">&quot;sent&quot;</span>, <span class="hljs-string">&quot;2222222222: &quot;</span> + viewType);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RightViewHolder(view);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@NotNull</span> RecyclerView.ViewHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        Msg msg = msgList.get(position);<br>        <span class="hljs-keyword">if</span> (holder <span class="hljs-keyword">instanceof</span> LeftViewHolder) ((LeftViewHolder) holder).leftMsg.setText(msg.content);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder <span class="hljs-keyword">instanceof</span> RightViewHolder) ((RightViewHolder) holder).rightMsg.setText(msg.content);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal message type&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> msgList.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> msgList.get(position).type;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span></span>&#123;<br>        View view;<br>        TextView leftMsg;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeftViewHolder</span><span class="hljs-params">(View view)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(view);<br>            <span class="hljs-keyword">this</span>.view = view;<br>            leftMsg = view.findViewById(R.id.textview3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RightViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span></span>&#123;<br>        View view;<br>        TextView rightMsg;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RightViewHolder</span><span class="hljs-params">(View view)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(view);<br>            <span class="hljs-keyword">this</span>.view = view;<br>            rightMsg = view.findViewById(R.id.textview4);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主界面逻辑代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity9</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">View</span>.<span class="hljs-title">OnClickListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Msg&gt; msgList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">private</span> MsgAdapter adapter = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.chat_layout);<br>        initMsg();<br>        LinearLayoutManager layoutManager = <span class="hljs-keyword">new</span> LinearLayoutManager(<span class="hljs-keyword">this</span>);<br>        RecyclerView recyclerview2 = (RecyclerView)findViewById(R.id.recycleview2);<br>        recyclerview2.setLayoutManager(layoutManager);<br>        adapter = <span class="hljs-keyword">new</span> MsgAdapter(msgList);<br>        recyclerview2.setAdapter(adapter);<br>        findViewById(R.id.button14).setOnClickListener(<span class="hljs-keyword">this</span>);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMsg</span><span class="hljs-params">()</span> </span>&#123;<br>        Msg msg1 = <span class="hljs-keyword">new</span> Msg(<span class="hljs-string">&quot;hello&quot;</span>, Msg.TYPE_RECEIVED);<br>        Msg msg2 = <span class="hljs-keyword">new</span> Msg(<span class="hljs-string">&quot;nice to meet you&quot;</span>, Msg.TYPE_SENT);<br>        Msg msg3 = <span class="hljs-keyword">new</span> Msg(<span class="hljs-string">&quot;nice to meet you too&quot;</span>, Msg.TYPE_RECEIVED);<br>        msgList.add(msg1);<br>        msgList.add(msg2);<br>        msgList.add(msg3);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        EditText text = (EditText)findViewById(R.id.edittext3);<br>        String s = text.getText().toString();<br>        <span class="hljs-keyword">if</span> (s.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            Msg msg = <span class="hljs-keyword">new</span> Msg(s, Msg.TYPE_SENT);<br>            msgList.add(msg);<br>            <span class="hljs-keyword">if</span> (adapter != <span class="hljs-keyword">null</span>) adapter.notifyItemInserted(msgList.size() - <span class="hljs-number">1</span>);<br>            RecyclerView recycler = (RecyclerView) findViewById(R.id.recycleview2);<br>            recycler.scrollToPosition(msgList.size() - <span class="hljs-number">1</span>);<br>            text.setText(<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://book.douban.com/subject/34996842/">《第一行代码》-第四章</a></li><li><a href="https://developer.android.com/guide/topics/ui/layout/recyclerview?hl=zh-cn#java">使用RecyclerView创建动态列表</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BroadcastReceiver</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/6BroadcastReceiver/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/6BroadcastReceiver/</url>
    
    <content type="html"><![CDATA[<h1 id="Broadcast-Receiver"><a href="#Broadcast-Receiver" class="headerlink" title="Broadcast Receiver"></a>Broadcast Receiver</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>广播可以来自系统，或者来自应用程序。</li><li>每个应用程序可以对感兴趣的广播进行注册，只接受特定的广播内容。</li><li>广播的分类：<ul><li><strong>标准广播</strong>(normal broadcast)</li><li><strong>有序广播</strong>(ordered broadcast)</li></ul></li></ul><p>|广播|同步/异步|接收特点|先后顺序|截断广播|图示|<br>|—|—|—|—|—|—|—|<br>|标准广播|异步执行|所有BroadcastReceiver几乎同时收到|不同BroadcastReceiver接收没有先后顺序|没有办法截断广播|<img src="../../../imgs/normalbroadcast.jpg">|<br>|有序广播|同步执行|同一时刻只有一个BroadcastReceiver收到广播|不同的BroadcastReceiver存在先后顺序|前面的BroadcastReceiver可以截断正在传递的广播|<img src="../../../imgs/orderedbroadcast.jpg">|</p><hr><h3 id="接受系统广播"><a href="#接受系统广播" class="headerlink" title="接受系统广播"></a>接受系统广播</h3><blockquote><p>Android内置许多系统级别的广播，通过监听系统广播，可以获得对应的系统的状态信息。</p></blockquote><h3 id="注册BroadcastReceiver"><a href="#注册BroadcastReceiver" class="headerlink" title="注册BroadcastReceiver"></a>注册BroadcastReceiver</h3><p>注册BroadcastReceiver有两种方式：</p><ul><li>动态注册：在代码中注册。必须在程序启动时才能接受广播。</li><li>静态注册：在<code>AndroidManifest.xml</code>中注册。程序未启动也可以监听系统广播。Android 8.0后隐式广播不允许使用静态注册方式接受。（隐式广播：没有指定发送给具体应用的广播）少部分系统广播可以通过静态注册方式接收。</li></ul><p>动态注册的流程：</p><ol><li>新建类，继承自<code>BroadcastReceiver</code>。</li><li>重写<code>onReceiver()</code>方法。</li><li>在需要监听广播时创建<code>BroadcastReceiver</code>进行监听。</li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建自定义的BroadcastReceiver类，重写onRecive方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBroadcastReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;<br>        Toast.makeText(context, <span class="hljs-string">&quot;another broadcast recevier received message&quot;</span>, Toast.LENGTH_SHORT).show();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//在需要监听广播时注册BroadcastReceiver</span><br>IntentFilter filter = <span class="hljs-keyword">new</span> IntentFilter();<br>filter.addAction(<span class="hljs-string">&quot;android.intent.action.TIME_TICK&quot;</span>); <span class="hljs-comment">// 添加特定系统广播</span><br>MyBroadcastReceiver br = <span class="hljs-keyword">new</span> MyBroadcastReceiver();<br>registerReceiver(receiver, filter);<br><br><span class="hljs-comment">// 取消注册BroadcastReceiver</span><br>unregisterReceiver(br);<br></code></pre></td></tr></table></figure><p>静态注册流程：</p><ol><li>新建类，继承自<code>BroadcastReceiver</code>。重写<code>onReceive()</code>方法。</li><li>在<code>AndroidManifest.xml</code>文件中注册。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;&lt;BroadcastReceiver Name&gt;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;&lt;special broadcast&gt;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：当程序进行敏感操作时，需要在<code>AndroidManifest.xml</code>文件中进行权限声明：<code>&lt;uses-permission android:name=&quot;special permission&quot; /&gt;</code>。</p><hr><h2 id="自定义广播"><a href="#自定义广播" class="headerlink" title="自定义广播"></a>自定义广播</h2><p>发送标准自定义广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义的BroadcastReceiver</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnotherBroadcastReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;<br>        Toast.makeText(context, <span class="hljs-string">&quot;received self broadcast&quot;</span>, Toast.LENGTH_SHORT).show();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在接收广播的地方注册</span><br>AnotherBroadcastReceiver receiver = <span class="hljs-keyword">new</span> AnotherBroadcastReceiver();<br>IntentFilter filter = <span class="hljs-keyword">new</span> IntentFilter();<br>filter.addAction(<span class="hljs-string">&quot;Self-defined Broadcast&quot;</span>); <span class="hljs-comment">// 自定义的广播</span><br>registerReceiver(receiver, filter);<br><br><span class="hljs-comment">// 发送广播</span><br>Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">&quot;Self-defined Broadcast&quot;</span>);<br><span class="hljs-comment">// intent.setPackage(package) // 若为隐式广播（自定义广播），则需要指定接收的应用</span><br>sendBroadcast(intent);<br></code></pre></td></tr></table></figure><p>发送有序广播：</p><p>只需要修改发送广播部分代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">&quot;Self-defined Broadcast&quot;</span>);<br><span class="hljs-comment">// intent.setPackage(package) // 若为隐式广播（自定义广播），则需要指定接收的应用</span><br>sendOrderedBroadcast(intent, <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><p>截断广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在特定的BroadcastReceiver中进行截断操作</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;<br>    <span class="hljs-comment">// 项目代码</span><br>    abortBroadcast();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><blockquote><p>一个通过广播实现强制下线的功能。</p></blockquote><p>登录界面布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.BR&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;80dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/edittext_name&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:maxLines</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;80dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Password&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/edittext_password&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:maxLines</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button_login&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Login&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>登录成功界面布局，设置按钮发送广播：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button_offline_broadcast&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Send force offline broadcast&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新建类，作为所有的Activity的父类，内置Activity容器，保存已创建的Activity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> ActivityCollection activityCollection = <span class="hljs-keyword">new</span> ActivityCollection();<br>    OfflineBroadcastReceiver receiver;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        activityCollection.addToCollection(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onResume();<br>        IntentFilter intentFilter = <span class="hljs-keyword">new</span> IntentFilter();<br>        intentFilter.addAction(<span class="hljs-string">&quot;com.example.broadcastreceiver.MY_BROADCAST&quot;</span>);<br>        receiver = <span class="hljs-keyword">new</span> OfflineBroadcastReceiver();<br>        registerReceiver(receiver, intentFilter);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onPause();<br>        unregisterReceiver(receiver);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onDestroy();<br>        activityCollection.removeActivity(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OfflineBroadcastReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;<br>            AlertDialog.Builder builder = <span class="hljs-keyword">new</span> AlertDialog.Builder(context);<br>            builder.setTitle(<span class="hljs-string">&quot;Warning&quot;</span>)<br>                    .setMessage(<span class="hljs-string">&quot;You have to re-login&quot;</span>)<br>                    .setCancelable(<span class="hljs-keyword">false</span>)<br>                    .setPositiveButton(<span class="hljs-string">&quot;OK&quot;</span>, <span class="hljs-keyword">new</span> DialogInterface.OnClickListener() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(DialogInterface dialog, <span class="hljs-keyword">int</span> which)</span> </span>&#123;<br>                            activityCollection.finishAll();<br>                            Intent toLogin = <span class="hljs-keyword">new</span> Intent(getApplicationContext(), BR.class);<br>                            startActivity(toLogin);<br>                        &#125;<br>                    &#125;).show();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>登录界面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BR</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseActivity</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_br);<br>        findViewById(R.id.button_login).setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View view)</span> </span>&#123;<br>                String name = ((EditText)findViewById(R.id.edittext_name)).getText().toString();<br>                String password = ((EditText)findViewById(R.id.edittext_password)).getText().toString();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(name) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(password)) &#123;<br>                    Intent login_succeed_intent = <span class="hljs-keyword">new</span> Intent(getApplicationContext(), MainActivity.class);<br>                    startActivity(login_succeed_intent);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    Toast.makeText(getApplicationContext(), <span class="hljs-string">&quot;Wrong username or password&quot;</span>, Toast.LENGTH_SHORT).show();<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        findViewById(R.id.button_sendbroadcast).setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>                AnotherBroadcastReceiver receiver = <span class="hljs-keyword">new</span> AnotherBroadcastReceiver();<br>                IntentFilter filter = <span class="hljs-keyword">new</span> IntentFilter();<br>                filter.addAction(<span class="hljs-string">&quot;Self-defined Broadcast&quot;</span>);<br>                registerReceiver(receiver, filter);<br>                Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">&quot;Self-defined Broadcast&quot;</span>);<br>                sendBroadcast(intent);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>登录成功界面，发送强制下线广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BR</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        activityCollection.addToCollection(<span class="hljs-keyword">this</span>);<br>        findViewById(R.id.button_offline_broadcast).setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>                Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">&quot;com.example.broadcastreceiver.MY_BROADCAST&quot;</span>);<br>                sendBroadcast(intent);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://book.douban.com/subject/34996842/">《第一行代码》-第六章</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Persistence</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/7Persistence/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/7Persistence/</url>
    
    <content type="html"><![CDATA[<h1 id="7-Persistence"><a href="#7-Persistence" class="headerlink" title="7. Persistence"></a>7. Persistence</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>持久化：应用运行时数据保存在内存中，属于瞬时状态，断电后会丢失数据。而持久化是将数据保存到硬盘中，处于持久状态，从而在断电后仍然保持数据。</p><p>Android提供三种持久化方式：</p><ul><li>文件存储</li><li>SharedPreferences存储</li><li>数据库存储</li></ul><h3 id="三种存储方式对比"><a href="#三种存储方式对比" class="headerlink" title="三种存储方式对比"></a>三种存储方式对比</h3><table><thead><tr><th>存储方式</th><th>特点</th><th>适用场景</th><th>文件路径</th></tr></thead><tbody><tr><td>文件存储</td><td>直接保存到特定的文件中</td><td>适用于简单文本和二进制数据</td><td><code>data/data/package_name/files/</code></td></tr><tr><td>SharedPrefences存储</td><td>使用键值对方式存储数据，支持不同的数据类型存储</td><td>结构化数据存储</td><td><code>data/data/package_name/shared_prefs/</code></td></tr><tr><td>SQLite数据库存储</td><td>支持SQL语句，遵循ACID事务</td><td>大量复杂的关系型数据</td><td><code>data/data/package_name/databases/</code></td></tr></tbody></table><hr><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><ul><li>通过<code>Context</code>类的<code>openFileOutput()</code>方法将数据保存到指定的文件中。通过<code>openFileInput()</code>方法从指定的文件中读取数据。</li><li>写入数据需要指定文件的操作模式：<code>MODE_PRIVATE</code>：存在同名文件时，写入的内容将覆盖文件中的内容；<code>MODE_APPEND</code>：若文件已经存在时，则向文件中追加内容。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = MainActivity.class.getSimpleName();<br><br>    EditText text = <span class="hljs-keyword">null</span>;<br>    Button button = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        text = (EditText) findViewById(R.id.edittext_datatofile);<br>        button = (Button) findViewById(R.id.button_savedatatofile); <br>        button.setOnClickListener(v -&gt; &#123;&#125;);<br>        String data = onRead();<br>        <span class="hljs-keyword">if</span> (data.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            Log.d(TAG, data);<br>            text.setText(data);<br>            text.setSelection(data.length());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onDestroy();<br>        <span class="hljs-keyword">if</span> (text.getText().toString().length() &gt; <span class="hljs-number">0</span>) &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;message is : &quot;</span> + text.getText().toString());<br>            onSave(text.getText().toString());<br>        &#125;<br>    &#125;<br><br> <span class="hljs-comment">// 将输入框中的文字保存到本地文件中</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSave</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        FileOutputStream fileOutputStream = <span class="hljs-keyword">null</span>;<br>        OutputStreamWriter outputStreamWriter = <span class="hljs-keyword">null</span>;<br>        BufferedWriter bufferedWriter = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fileOutputStream = openFileOutput(<span class="hljs-string">&quot;my_data&quot;</span>, MODE_PRIVATE);<br>            outputStreamWriter = <span class="hljs-keyword">new</span> OutputStreamWriter(fileOutputStream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            bufferedWriter = <span class="hljs-keyword">new</span> BufferedWriter(outputStreamWriter);<br>            bufferedWriter.write(data);<br>            bufferedWriter.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (fileOutputStream != <span class="hljs-keyword">null</span>) fileOutputStream.close();<br>                <span class="hljs-keyword">if</span> (outputStreamWriter != <span class="hljs-keyword">null</span>) outputStreamWriter.close();<br>                <span class="hljs-keyword">if</span> (bufferedWriter != <span class="hljs-keyword">null</span>) bufferedWriter.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 从文件中读取数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">onRead</span><span class="hljs-params">()</span> </span>&#123;<br>        FileInputStream inputStream = <span class="hljs-keyword">null</span>;<br>        InputStreamReader reader = <span class="hljs-keyword">null</span>;<br>        BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = openFileInput(<span class="hljs-string">&quot;my_data&quot;</span>);<br>            reader = <span class="hljs-keyword">new</span> InputStreamReader(inputStream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(reader);<br>            <span class="hljs-keyword">while</span> (bufferedReader.ready()) &#123;<br>                sb.append((<span class="hljs-keyword">char</span>)bufferedReader.read());<br>            &#125;<br>            Log.d(TAG, sb.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (reader != <span class="hljs-keyword">null</span>) reader.close();<br>                <span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) bufferedReader.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> sb.toString();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a><code>SharedPreferences</code>存储</h2><ul><li>使用键值对存储数据。</li><li>通过key可以获得对应的值。</li><li>支持多种数据类型，存入和取出的数据类型保持一致。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>基本流程：</p><ol><li>通过<code>getSharedPreferences()</code>方法获得<code>SharedPreferences</code></li><li>由<code>SharedPreferences</code>对象获取对应的<code>SharedPreferences.Editor</code>对象</li><li>通过<code>putXXX(key, value)</code>方法存储数据。如<code>putString()</code>，<code>putInt()</code>等。</li><li>存入数据后需要通过<code>commit()</code>或<code>apply()</code>方法提交修改。</li><li>通过<code>SharedPreferences</code>对象的<code>getXXX(key, default)</code>方法获得对应的数据。</li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogin</span><span class="hljs-params">()</span> </span>&#123;<br>SharedPreferences.Editor editor = getSharedPreferences(path, MODE_PRIVATE).edit(); <span class="hljs-comment">// path：指定文件名</span><br><span class="hljs-keyword">if</span> (rememberPassword.isChecked()) &#123;<br>    editor.putString(<span class="hljs-string">&quot;username&quot;</span>, userName.getText().toString()); <span class="hljs-comment">// 存放String类型数据</span><br>    editor.putString(<span class="hljs-string">&quot;password&quot;</span>, password.getText().toString());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (sharedPreferences.contains(<span class="hljs-string">&quot;username&quot;</span>)) editor.remove(<span class="hljs-string">&quot;username&quot;</span>); <span class="hljs-comment">// 删除指定的key</span><br>    <span class="hljs-keyword">if</span> (sharedPreferences.contains(<span class="hljs-string">&quot;password&quot;</span>)) editor.remove(<span class="hljs-string">&quot;password&quot;</span>);<br>&#125;<br>editor.apply(); <span class="hljs-comment">// 修改后必须提交</span><br>&#125;<br><br><span class="hljs-comment">// 获取指定key的数据，若没有则为指定的默认值</span><br>sharedPreferences.getString(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>sharedPreferences.getString(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br><br></code></pre></td></tr></table></figure><hr><h2 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h2><ul><li>支持标准SQL语法。</li><li>遵循数据库的ACID事务。</li></ul><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul><li>通过<code>SQLiteOpenHelper</code>抽象类对数据库进行创建和升级。</li><li>继承<code>SQLiteOpenHelper</code>类，重写<code>onCreate()</code>和<code>onUpgrade()</code>方法。</li><li>通过<code>SQLiteOpenHelper</code>获取对应的可读数据库<code>getReadableDatabase()</code>或可写数据库<code>getWritableDatabase()</code>。</li><li>创建的数据库文件保存在<code>/data/data/&lt;package_name&gt;/databases/</code>目录下。</li><li>SQLite中：<ul><li><code>integer</code>: 整型</li><li><code>real</code>: 浮点型</li><li><code>text</code>: 文本类型</li><li><code>blob</code>: 二进制类型</li></ul></li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义SQLiteOpenHelper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySQLiteHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SQLiteOpenHelper</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Context context;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> version;<br>    <span class="hljs-keyword">private</span> String createBookTable = <span class="hljs-string">&quot;create table Book (&quot;</span> +<br>            <span class="hljs-string">&quot; id integer primary key autoincrement, &quot;</span> +<br>            <span class="hljs-string">&quot;author text, &quot;</span> +<br>            <span class="hljs-string">&quot;prices real, &quot;</span> +<br>            <span class="hljs-string">&quot;pages integer, &quot;</span> +<br>            <span class="hljs-string">&quot;name text)&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MySQLiteHelper</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Context context, <span class="hljs-meta">@Nullable</span> String name, <span class="hljs-meta">@Nullable</span> SQLiteDatabase.CursorFactory factory, <span class="hljs-keyword">int</span> version)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, name, factory, version);<br>        <span class="hljs-keyword">this</span>.context = context;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.version = version;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(SQLiteDatabase db)</span> </span>&#123;<br>        db.execSQL(createBookTable);<br>        Toast.makeText(context, <span class="hljs-string">&quot;create table succeed&quot;</span>, Toast.LENGTH_SHORT).show();<br>    &#125;<br><br>    <br><br><br>&#125;<br><br><span class="hljs-comment">// 通过一个按钮触发数据库创建</span><br>findViewById(R.id.btn_createbooktable).setOnClickListener(v -&gt; &#123;<br>    mySQLiteHelper = <span class="hljs-keyword">new</span> MySQLiteHelper(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-keyword">null</span>, VERSION);<br>    writableDatabase = mySQLiteHelper.getWritableDatabase();<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h3><ul><li>通过<code>onUpgrade()</code>对数据库进行升级。</li><li>若创建的表已经存在，则会报错。所以在创建表时删除将要创建的表。</li><li>若需要<code>onUpgrade()</code>方法执行，需要保证对应的数据库版本号大于当前的版本号。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先删除将要创建的表</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpgrade</span><span class="hljs-params">(SQLiteDatabase db, <span class="hljs-keyword">int</span> oldVersion, <span class="hljs-keyword">int</span> newVersion)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.version = newVersion;<br>db.execSQL(<span class="hljs-string">&quot;DROP TABLE IF EXISTS book&quot;</span>);<br>db.execSQL(<span class="hljs-string">&quot;DROP TABLE IF EXISTS category&quot;</span>);<br>doSQL(db);<br>Toast.makeText(context, <span class="hljs-string">&quot;upgrade table succeed&quot;</span>, Toast.LENGTH_SHORT).show();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSQL</span><span class="hljs-params">(SQLiteDatabase db)</span> </span>&#123;<br>        db.execSQL(createBookTable);<br>        db.execSQL(createCategoryTable);<br>&#125;<br><br><span class="hljs-comment">// 然后获取对应的数据库，注意使用更高的版本号</span><br>findViewById(R.id.btn_upgradedatabase).setOnClickListener(v -&gt; &#123;<br>    mySQLiteHelper = <span class="hljs-keyword">new</span> MySQLiteHelper(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-keyword">null</span>, ++VERSION);<br>    writableDatabase = mySQLiteHelper.getWritableDatabase();<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><ul><li>通过<code>SQLiteDatabase</code>提供的<code>insert()</code>方法添加数据</li><li>通过执行原生的SQL语句添加数据</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// insert()方法需要指定数据库名、ContentValues对象（包装数据项）</span><br>ContentValues contentValues = <span class="hljs-keyword">new</span> ContentValues();<br>contentValues.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;book1&quot;</span>);<br>contentValues.put(<span class="hljs-string">&quot;author&quot;</span>, <span class="hljs-string">&quot;author1&quot;</span>);<br>contentValues.put(<span class="hljs-string">&quot;pages&quot;</span>, <span class="hljs-number">480</span>);<br>contentValues.put(<span class="hljs-string">&quot;prices&quot;</span>, <span class="hljs-number">12.2</span>);<br>writableDatabase.insert(<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-keyword">null</span>, contentValues);<br>ContentValues contentValues1 = <span class="hljs-keyword">new</span> ContentValues();<br>contentValues1.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;book2&quot;</span>);<br>contentValues1.put(<span class="hljs-string">&quot;author&quot;</span>, <span class="hljs-string">&quot;author2&quot;</span>);<br>contentValues1.put(<span class="hljs-string">&quot;pages&quot;</span>, <span class="hljs-number">502</span>);<br>contentValues1.put(<span class="hljs-string">&quot;prices&quot;</span>, <span class="hljs-number">23.9</span>);<br>writableDatabase.insert(<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-keyword">null</span>, contentValues1);<br>Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;add data succeed&quot;</span>, Toast.LENGTH_SHORT).show();<br><br><span class="hljs-comment">// 通过直接执行SQL</span><br>writableDatabase.execSQL(<span class="hljs-string">&quot;INSERT INTO book (name, author, pages, prices) values(?, ?, ?, ?)&quot;</span>, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;book1&quot;</span>, <span class="hljs-string">&quot;author1&quot;</span>, <span class="hljs-string">&quot;238&quot;</span>, <span class="hljs-string">&quot;21.93&quot;</span>&#125;);<br>writableDatabase.execSQL(<span class="hljs-string">&quot;INSERT INTO book (name, author, pages, prices) values(?, ?, ?, ?)&quot;</span>, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;book2&quot;</span>, <span class="hljs-string">&quot;author2&quot;</span>, <span class="hljs-string">&quot;765&quot;</span>, <span class="hljs-string">&quot;32.7&quot;</span>&#125;);<br></code></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><ul><li>通过<code>update()</code>方法更新数据</li><li>通过原生SQL更新数据</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过ContentValues构建更新项</span><br>ContentValues newValue = <span class="hljs-keyword">new</span> ContentValues();<br>newValue.put(<span class="hljs-string">&quot;prices&quot;</span>, <span class="hljs-number">10.99</span>);<br>writableDatabase.update(<span class="hljs-string">&quot;book&quot;</span>, newValue, <span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;book1&quot;</span>&#125;);<br><br><span class="hljs-comment">// 直接通过SQL进行更新</span><br>writableDatabase.execSQL(<span class="hljs-string">&quot;UPDATE book set prices = ? where name = ?&quot;</span>, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;28.8&quot;</span>, <span class="hljs-string">&quot;book1&quot;</span>&#125;);<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul><li>通过<code>delete</code>方法进行删除</li><li>原生SQL进行删除</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过delete方法删除</span><br>writableDatabase.delete(<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-string">&quot;pages &gt; ?&quot;</span>, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;500&quot;</span>&#125;);<br><br><span class="hljs-comment">// 原生SQL删除</span><br>writableDatabase.execSQL(<span class="hljs-string">&quot;DELETE FROM book where pages &gt; ?&quot;</span>, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;400&quot;</span>&#125;);<br></code></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><ul><li>通过<code>query()</code>方法获取<code>Cursor</code>对象，然后逐项获取对应的位置上的所有数据。</li><li>通过<code>rawQuery()</code>方法执行原生SQL语句获取<code>Cursor</code>对象。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过`query()`方法获得`Cursor`对象</span><br>Cursor cursor = writableDatabase.query(<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">if</span> (cursor.moveToFirst()) &#123;<br><span class="hljs-keyword">do</span> &#123;<br>    Log.d(TAG, <span class="hljs-string">&quot;name: &quot;</span> + cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;name&quot;</span>)) + <span class="hljs-string">&quot;, author: &quot;</span> + cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;author&quot;</span>)) + <span class="hljs-string">&quot;, pages: &quot;</span> + cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;pages&quot;</span>)) + <span class="hljs-string">&quot;, prices: &quot;</span> + cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;prices&quot;</span>)));<br>&#125; <span class="hljs-keyword">while</span> (cursor.moveToNext());<br>&#125;<br>cursor.close();<br><br><span class="hljs-comment">// 通过`rawQuery()`方法执行原生SQL获得`Cursor`对象</span><br>Cursor cursor = writableDatabase.rawQuery(<span class="hljs-string">&quot;SELECT * FROM book&quot;</span>, <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">if</span> (cursor.moveToFirst()) &#123;<br><span class="hljs-keyword">do</span> &#123;<br>    Log.d(TAG, <span class="hljs-string">&quot;name: &quot;</span> + cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;name&quot;</span>)) + <span class="hljs-string">&quot;, author: &quot;</span> + cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;author&quot;</span>)) + <span class="hljs-string">&quot;, pages: &quot;</span> + cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;pages&quot;</span>)) + <span class="hljs-string">&quot;, prices: &quot;</span> + cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;prices&quot;</span>)));<br>&#125; <span class="hljs-keyword">while</span> (cursor.moveToNext());<br>&#125;<br>cursor.close();<br></code></pre></td></tr></table></figure><h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><p>事务：一系列操作要么全部完成，要么全不完成。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 开始事项</span><br>writableDatabase.beginTransaction();<br><span class="hljs-keyword">try</span> &#123;<br>writableDatabase.delete(<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br><span class="hljs-comment">// 手动抛出异常，检查是否可以撤销之前的改动</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>writableDatabase.execSQL(<span class="hljs-string">&quot;INSERT INTO book (name, author, pages, prices) values(?, ?, ?, ?)&quot;</span>, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;book3&quot;</span>, <span class="hljs-string">&quot;author3&quot;</span>, <span class="hljs-string">&quot;840&quot;</span>, <span class="hljs-string">&quot;37.8&quot;</span>&#125;);<br><span class="hljs-comment">// 提交事务</span><br>writableDatabase.setTransactionSuccessful();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 结束事务</span><br>writableDatabase.endTransaction();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="升级数据库的最佳实践"><a href="#升级数据库的最佳实践" class="headerlink" title="升级数据库的最佳实践"></a>升级数据库的最佳实践</h3><ul><li>当指定的数据库版本号大于当前的数据库版本号时，会执行<code>onUpgrade()</code>方法进行更新操作。</li><li>为每个版本赋予对应的数据库修改。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpgrade</span><span class="hljs-params">(SQLiteDatabase db, <span class="hljs-keyword">int</span> oldVersion, <span class="hljs-keyword">int</span> newVersion)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.version = newVersion;<br><span class="hljs-keyword">if</span> (oldVersion &lt;= <span class="hljs-number">2</span>) db.execSQL(<span class="hljs-string">&quot;ALTER TABLE book ADD COLUMN category_id integer&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>每次对数据库进行升级时，都需要在<code>onUpgrade()</code>方法中使用<code>if</code>语句执行对应的修改。</li><li>保证数据库从哪个版本升级到最新的版本，都能获得一致的数据库。</li></ol><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://book.douban.com/subject/34996842/">第一行代码-第七章</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ContentProvider</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/8ContentProvider/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/8ContentProvider/</url>
    
    <content type="html"><![CDATA[<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><code>ContentProvider</code>提供与其他应用共享数据的接口。可使得其他应用安全地访问和修改应用的数据。</li><li>提供精细的数据访问权限控制，可以限制访问其他应用数据的权限，配置读写数据的权限。</li><li>使用<code>ContentProvider</code>对实现细节进行抽象，方便的访问应用中不同的数据源。</li></ul><p>不同应用通过<code>Content Provider</code>进行数据共享：<br><img src="../../../imgs/applicationcontentprovider.jpg"></p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ul><li><code>provider</code>和<code>provider client</code>提供数据访问的一致接口。<code>provider</code>提供数据，<code>provider client</code>用于获取数据。</li><li>若要获取应用提供的数据，可以通过<code>Context</code>的<code>ContentResolver</code>与<code>ContentProvider</code>进行通信。</li><li><code>ContentResolver</code>对象提供“CRUD”功能，其通过调用<code>ContentResolver</code>来实现对数据的操作。</li></ul><p><img src="../../../imgs/content-provider-interaction.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>播放多媒体</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/9Multimedia/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/9Multimedia/</url>
    
    <content type="html"><![CDATA[<h1 id="播放多媒体"><a href="#播放多媒体" class="headerlink" title="播放多媒体"></a>播放多媒体</h1><p>[toc]</p><hr><h2 id="播放音频"><a href="#播放音频" class="headerlink" title="播放音频"></a>播放音频</h2><ul><li>一般通过<code>MediaPlayer</code>类实现。</li></ul><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol><li>在项目根目录下创建目录<code>assets</code>，在该目录下放置音频文件。</li><li>分别对不同的按钮设置不同的功能。</li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Button btn_start, btn_pause, btn_stop;<br>    <span class="hljs-keyword">private</span> MediaPlayer mediaPlayer;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        btn_start = (Button) findViewById(R.id.btn_play);<br>        btn_pause = (Button) findViewById(R.id.btn_pause);<br>        btn_stop = (Button) findViewById(R.id.btn_stop);<br><br>        initMediaPlayer();<br><br>        btn_start.setOnClickListener(v -&gt; &#123;<br>            mediaPlayer.start();<br>        &#125;);<br><br>        btn_pause.setOnClickListener(v -&gt; &#123;<br>            mediaPlayer.pause();<br>        &#125;);<br><br>        btn_stop.setOnClickListener(v -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (mediaPlayer.isPlaying()) mediaPlayer.reset();<br>            initMediaPlayer();<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMediaPlayer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mediaPlayer = <span class="hljs-keyword">new</span> MediaPlayer();<br>            AssetFileDescriptor fd = getAssets().openFd(<span class="hljs-string">&quot;chinasong.wav&quot;</span>);<br>            mediaPlayer.setDataSource(fd.getFileDescriptor(), fd.getStartOffset(), fd.getLength());<br>            mediaPlayer.prepare();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onDestroy();<br>        mediaPlayer.stop();<br>        mediaPlayer.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h2><ul><li>通过<code>VideoView</code>播放视频。</li></ul><h3 id="基本流程-1"><a href="#基本流程-1" class="headerlink" title="基本流程"></a>基本流程</h3><ol><li>在<code>res</code>目录下创建文件夹<code>raw</code>，放置视频文件。</li><li>不同的按钮设置不同的功能。</li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Button btn_start, btn_pause, btn_stop;<br>    <span class="hljs-keyword">private</span> VideoView vv;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        btn_start = (Button) findViewById(R.id.btn_start);<br>        btn_pause = (Button) findViewById(R.id.btn_pause);<br>        btn_stop = (Button) findViewById(R.id.btn_stop);<br>        vv = (VideoView) findViewById(R.id.vv_video);<br><br>        Uri uri = Uri.parse(<span class="hljs-string">&quot;android.resource://&quot;</span> + getPackageName() + <span class="hljs-string">&quot;/&quot;</span> + R.raw.stay);<br>        Log.d(MainActivity.class.getSimpleName(), getPackageName());<br>        Log.d(MainActivity.class.getSimpleName(), uri.toString());<br>        vv.setVideoURI(uri);<br><br>        btn_start.setOnClickListener(v -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (!vv.isPlaying()) vv.start();<br>        &#125;);<br><br>        btn_pause.setOnClickListener(v -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (vv.isPlaying()) vv.pause();<br>        &#125;);<br><br>        btn_stop.setOnClickListener(v -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (vv.isPlaying()) vv.resume();<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onDestroy();<br>        vv.suspend();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Notification（通知）</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/9Notification/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/9Notification/</url>
    
    <content type="html"><![CDATA[<h1 id="Notification（通知）"><a href="#Notification（通知）" class="headerlink" title="Notification（通知）"></a>Notification（通知）</h1><p>[toc]</p><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>若应用不再前台但需要向用户发出提示信息，可以通过通知实现。</li><li>通知显示在状态栏上，并在下拉栏中可以看到详细信息。</li><li>Android中对通知进行划分，每条通知对应一个渠道。用户可以关闭特定通知渠道，从而该通知渠道的所有通知将不会再显示。</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>获取通知管理。</li><li>构建通知渠道，创建通知渠道。</li><li>由<code>NotificationCompat.Builder</code>构建通知。</li><li>发送通知。</li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取通知管理者</span><br>NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);<br><br><span class="hljs-comment">// 构建通知渠道，分别填入渠道id，渠道名和渠道重要性</span><br>NotificationChannel channel = <span class="hljs-keyword">new</span> NotificationChannel(<span class="hljs-string">&quot;channel_id&quot;</span>, <span class="hljs-string">&quot;channal_name&quot;</span>, NotificationManager.IMPORTANCE_LOW);<br><br><span class="hljs-comment">// 由通知管理者创建通知渠道</span><br>manager.createNotificationChannel(channel);<br><br><span class="hljs-comment">// 设置用户点击通知的逻辑</span><br>Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, MainActivity.class);<br><span class="hljs-comment">// 由延迟Intent构建点击逻辑</span><br>PendingIntent pi = PendingIntent.getActivities(<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> Intent[]&#123;intent&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 构建通知，填入对应的渠道id</span><br><span class="hljs-comment">// 分别设置通知的标题，内容，大文本，图片，小图标，点击逻辑，点击后是否取消N</span><br>Notification notification = <span class="hljs-keyword">new</span> NotificationCompat.Builder(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;channel_id&quot;</span>)<br>    .setContentTitle(<span class="hljs-string">&quot;this is a title&quot;</span>)<br>    .setContentText(<span class="hljs-string">&quot;this is a text&quot;</span>)<br>    .setStyle(<span class="hljs-keyword">new</span> NotificationCompat.BigTextStyle().bigText(<span class="hljs-string">&quot;there is long text&quot;</span>))<br>    .setStyle(<span class="hljs-keyword">new</span> NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(), R.drawable.bigpicture)))<br>    .setSmallIcon(R.drawable.small_icon)<br>    .setContentIntent(pi)<br>    .setAutoCancel(<span class="hljs-keyword">true</span>)<br>    .build();<br><br><span class="hljs-comment">// 发送通知</span><br>manager.notify(<span class="hljs-number">1</span>, notification);<br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://book.douban.com/subject/34996842/">《第一行代码》-第九章》</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android中Context学习小结</title>
    <link href="/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/allaboutcontext/"/>
    <url>/TrueStoriesavici01.github.io/2021/12/21/myworkspaces/readnotes/android/thefirstlinecode/allaboutcontext/</url>
    
    <content type="html"><![CDATA[<h1 id="Android中Context学习小结"><a href="#Android中Context学习小结" class="headerlink" title="Android中Context学习小结"></a>Android中Context学习小结</h1><p>[toc]</p><hr><h1 id="Context简介"><a href="#Context简介" class="headerlink" title="Context简介"></a>Context简介</h1><ul><li><code>Context</code>是一个表示应用运行环境的全局变量的抽象接口。</li><li>可以通过<code>Context</code>访问特定应用的资源，通过<code>Context</code>实现诸如启动Activity、发送Broadcast和接受Intent等操作。</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://duanqz.github.io/2017-12-25-Android-Context#12-%E5%85%B3%E4%BA%8Edecorator%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">Android Context的设计思想和源码分析</a></li><li><a href="http://gityuan.com/2017/04/09/android_context/">理解Android Context</a></li><li><a href="https://www.jianshu.com/p/c5efb41f2ef0">Android各种Context的前世今生</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
